# Rule: replace-mock-with-api

## Scope

This rule applies to the Circle project files that currently import data from `mock-data/*` or use the prototype Zustand store. It guides the assistant to remove dependencies on in‑memory mocks and replace them with calls to the real backend.

## Instruction

* **No mock data** — Do not import or reference any files from `mock-data/*` in new or updated code. These files were used in the Circle prototype to provide static lists of tasks, teams, projects and cycles. Similarly, avoid using the existing Zustand store functions for CRUD actions.
* **Use Supabase** — For all data operations, call the Supabase database through `@supabase/supabase-js`. For example, to load tasks for a team:
  ```ts
  const { data: tasks, error } = await supabase.from('task')
    .select('*')
    .eq('team_id', teamId);
  ```
  To create a new record, call `.insert([...])`, and to update an existing record call `.update({...}).eq('id', id)`. Remember to refresh the client cache (e.g. by invalidating TanStack Query queries) after mutations.
* **Server state** — Prefer using a data fetching library like TanStack Query or SWR to manage server state. Do not replicate Supabase data in a global store; instead, fetch data where it is needed and cache it using the query library.
* **Action handlers** — Replace calls such as `removeNotification`, `addIssue`, or `updateProject` with functions that perform the corresponding mutation on the Supabase tables and then refresh the affected queries.
* **Preserve UI** — The structure and styling of pages and components should remain the same. Only the data sources and side effects should change.

## Anti‑patterns

* Importing anything from `mock-data/*` or referencing the prototype store in production code.
* Logging actions to the console instead of performing real API calls.
* Maintaining duplicate copies of the same data in multiple stores; always treat Supabase as the single source of truth.