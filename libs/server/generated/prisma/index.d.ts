/**
 * Client
 **/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types; // general types
import $Public = runtime.Types.Public;
import $Utils = runtime.Types.Utils;
import $Extensions = runtime.Types.Extensions;
import $Result = runtime.Types.Result;

export type PrismaPromise<T> = $Public.PrismaPromise<T>;

/**
 * Model Task
 *
 */
export type Task = $Result.DefaultSelection<Prisma.$TaskPayload>;
/**
 * Model Subtask
 *
 */
export type Subtask = $Result.DefaultSelection<Prisma.$SubtaskPayload>;
/**
 * Model TaskDependency
 *
 */
export type TaskDependency = $Result.DefaultSelection<Prisma.$TaskDependencyPayload>;
/**
 * Model TaskMasterMetadata
 *
 */
export type TaskMasterMetadata = $Result.DefaultSelection<Prisma.$TaskMasterMetadataPayload>;
/**
 * Model SyncOperation
 *
 */
export type SyncOperation = $Result.DefaultSelection<Prisma.$SyncOperationPayload>;
/**
 * Model SyncConflict
 *
 */
export type SyncConflict = $Result.DefaultSelection<Prisma.$SyncConflictPayload>;
/**
 * Model User
 *
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>;
/**
 * Model Project
 *
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>;
/**
 * Model Label
 *
 */
export type Label = $Result.DefaultSelection<Prisma.$LabelPayload>;
/**
 * Model IssueStatus
 *
 */
export type IssueStatus = $Result.DefaultSelection<Prisma.$IssueStatusPayload>;
/**
 * Model IssuePriority
 *
 */
export type IssuePriority = $Result.DefaultSelection<Prisma.$IssuePriorityPayload>;
/**
 * Model Issue
 *
 */
export type Issue = $Result.DefaultSelection<Prisma.$IssuePayload>;
/**
 * Model IssueLabel
 *
 */
export type IssueLabel = $Result.DefaultSelection<Prisma.$IssueLabelPayload>;
/**
 * Model Cycle
 *
 */
export type Cycle = $Result.DefaultSelection<Prisma.$CyclePayload>;
/**
 * Model Team
 *
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>;
/**
 * Model TeamMember
 *
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>;
/**
 * Model TeamProject
 *
 */
export type TeamProject = $Result.DefaultSelection<Prisma.$TeamProjectPayload>;

/**
 * Enums
 */
export namespace $Enums {
   export const IssueType: {
      TASK: 'TASK';
      SUBTASK: 'SUBTASK';
   };

   export type IssueType = (typeof IssueType)[keyof typeof IssueType];

   export const UserStatus: {
      ONLINE: 'ONLINE';
      OFFLINE: 'OFFLINE';
      AWAY: 'AWAY';
   };

   export type UserStatus = (typeof UserStatus)[keyof typeof UserStatus];

   export const UserRole: {
      ADMIN: 'ADMIN';
      MEMBER: 'MEMBER';
      GUEST: 'GUEST';
   };

   export type UserRole = (typeof UserRole)[keyof typeof UserRole];

   export const ProjectHealth: {
      NO_UPDATE: 'NO_UPDATE';
      OFF_TRACK: 'OFF_TRACK';
      ON_TRACK: 'ON_TRACK';
      AT_RISK: 'AT_RISK';
   };

   export type ProjectHealth = (typeof ProjectHealth)[keyof typeof ProjectHealth];
}

export type IssueType = $Enums.IssueType;

export const IssueType: typeof $Enums.IssueType;

export type UserStatus = $Enums.UserStatus;

export const UserStatus: typeof $Enums.UserStatus;

export type UserRole = $Enums.UserRole;

export const UserRole: typeof $Enums.UserRole;

export type ProjectHealth = $Enums.ProjectHealth;

export const ProjectHealth: typeof $Enums.ProjectHealth;

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tasks
 * const tasks = await prisma.task.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
   ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
   U = 'log' extends keyof ClientOptions
      ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition>
         ? Prisma.GetEvents<ClientOptions['log']>
         : never
      : never,
   ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
> {
   [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] };

   /**
    * ##  Prisma Client ʲˢ
    *
    * Type-safe database client for TypeScript & Node.js
    * @example
    * ```
    * const prisma = new PrismaClient()
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    *
    *
    * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
    */

   constructor(optionsArg?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
   $on<V extends U>(
      eventType: V,
      callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void
   ): PrismaClient;

   /**
    * Connect with the database
    */
   $connect(): $Utils.JsPromise<void>;

   /**
    * Disconnect from the database
    */
   $disconnect(): $Utils.JsPromise<void>;

   /**
    * Add a middleware
    * @deprecated since 4.16.0. For new code, prefer client extensions instead.
    * @see https://pris.ly/d/extensions
    */
   $use(cb: Prisma.Middleware): void;

   /**
    * Executes a prepared raw query and returns the number of affected rows.
    * @example
    * ```
    * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
    * ```
    *
    * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
    */
   $executeRaw<T = unknown>(
      query: TemplateStringsArray | Prisma.Sql,
      ...values: any[]
   ): Prisma.PrismaPromise<number>;

   /**
    * Executes a raw query and returns the number of affected rows.
    * Susceptible to SQL injections, see documentation.
    * @example
    * ```
    * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
    * ```
    *
    * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
    */
   $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

   /**
    * Performs a prepared raw query and returns the `SELECT` data.
    * @example
    * ```
    * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
    * ```
    *
    * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
    */
   $queryRaw<T = unknown>(
      query: TemplateStringsArray | Prisma.Sql,
      ...values: any[]
   ): Prisma.PrismaPromise<T>;

   /**
    * Performs a raw query and returns the `SELECT` data.
    * Susceptible to SQL injections, see documentation.
    * @example
    * ```
    * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
    * ```
    *
    * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
    */
   $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

   /**
    * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
    * @example
    * ```
    * const [george, bob, alice] = await prisma.$transaction([
    *   prisma.user.create({ data: { name: 'George' } }),
    *   prisma.user.create({ data: { name: 'Bob' } }),
    *   prisma.user.create({ data: { name: 'Alice' } }),
    * ])
    * ```
    *
    * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
    */
   $transaction<P extends Prisma.PrismaPromise<any>[]>(
      arg: [...P],
      options?: { isolationLevel?: Prisma.TransactionIsolationLevel }
   ): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>;

   $transaction<R>(
      fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>,
      options?: {
         maxWait?: number;
         timeout?: number;
         isolationLevel?: Prisma.TransactionIsolationLevel;
      }
   ): $Utils.JsPromise<R>;

   $extends: $Extensions.ExtendsHook<
      'extends',
      Prisma.TypeMapCb<ClientOptions>,
      ExtArgs,
      $Utils.Call<
         Prisma.TypeMapCb<ClientOptions>,
         {
            extArgs: ExtArgs;
         }
      >
   >;

   /**
    * `prisma.task`: Exposes CRUD operations for the **Task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tasks
    * const tasks = await prisma.task.findMany()
    * ```
    */
   get task(): Prisma.TaskDelegate<ExtArgs, ClientOptions>;

   /**
    * `prisma.subtask`: Exposes CRUD operations for the **Subtask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subtasks
    * const subtasks = await prisma.subtask.findMany()
    * ```
    */
   get subtask(): Prisma.SubtaskDelegate<ExtArgs, ClientOptions>;

   /**
    * `prisma.taskDependency`: Exposes CRUD operations for the **TaskDependency** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskDependencies
    * const taskDependencies = await prisma.taskDependency.findMany()
    * ```
    */
   get taskDependency(): Prisma.TaskDependencyDelegate<ExtArgs, ClientOptions>;

   /**
    * `prisma.taskMasterMetadata`: Exposes CRUD operations for the **TaskMasterMetadata** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TaskMasterMetadata
    * const taskMasterMetadata = await prisma.taskMasterMetadata.findMany()
    * ```
    */
   get taskMasterMetadata(): Prisma.TaskMasterMetadataDelegate<ExtArgs, ClientOptions>;

   /**
    * `prisma.syncOperation`: Exposes CRUD operations for the **SyncOperation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncOperations
    * const syncOperations = await prisma.syncOperation.findMany()
    * ```
    */
   get syncOperation(): Prisma.SyncOperationDelegate<ExtArgs, ClientOptions>;

   /**
    * `prisma.syncConflict`: Exposes CRUD operations for the **SyncConflict** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SyncConflicts
    * const syncConflicts = await prisma.syncConflict.findMany()
    * ```
    */
   get syncConflict(): Prisma.SyncConflictDelegate<ExtArgs, ClientOptions>;

   /**
    * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
   get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

   /**
    * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
   get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

   /**
    * `prisma.label`: Exposes CRUD operations for the **Label** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Labels
    * const labels = await prisma.label.findMany()
    * ```
    */
   get label(): Prisma.LabelDelegate<ExtArgs, ClientOptions>;

   /**
    * `prisma.issueStatus`: Exposes CRUD operations for the **IssueStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IssueStatuses
    * const issueStatuses = await prisma.issueStatus.findMany()
    * ```
    */
   get issueStatus(): Prisma.IssueStatusDelegate<ExtArgs, ClientOptions>;

   /**
    * `prisma.issuePriority`: Exposes CRUD operations for the **IssuePriority** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IssuePriorities
    * const issuePriorities = await prisma.issuePriority.findMany()
    * ```
    */
   get issuePriority(): Prisma.IssuePriorityDelegate<ExtArgs, ClientOptions>;

   /**
    * `prisma.issue`: Exposes CRUD operations for the **Issue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Issues
    * const issues = await prisma.issue.findMany()
    * ```
    */
   get issue(): Prisma.IssueDelegate<ExtArgs, ClientOptions>;

   /**
    * `prisma.issueLabel`: Exposes CRUD operations for the **IssueLabel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more IssueLabels
    * const issueLabels = await prisma.issueLabel.findMany()
    * ```
    */
   get issueLabel(): Prisma.IssueLabelDelegate<ExtArgs, ClientOptions>;

   /**
    * `prisma.cycle`: Exposes CRUD operations for the **Cycle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cycles
    * const cycles = await prisma.cycle.findMany()
    * ```
    */
   get cycle(): Prisma.CycleDelegate<ExtArgs, ClientOptions>;

   /**
    * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
   get team(): Prisma.TeamDelegate<ExtArgs, ClientOptions>;

   /**
    * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
   get teamMember(): Prisma.TeamMemberDelegate<ExtArgs, ClientOptions>;

   /**
    * `prisma.teamProject`: Exposes CRUD operations for the **TeamProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamProjects
    * const teamProjects = await prisma.teamProject.findMany()
    * ```
    */
   get teamProject(): Prisma.TeamProjectDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
   export import DMMF = runtime.DMMF;

   export type PrismaPromise<T> = $Public.PrismaPromise<T>;

   /**
    * Validator
    */
   export import validator = runtime.Public.validator;

   /**
    * Prisma Errors
    */
   export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError;
   export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError;
   export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError;
   export import PrismaClientInitializationError = runtime.PrismaClientInitializationError;
   export import PrismaClientValidationError = runtime.PrismaClientValidationError;

   /**
    * Re-export of sql-template-tag
    */
   export import sql = runtime.sqltag;
   export import empty = runtime.empty;
   export import join = runtime.join;
   export import raw = runtime.raw;
   export import Sql = runtime.Sql;

   /**
    * Decimal.js
    */
   export import Decimal = runtime.Decimal;

   export type DecimalJsLike = runtime.DecimalJsLike;

   /**
    * Metrics
    */
   export type Metrics = runtime.Metrics;
   export type Metric<T> = runtime.Metric<T>;
   export type MetricHistogram = runtime.MetricHistogram;
   export type MetricHistogramBucket = runtime.MetricHistogramBucket;

   /**
    * Extensions
    */
   export import Extension = $Extensions.UserArgs;
   export import getExtensionContext = runtime.Extensions.getExtensionContext;
   export import Args = $Public.Args;
   export import Payload = $Public.Payload;
   export import Result = $Public.Result;
   export import Exact = $Public.Exact;

   /**
    * Prisma Client JS version: 6.12.0
    * Query Engine version: 8047c96bbd92db98a2abc7c9323ce77c02c89dbc
    */
   export type PrismaVersion = {
      client: string;
   };

   export const prismaVersion: PrismaVersion;

   /**
    * Utility Types
    */

   export import JsonObject = runtime.JsonObject;
   export import JsonArray = runtime.JsonArray;
   export import JsonValue = runtime.JsonValue;
   export import InputJsonObject = runtime.InputJsonObject;
   export import InputJsonArray = runtime.InputJsonArray;
   export import InputJsonValue = runtime.InputJsonValue;

   /**
    * Types of the values used to represent different kinds of `null` values when working with JSON fields.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
   namespace NullTypes {
      /**
       * Type of `Prisma.DbNull`.
       *
       * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
       *
       * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
       */
      class DbNull {
         private DbNull: never;
         private constructor();
      }

      /**
       * Type of `Prisma.JsonNull`.
       *
       * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
       *
       * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
       */
      class JsonNull {
         private JsonNull: never;
         private constructor();
      }

      /**
       * Type of `Prisma.AnyNull`.
       *
       * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
       *
       * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
       */
      class AnyNull {
         private AnyNull: never;
         private constructor();
      }
   }

   /**
    * Helper for filtering JSON entries that have `null` on the database (empty on the db)
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
   export const DbNull: NullTypes.DbNull;

   /**
    * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
   export const JsonNull: NullTypes.JsonNull;

   /**
    * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
   export const AnyNull: NullTypes.AnyNull;

   type SelectAndInclude = {
      select: any;
      include: any;
   };

   type SelectAndOmit = {
      select: any;
      omit: any;
   };

   /**
    * Get the type of the value, that the Promise holds.
    */
   export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

   /**
    * Get the return type of a function which returns a Promise.
    */
   export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<
      ReturnType<T>
   >;

   /**
    * From T, pick a set of properties whose keys are in the union K
    */
   type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
   };

   export type Enumerable<T> = T | Array<T>;

   export type RequiredKeys<T> = {
      [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K;
   }[keyof T];

   export type TruthyKeys<T> = keyof {
      [K in keyof T as T[K] extends false | undefined | null ? never : K]: K;
   };

   export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>;

   /**
    * Subset
    * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
    */
   export type Subset<T, U> = {
      [key in keyof T]: key extends keyof U ? T[key] : never;
   };

   /**
    * SelectSubset
    * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
    * Additionally, it validates, if both select and include are present. If the case, it errors.
    */
   export type SelectSubset<T, U> = {
      [key in keyof T]: key extends keyof U ? T[key] : never;
   } & (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {});

   /**
    * Subset + Intersection
    * @desc From `T` pick properties that exist in `U` and intersect `K`
    */
   export type SubsetIntersection<T, U, K> = {
      [key in keyof T]: key extends keyof U ? T[key] : never;
   } & K;

   type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

   /**
    * XOR is needed to have a real mutually exclusive union type
    * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
    */
   type XOR<T, U> = T extends object
      ? U extends object
         ? (Without<T, U> & U) | (Without<U, T> & T)
         : U
      : T;

   /**
    * Is T a Record?
    */
   type IsObject<T extends any> =
      T extends Array<any>
         ? False
         : T extends Date
           ? False
           : T extends Uint8Array
             ? False
             : T extends BigInt
               ? False
               : T extends object
                 ? True
                 : False;

   /**
    * If it's T[], return T
    */
   export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T;

   /**
    * From ts-toolbelt
    */

   type __Either<O extends object, K extends Key> = Omit<O, K> &
      {
         // Merge all but K
         [P in K]: Prisma__Pick<O, P & keyof O>; // With K possibilities
      }[K];

   type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>;

   type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>;

   type _Either<O extends object, K extends Key, strict extends Boolean> = {
      1: EitherStrict<O, K>;
      0: EitherLoose<O, K>;
   }[strict];

   type Either<O extends object, K extends Key, strict extends Boolean = 1> = O extends unknown
      ? _Either<O, K, strict>
      : never;

   export type Union = any;

   type PatchUndefined<O extends object, O1 extends object> = {
      [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K];
   } & {};

   /** Helper Types for "Merge" **/
   export type IntersectOf<U extends Union> = (U extends unknown ? (k: U) => void : never) extends (
      k: infer I
   ) => void
      ? I
      : never;

   export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
   } & {};

   type _Merge<U extends object> = IntersectOf<
      Overwrite<
         U,
         {
            [K in keyof U]-?: At<U, K>;
         }
      >
   >;

   type Key = string | number | symbol;
   type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
   type AtStrict<O extends object, K extends Key> = O[K & keyof O];
   type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
   export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
   }[strict];

   export type ComputeRaw<A extends any> = A extends Function
      ? A
      : {
           [K in keyof A]: A[K];
        } & {};

   export type OptionalFlat<O> = {
      [K in keyof O]?: O[K];
   } & {};

   type _Record<K extends keyof any, T> = {
      [P in K]: T;
   };

   // cause typescript not to expand types and preserve names
   type NoExpand<T> = T extends unknown ? T : never;

   // this type assumes the passed object is entirely optional
   type AtLeast<O extends object, K extends string> = NoExpand<
      O extends unknown
         ?
              | (K extends keyof O ? { [P in K]: O[P] } & O : O)
              | ({ [P in keyof O as P extends K ? P : never]-?: O[P] } & O)
         : never
   >;

   type _Strict<U, _U = U> = U extends unknown
      ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>>
      : never;

   export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
   /** End Helper Types for "Merge" **/

   export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

   /**
  A [[Boolean]]
  */
   export type Boolean = True | False;

   // /**
   // 1
   // */
   export type True = 1;

   /**
  0
  */
   export type False = 0;

   export type Not<B extends Boolean> = {
      0: 1;
      1: 0;
   }[B];

   export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
      ? 0 // anything `never` is false
      : A1 extends A2
        ? 1
        : 0;

   export type Has<U extends Union, U1 extends Union> = Not<Extends<Exclude<U1, U>, U1>>;

   export type Or<B1 extends Boolean, B2 extends Boolean> = {
      0: {
         0: 0;
         1: 1;
      };
      1: {
         0: 1;
         1: 1;
      };
   }[B1][B2];

   export type Keys<U extends Union> = U extends unknown ? keyof U : never;

   type Cast<A, B> = A extends B ? A : B;

   export const type: unique symbol;

   /**
    * Used by group by
    */

   export type GetScalarType<T, O> = O extends object
      ? {
           [P in keyof T]: P extends keyof O ? O[P] : never;
        }
      : never;

   type FieldPaths<T, U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>> =
      IsObject<T> extends True ? U : T;

   type GetHavingFields<T> = {
      [K in keyof T]: Or<Or<Extends<'OR', K>, Extends<'AND', K>>, Extends<'NOT', K>> extends True
         ? // infer is only needed to not hit TS limit
           // based on the brilliant idea of Pierre-Antoine Mills
           // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
           T[K] extends infer TK
            ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
            : never
         : {} extends FieldPaths<T[K]>
           ? never
           : K;
   }[keyof T];

   /**
    * Convert tuple to union
    */
   type _TupleToUnion<T> = T extends (infer E)[] ? E : never;
   type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>;
   type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T;

   /**
    * Like `Pick`, but additionally can also accept an array of keys
    */
   type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<
      T,
      MaybeTupleToUnion<K>
   >;

   /**
    * Exclude all keys with underscores
    */
   type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T;

   export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>;

   type FieldRefInputType<Model, FieldType> = Model extends never
      ? never
      : FieldRef<Model, FieldType>;

   export const ModelName: {
      Task: 'Task';
      Subtask: 'Subtask';
      TaskDependency: 'TaskDependency';
      TaskMasterMetadata: 'TaskMasterMetadata';
      SyncOperation: 'SyncOperation';
      SyncConflict: 'SyncConflict';
      User: 'User';
      Project: 'Project';
      Label: 'Label';
      IssueStatus: 'IssueStatus';
      IssuePriority: 'IssuePriority';
      Issue: 'Issue';
      IssueLabel: 'IssueLabel';
      Cycle: 'Cycle';
      Team: 'Team';
      TeamMember: 'TeamMember';
      TeamProject: 'TeamProject';
   };

   export type ModelName = (typeof ModelName)[keyof typeof ModelName];

   export type Datasources = {
      db?: Datasource;
   };

   interface TypeMapCb<ClientOptions = {}>
      extends $Utils.Fn<{ extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
      returns: Prisma.TypeMap<
         this['params']['extArgs'],
         ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}
      >;
   }

   export type TypeMap<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > = {
      globalOmitOptions: {
         omit: GlobalOmitOptions;
      };
      meta: {
         modelProps:
            | 'task'
            | 'subtask'
            | 'taskDependency'
            | 'taskMasterMetadata'
            | 'syncOperation'
            | 'syncConflict'
            | 'user'
            | 'project'
            | 'label'
            | 'issueStatus'
            | 'issuePriority'
            | 'issue'
            | 'issueLabel'
            | 'cycle'
            | 'team'
            | 'teamMember'
            | 'teamProject';
         txIsolationLevel: Prisma.TransactionIsolationLevel;
      };
      model: {
         Task: {
            payload: Prisma.$TaskPayload<ExtArgs>;
            fields: Prisma.TaskFieldRefs;
            operations: {
               findUnique: {
                  args: Prisma.TaskFindUniqueArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null;
               };
               findUniqueOrThrow: {
                  args: Prisma.TaskFindUniqueOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskPayload>;
               };
               findFirst: {
                  args: Prisma.TaskFindFirstArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskPayload> | null;
               };
               findFirstOrThrow: {
                  args: Prisma.TaskFindFirstOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskPayload>;
               };
               findMany: {
                  args: Prisma.TaskFindManyArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskPayload>[];
               };
               create: {
                  args: Prisma.TaskCreateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskPayload>;
               };
               createMany: {
                  args: Prisma.TaskCreateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               createManyAndReturn: {
                  args: Prisma.TaskCreateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskPayload>[];
               };
               delete: {
                  args: Prisma.TaskDeleteArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskPayload>;
               };
               update: {
                  args: Prisma.TaskUpdateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskPayload>;
               };
               deleteMany: {
                  args: Prisma.TaskDeleteManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateMany: {
                  args: Prisma.TaskUpdateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateManyAndReturn: {
                  args: Prisma.TaskUpdateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskPayload>[];
               };
               upsert: {
                  args: Prisma.TaskUpsertArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskPayload>;
               };
               aggregate: {
                  args: Prisma.TaskAggregateArgs<ExtArgs>;
                  result: $Utils.Optional<AggregateTask>;
               };
               groupBy: {
                  args: Prisma.TaskGroupByArgs<ExtArgs>;
                  result: $Utils.Optional<TaskGroupByOutputType>[];
               };
               count: {
                  args: Prisma.TaskCountArgs<ExtArgs>;
                  result: $Utils.Optional<TaskCountAggregateOutputType> | number;
               };
            };
         };
         Subtask: {
            payload: Prisma.$SubtaskPayload<ExtArgs>;
            fields: Prisma.SubtaskFieldRefs;
            operations: {
               findUnique: {
                  args: Prisma.SubtaskFindUniqueArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SubtaskPayload> | null;
               };
               findUniqueOrThrow: {
                  args: Prisma.SubtaskFindUniqueOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>;
               };
               findFirst: {
                  args: Prisma.SubtaskFindFirstArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SubtaskPayload> | null;
               };
               findFirstOrThrow: {
                  args: Prisma.SubtaskFindFirstOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>;
               };
               findMany: {
                  args: Prisma.SubtaskFindManyArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>[];
               };
               create: {
                  args: Prisma.SubtaskCreateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>;
               };
               createMany: {
                  args: Prisma.SubtaskCreateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               createManyAndReturn: {
                  args: Prisma.SubtaskCreateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>[];
               };
               delete: {
                  args: Prisma.SubtaskDeleteArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>;
               };
               update: {
                  args: Prisma.SubtaskUpdateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>;
               };
               deleteMany: {
                  args: Prisma.SubtaskDeleteManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateMany: {
                  args: Prisma.SubtaskUpdateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateManyAndReturn: {
                  args: Prisma.SubtaskUpdateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>[];
               };
               upsert: {
                  args: Prisma.SubtaskUpsertArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SubtaskPayload>;
               };
               aggregate: {
                  args: Prisma.SubtaskAggregateArgs<ExtArgs>;
                  result: $Utils.Optional<AggregateSubtask>;
               };
               groupBy: {
                  args: Prisma.SubtaskGroupByArgs<ExtArgs>;
                  result: $Utils.Optional<SubtaskGroupByOutputType>[];
               };
               count: {
                  args: Prisma.SubtaskCountArgs<ExtArgs>;
                  result: $Utils.Optional<SubtaskCountAggregateOutputType> | number;
               };
            };
         };
         TaskDependency: {
            payload: Prisma.$TaskDependencyPayload<ExtArgs>;
            fields: Prisma.TaskDependencyFieldRefs;
            operations: {
               findUnique: {
                  args: Prisma.TaskDependencyFindUniqueArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload> | null;
               };
               findUniqueOrThrow: {
                  args: Prisma.TaskDependencyFindUniqueOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>;
               };
               findFirst: {
                  args: Prisma.TaskDependencyFindFirstArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload> | null;
               };
               findFirstOrThrow: {
                  args: Prisma.TaskDependencyFindFirstOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>;
               };
               findMany: {
                  args: Prisma.TaskDependencyFindManyArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>[];
               };
               create: {
                  args: Prisma.TaskDependencyCreateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>;
               };
               createMany: {
                  args: Prisma.TaskDependencyCreateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               createManyAndReturn: {
                  args: Prisma.TaskDependencyCreateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>[];
               };
               delete: {
                  args: Prisma.TaskDependencyDeleteArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>;
               };
               update: {
                  args: Prisma.TaskDependencyUpdateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>;
               };
               deleteMany: {
                  args: Prisma.TaskDependencyDeleteManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateMany: {
                  args: Prisma.TaskDependencyUpdateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateManyAndReturn: {
                  args: Prisma.TaskDependencyUpdateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>[];
               };
               upsert: {
                  args: Prisma.TaskDependencyUpsertArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskDependencyPayload>;
               };
               aggregate: {
                  args: Prisma.TaskDependencyAggregateArgs<ExtArgs>;
                  result: $Utils.Optional<AggregateTaskDependency>;
               };
               groupBy: {
                  args: Prisma.TaskDependencyGroupByArgs<ExtArgs>;
                  result: $Utils.Optional<TaskDependencyGroupByOutputType>[];
               };
               count: {
                  args: Prisma.TaskDependencyCountArgs<ExtArgs>;
                  result: $Utils.Optional<TaskDependencyCountAggregateOutputType> | number;
               };
            };
         };
         TaskMasterMetadata: {
            payload: Prisma.$TaskMasterMetadataPayload<ExtArgs>;
            fields: Prisma.TaskMasterMetadataFieldRefs;
            operations: {
               findUnique: {
                  args: Prisma.TaskMasterMetadataFindUniqueArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskMasterMetadataPayload> | null;
               };
               findUniqueOrThrow: {
                  args: Prisma.TaskMasterMetadataFindUniqueOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskMasterMetadataPayload>;
               };
               findFirst: {
                  args: Prisma.TaskMasterMetadataFindFirstArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskMasterMetadataPayload> | null;
               };
               findFirstOrThrow: {
                  args: Prisma.TaskMasterMetadataFindFirstOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskMasterMetadataPayload>;
               };
               findMany: {
                  args: Prisma.TaskMasterMetadataFindManyArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskMasterMetadataPayload>[];
               };
               create: {
                  args: Prisma.TaskMasterMetadataCreateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskMasterMetadataPayload>;
               };
               createMany: {
                  args: Prisma.TaskMasterMetadataCreateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               createManyAndReturn: {
                  args: Prisma.TaskMasterMetadataCreateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskMasterMetadataPayload>[];
               };
               delete: {
                  args: Prisma.TaskMasterMetadataDeleteArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskMasterMetadataPayload>;
               };
               update: {
                  args: Prisma.TaskMasterMetadataUpdateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskMasterMetadataPayload>;
               };
               deleteMany: {
                  args: Prisma.TaskMasterMetadataDeleteManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateMany: {
                  args: Prisma.TaskMasterMetadataUpdateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateManyAndReturn: {
                  args: Prisma.TaskMasterMetadataUpdateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskMasterMetadataPayload>[];
               };
               upsert: {
                  args: Prisma.TaskMasterMetadataUpsertArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TaskMasterMetadataPayload>;
               };
               aggregate: {
                  args: Prisma.TaskMasterMetadataAggregateArgs<ExtArgs>;
                  result: $Utils.Optional<AggregateTaskMasterMetadata>;
               };
               groupBy: {
                  args: Prisma.TaskMasterMetadataGroupByArgs<ExtArgs>;
                  result: $Utils.Optional<TaskMasterMetadataGroupByOutputType>[];
               };
               count: {
                  args: Prisma.TaskMasterMetadataCountArgs<ExtArgs>;
                  result: $Utils.Optional<TaskMasterMetadataCountAggregateOutputType> | number;
               };
            };
         };
         SyncOperation: {
            payload: Prisma.$SyncOperationPayload<ExtArgs>;
            fields: Prisma.SyncOperationFieldRefs;
            operations: {
               findUnique: {
                  args: Prisma.SyncOperationFindUniqueArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload> | null;
               };
               findUniqueOrThrow: {
                  args: Prisma.SyncOperationFindUniqueOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload>;
               };
               findFirst: {
                  args: Prisma.SyncOperationFindFirstArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload> | null;
               };
               findFirstOrThrow: {
                  args: Prisma.SyncOperationFindFirstOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload>;
               };
               findMany: {
                  args: Prisma.SyncOperationFindManyArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload>[];
               };
               create: {
                  args: Prisma.SyncOperationCreateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload>;
               };
               createMany: {
                  args: Prisma.SyncOperationCreateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               createManyAndReturn: {
                  args: Prisma.SyncOperationCreateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload>[];
               };
               delete: {
                  args: Prisma.SyncOperationDeleteArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload>;
               };
               update: {
                  args: Prisma.SyncOperationUpdateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload>;
               };
               deleteMany: {
                  args: Prisma.SyncOperationDeleteManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateMany: {
                  args: Prisma.SyncOperationUpdateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateManyAndReturn: {
                  args: Prisma.SyncOperationUpdateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload>[];
               };
               upsert: {
                  args: Prisma.SyncOperationUpsertArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncOperationPayload>;
               };
               aggregate: {
                  args: Prisma.SyncOperationAggregateArgs<ExtArgs>;
                  result: $Utils.Optional<AggregateSyncOperation>;
               };
               groupBy: {
                  args: Prisma.SyncOperationGroupByArgs<ExtArgs>;
                  result: $Utils.Optional<SyncOperationGroupByOutputType>[];
               };
               count: {
                  args: Prisma.SyncOperationCountArgs<ExtArgs>;
                  result: $Utils.Optional<SyncOperationCountAggregateOutputType> | number;
               };
            };
         };
         SyncConflict: {
            payload: Prisma.$SyncConflictPayload<ExtArgs>;
            fields: Prisma.SyncConflictFieldRefs;
            operations: {
               findUnique: {
                  args: Prisma.SyncConflictFindUniqueArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncConflictPayload> | null;
               };
               findUniqueOrThrow: {
                  args: Prisma.SyncConflictFindUniqueOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncConflictPayload>;
               };
               findFirst: {
                  args: Prisma.SyncConflictFindFirstArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncConflictPayload> | null;
               };
               findFirstOrThrow: {
                  args: Prisma.SyncConflictFindFirstOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncConflictPayload>;
               };
               findMany: {
                  args: Prisma.SyncConflictFindManyArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncConflictPayload>[];
               };
               create: {
                  args: Prisma.SyncConflictCreateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncConflictPayload>;
               };
               createMany: {
                  args: Prisma.SyncConflictCreateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               createManyAndReturn: {
                  args: Prisma.SyncConflictCreateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncConflictPayload>[];
               };
               delete: {
                  args: Prisma.SyncConflictDeleteArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncConflictPayload>;
               };
               update: {
                  args: Prisma.SyncConflictUpdateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncConflictPayload>;
               };
               deleteMany: {
                  args: Prisma.SyncConflictDeleteManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateMany: {
                  args: Prisma.SyncConflictUpdateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateManyAndReturn: {
                  args: Prisma.SyncConflictUpdateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncConflictPayload>[];
               };
               upsert: {
                  args: Prisma.SyncConflictUpsertArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$SyncConflictPayload>;
               };
               aggregate: {
                  args: Prisma.SyncConflictAggregateArgs<ExtArgs>;
                  result: $Utils.Optional<AggregateSyncConflict>;
               };
               groupBy: {
                  args: Prisma.SyncConflictGroupByArgs<ExtArgs>;
                  result: $Utils.Optional<SyncConflictGroupByOutputType>[];
               };
               count: {
                  args: Prisma.SyncConflictCountArgs<ExtArgs>;
                  result: $Utils.Optional<SyncConflictCountAggregateOutputType> | number;
               };
            };
         };
         User: {
            payload: Prisma.$UserPayload<ExtArgs>;
            fields: Prisma.UserFieldRefs;
            operations: {
               findUnique: {
                  args: Prisma.UserFindUniqueArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
               };
               findUniqueOrThrow: {
                  args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$UserPayload>;
               };
               findFirst: {
                  args: Prisma.UserFindFirstArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$UserPayload> | null;
               };
               findFirstOrThrow: {
                  args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$UserPayload>;
               };
               findMany: {
                  args: Prisma.UserFindManyArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
               };
               create: {
                  args: Prisma.UserCreateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$UserPayload>;
               };
               createMany: {
                  args: Prisma.UserCreateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               createManyAndReturn: {
                  args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
               };
               delete: {
                  args: Prisma.UserDeleteArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$UserPayload>;
               };
               update: {
                  args: Prisma.UserUpdateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$UserPayload>;
               };
               deleteMany: {
                  args: Prisma.UserDeleteManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateMany: {
                  args: Prisma.UserUpdateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateManyAndReturn: {
                  args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$UserPayload>[];
               };
               upsert: {
                  args: Prisma.UserUpsertArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$UserPayload>;
               };
               aggregate: {
                  args: Prisma.UserAggregateArgs<ExtArgs>;
                  result: $Utils.Optional<AggregateUser>;
               };
               groupBy: {
                  args: Prisma.UserGroupByArgs<ExtArgs>;
                  result: $Utils.Optional<UserGroupByOutputType>[];
               };
               count: {
                  args: Prisma.UserCountArgs<ExtArgs>;
                  result: $Utils.Optional<UserCountAggregateOutputType> | number;
               };
            };
         };
         Project: {
            payload: Prisma.$ProjectPayload<ExtArgs>;
            fields: Prisma.ProjectFieldRefs;
            operations: {
               findUnique: {
                  args: Prisma.ProjectFindUniqueArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null;
               };
               findUniqueOrThrow: {
                  args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$ProjectPayload>;
               };
               findFirst: {
                  args: Prisma.ProjectFindFirstArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null;
               };
               findFirstOrThrow: {
                  args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$ProjectPayload>;
               };
               findMany: {
                  args: Prisma.ProjectFindManyArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[];
               };
               create: {
                  args: Prisma.ProjectCreateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$ProjectPayload>;
               };
               createMany: {
                  args: Prisma.ProjectCreateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               createManyAndReturn: {
                  args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[];
               };
               delete: {
                  args: Prisma.ProjectDeleteArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$ProjectPayload>;
               };
               update: {
                  args: Prisma.ProjectUpdateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$ProjectPayload>;
               };
               deleteMany: {
                  args: Prisma.ProjectDeleteManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateMany: {
                  args: Prisma.ProjectUpdateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateManyAndReturn: {
                  args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[];
               };
               upsert: {
                  args: Prisma.ProjectUpsertArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$ProjectPayload>;
               };
               aggregate: {
                  args: Prisma.ProjectAggregateArgs<ExtArgs>;
                  result: $Utils.Optional<AggregateProject>;
               };
               groupBy: {
                  args: Prisma.ProjectGroupByArgs<ExtArgs>;
                  result: $Utils.Optional<ProjectGroupByOutputType>[];
               };
               count: {
                  args: Prisma.ProjectCountArgs<ExtArgs>;
                  result: $Utils.Optional<ProjectCountAggregateOutputType> | number;
               };
            };
         };
         Label: {
            payload: Prisma.$LabelPayload<ExtArgs>;
            fields: Prisma.LabelFieldRefs;
            operations: {
               findUnique: {
                  args: Prisma.LabelFindUniqueArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$LabelPayload> | null;
               };
               findUniqueOrThrow: {
                  args: Prisma.LabelFindUniqueOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$LabelPayload>;
               };
               findFirst: {
                  args: Prisma.LabelFindFirstArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$LabelPayload> | null;
               };
               findFirstOrThrow: {
                  args: Prisma.LabelFindFirstOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$LabelPayload>;
               };
               findMany: {
                  args: Prisma.LabelFindManyArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$LabelPayload>[];
               };
               create: {
                  args: Prisma.LabelCreateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$LabelPayload>;
               };
               createMany: {
                  args: Prisma.LabelCreateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               createManyAndReturn: {
                  args: Prisma.LabelCreateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$LabelPayload>[];
               };
               delete: {
                  args: Prisma.LabelDeleteArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$LabelPayload>;
               };
               update: {
                  args: Prisma.LabelUpdateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$LabelPayload>;
               };
               deleteMany: {
                  args: Prisma.LabelDeleteManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateMany: {
                  args: Prisma.LabelUpdateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateManyAndReturn: {
                  args: Prisma.LabelUpdateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$LabelPayload>[];
               };
               upsert: {
                  args: Prisma.LabelUpsertArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$LabelPayload>;
               };
               aggregate: {
                  args: Prisma.LabelAggregateArgs<ExtArgs>;
                  result: $Utils.Optional<AggregateLabel>;
               };
               groupBy: {
                  args: Prisma.LabelGroupByArgs<ExtArgs>;
                  result: $Utils.Optional<LabelGroupByOutputType>[];
               };
               count: {
                  args: Prisma.LabelCountArgs<ExtArgs>;
                  result: $Utils.Optional<LabelCountAggregateOutputType> | number;
               };
            };
         };
         IssueStatus: {
            payload: Prisma.$IssueStatusPayload<ExtArgs>;
            fields: Prisma.IssueStatusFieldRefs;
            operations: {
               findUnique: {
                  args: Prisma.IssueStatusFindUniqueArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueStatusPayload> | null;
               };
               findUniqueOrThrow: {
                  args: Prisma.IssueStatusFindUniqueOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueStatusPayload>;
               };
               findFirst: {
                  args: Prisma.IssueStatusFindFirstArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueStatusPayload> | null;
               };
               findFirstOrThrow: {
                  args: Prisma.IssueStatusFindFirstOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueStatusPayload>;
               };
               findMany: {
                  args: Prisma.IssueStatusFindManyArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueStatusPayload>[];
               };
               create: {
                  args: Prisma.IssueStatusCreateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueStatusPayload>;
               };
               createMany: {
                  args: Prisma.IssueStatusCreateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               createManyAndReturn: {
                  args: Prisma.IssueStatusCreateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueStatusPayload>[];
               };
               delete: {
                  args: Prisma.IssueStatusDeleteArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueStatusPayload>;
               };
               update: {
                  args: Prisma.IssueStatusUpdateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueStatusPayload>;
               };
               deleteMany: {
                  args: Prisma.IssueStatusDeleteManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateMany: {
                  args: Prisma.IssueStatusUpdateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateManyAndReturn: {
                  args: Prisma.IssueStatusUpdateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueStatusPayload>[];
               };
               upsert: {
                  args: Prisma.IssueStatusUpsertArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueStatusPayload>;
               };
               aggregate: {
                  args: Prisma.IssueStatusAggregateArgs<ExtArgs>;
                  result: $Utils.Optional<AggregateIssueStatus>;
               };
               groupBy: {
                  args: Prisma.IssueStatusGroupByArgs<ExtArgs>;
                  result: $Utils.Optional<IssueStatusGroupByOutputType>[];
               };
               count: {
                  args: Prisma.IssueStatusCountArgs<ExtArgs>;
                  result: $Utils.Optional<IssueStatusCountAggregateOutputType> | number;
               };
            };
         };
         IssuePriority: {
            payload: Prisma.$IssuePriorityPayload<ExtArgs>;
            fields: Prisma.IssuePriorityFieldRefs;
            operations: {
               findUnique: {
                  args: Prisma.IssuePriorityFindUniqueArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePriorityPayload> | null;
               };
               findUniqueOrThrow: {
                  args: Prisma.IssuePriorityFindUniqueOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePriorityPayload>;
               };
               findFirst: {
                  args: Prisma.IssuePriorityFindFirstArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePriorityPayload> | null;
               };
               findFirstOrThrow: {
                  args: Prisma.IssuePriorityFindFirstOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePriorityPayload>;
               };
               findMany: {
                  args: Prisma.IssuePriorityFindManyArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePriorityPayload>[];
               };
               create: {
                  args: Prisma.IssuePriorityCreateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePriorityPayload>;
               };
               createMany: {
                  args: Prisma.IssuePriorityCreateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               createManyAndReturn: {
                  args: Prisma.IssuePriorityCreateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePriorityPayload>[];
               };
               delete: {
                  args: Prisma.IssuePriorityDeleteArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePriorityPayload>;
               };
               update: {
                  args: Prisma.IssuePriorityUpdateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePriorityPayload>;
               };
               deleteMany: {
                  args: Prisma.IssuePriorityDeleteManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateMany: {
                  args: Prisma.IssuePriorityUpdateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateManyAndReturn: {
                  args: Prisma.IssuePriorityUpdateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePriorityPayload>[];
               };
               upsert: {
                  args: Prisma.IssuePriorityUpsertArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePriorityPayload>;
               };
               aggregate: {
                  args: Prisma.IssuePriorityAggregateArgs<ExtArgs>;
                  result: $Utils.Optional<AggregateIssuePriority>;
               };
               groupBy: {
                  args: Prisma.IssuePriorityGroupByArgs<ExtArgs>;
                  result: $Utils.Optional<IssuePriorityGroupByOutputType>[];
               };
               count: {
                  args: Prisma.IssuePriorityCountArgs<ExtArgs>;
                  result: $Utils.Optional<IssuePriorityCountAggregateOutputType> | number;
               };
            };
         };
         Issue: {
            payload: Prisma.$IssuePayload<ExtArgs>;
            fields: Prisma.IssueFieldRefs;
            operations: {
               findUnique: {
                  args: Prisma.IssueFindUniqueArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePayload> | null;
               };
               findUniqueOrThrow: {
                  args: Prisma.IssueFindUniqueOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePayload>;
               };
               findFirst: {
                  args: Prisma.IssueFindFirstArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePayload> | null;
               };
               findFirstOrThrow: {
                  args: Prisma.IssueFindFirstOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePayload>;
               };
               findMany: {
                  args: Prisma.IssueFindManyArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePayload>[];
               };
               create: {
                  args: Prisma.IssueCreateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePayload>;
               };
               createMany: {
                  args: Prisma.IssueCreateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               createManyAndReturn: {
                  args: Prisma.IssueCreateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePayload>[];
               };
               delete: {
                  args: Prisma.IssueDeleteArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePayload>;
               };
               update: {
                  args: Prisma.IssueUpdateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePayload>;
               };
               deleteMany: {
                  args: Prisma.IssueDeleteManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateMany: {
                  args: Prisma.IssueUpdateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateManyAndReturn: {
                  args: Prisma.IssueUpdateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePayload>[];
               };
               upsert: {
                  args: Prisma.IssueUpsertArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssuePayload>;
               };
               aggregate: {
                  args: Prisma.IssueAggregateArgs<ExtArgs>;
                  result: $Utils.Optional<AggregateIssue>;
               };
               groupBy: {
                  args: Prisma.IssueGroupByArgs<ExtArgs>;
                  result: $Utils.Optional<IssueGroupByOutputType>[];
               };
               count: {
                  args: Prisma.IssueCountArgs<ExtArgs>;
                  result: $Utils.Optional<IssueCountAggregateOutputType> | number;
               };
            };
         };
         IssueLabel: {
            payload: Prisma.$IssueLabelPayload<ExtArgs>;
            fields: Prisma.IssueLabelFieldRefs;
            operations: {
               findUnique: {
                  args: Prisma.IssueLabelFindUniqueArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueLabelPayload> | null;
               };
               findUniqueOrThrow: {
                  args: Prisma.IssueLabelFindUniqueOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueLabelPayload>;
               };
               findFirst: {
                  args: Prisma.IssueLabelFindFirstArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueLabelPayload> | null;
               };
               findFirstOrThrow: {
                  args: Prisma.IssueLabelFindFirstOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueLabelPayload>;
               };
               findMany: {
                  args: Prisma.IssueLabelFindManyArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueLabelPayload>[];
               };
               create: {
                  args: Prisma.IssueLabelCreateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueLabelPayload>;
               };
               createMany: {
                  args: Prisma.IssueLabelCreateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               createManyAndReturn: {
                  args: Prisma.IssueLabelCreateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueLabelPayload>[];
               };
               delete: {
                  args: Prisma.IssueLabelDeleteArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueLabelPayload>;
               };
               update: {
                  args: Prisma.IssueLabelUpdateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueLabelPayload>;
               };
               deleteMany: {
                  args: Prisma.IssueLabelDeleteManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateMany: {
                  args: Prisma.IssueLabelUpdateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateManyAndReturn: {
                  args: Prisma.IssueLabelUpdateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueLabelPayload>[];
               };
               upsert: {
                  args: Prisma.IssueLabelUpsertArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$IssueLabelPayload>;
               };
               aggregate: {
                  args: Prisma.IssueLabelAggregateArgs<ExtArgs>;
                  result: $Utils.Optional<AggregateIssueLabel>;
               };
               groupBy: {
                  args: Prisma.IssueLabelGroupByArgs<ExtArgs>;
                  result: $Utils.Optional<IssueLabelGroupByOutputType>[];
               };
               count: {
                  args: Prisma.IssueLabelCountArgs<ExtArgs>;
                  result: $Utils.Optional<IssueLabelCountAggregateOutputType> | number;
               };
            };
         };
         Cycle: {
            payload: Prisma.$CyclePayload<ExtArgs>;
            fields: Prisma.CycleFieldRefs;
            operations: {
               findUnique: {
                  args: Prisma.CycleFindUniqueArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$CyclePayload> | null;
               };
               findUniqueOrThrow: {
                  args: Prisma.CycleFindUniqueOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$CyclePayload>;
               };
               findFirst: {
                  args: Prisma.CycleFindFirstArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$CyclePayload> | null;
               };
               findFirstOrThrow: {
                  args: Prisma.CycleFindFirstOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$CyclePayload>;
               };
               findMany: {
                  args: Prisma.CycleFindManyArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$CyclePayload>[];
               };
               create: {
                  args: Prisma.CycleCreateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$CyclePayload>;
               };
               createMany: {
                  args: Prisma.CycleCreateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               createManyAndReturn: {
                  args: Prisma.CycleCreateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$CyclePayload>[];
               };
               delete: {
                  args: Prisma.CycleDeleteArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$CyclePayload>;
               };
               update: {
                  args: Prisma.CycleUpdateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$CyclePayload>;
               };
               deleteMany: {
                  args: Prisma.CycleDeleteManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateMany: {
                  args: Prisma.CycleUpdateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateManyAndReturn: {
                  args: Prisma.CycleUpdateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$CyclePayload>[];
               };
               upsert: {
                  args: Prisma.CycleUpsertArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$CyclePayload>;
               };
               aggregate: {
                  args: Prisma.CycleAggregateArgs<ExtArgs>;
                  result: $Utils.Optional<AggregateCycle>;
               };
               groupBy: {
                  args: Prisma.CycleGroupByArgs<ExtArgs>;
                  result: $Utils.Optional<CycleGroupByOutputType>[];
               };
               count: {
                  args: Prisma.CycleCountArgs<ExtArgs>;
                  result: $Utils.Optional<CycleCountAggregateOutputType> | number;
               };
            };
         };
         Team: {
            payload: Prisma.$TeamPayload<ExtArgs>;
            fields: Prisma.TeamFieldRefs;
            operations: {
               findUnique: {
                  args: Prisma.TeamFindUniqueArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null;
               };
               findUniqueOrThrow: {
                  args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
               };
               findFirst: {
                  args: Prisma.TeamFindFirstArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null;
               };
               findFirstOrThrow: {
                  args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
               };
               findMany: {
                  args: Prisma.TeamFindManyArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamPayload>[];
               };
               create: {
                  args: Prisma.TeamCreateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
               };
               createMany: {
                  args: Prisma.TeamCreateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               createManyAndReturn: {
                  args: Prisma.TeamCreateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamPayload>[];
               };
               delete: {
                  args: Prisma.TeamDeleteArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
               };
               update: {
                  args: Prisma.TeamUpdateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
               };
               deleteMany: {
                  args: Prisma.TeamDeleteManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateMany: {
                  args: Prisma.TeamUpdateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateManyAndReturn: {
                  args: Prisma.TeamUpdateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamPayload>[];
               };
               upsert: {
                  args: Prisma.TeamUpsertArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamPayload>;
               };
               aggregate: {
                  args: Prisma.TeamAggregateArgs<ExtArgs>;
                  result: $Utils.Optional<AggregateTeam>;
               };
               groupBy: {
                  args: Prisma.TeamGroupByArgs<ExtArgs>;
                  result: $Utils.Optional<TeamGroupByOutputType>[];
               };
               count: {
                  args: Prisma.TeamCountArgs<ExtArgs>;
                  result: $Utils.Optional<TeamCountAggregateOutputType> | number;
               };
            };
         };
         TeamMember: {
            payload: Prisma.$TeamMemberPayload<ExtArgs>;
            fields: Prisma.TeamMemberFieldRefs;
            operations: {
               findUnique: {
                  args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null;
               };
               findUniqueOrThrow: {
                  args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
               };
               findFirst: {
                  args: Prisma.TeamMemberFindFirstArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null;
               };
               findFirstOrThrow: {
                  args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
               };
               findMany: {
                  args: Prisma.TeamMemberFindManyArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[];
               };
               create: {
                  args: Prisma.TeamMemberCreateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
               };
               createMany: {
                  args: Prisma.TeamMemberCreateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               createManyAndReturn: {
                  args: Prisma.TeamMemberCreateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[];
               };
               delete: {
                  args: Prisma.TeamMemberDeleteArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
               };
               update: {
                  args: Prisma.TeamMemberUpdateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
               };
               deleteMany: {
                  args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateMany: {
                  args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateManyAndReturn: {
                  args: Prisma.TeamMemberUpdateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[];
               };
               upsert: {
                  args: Prisma.TeamMemberUpsertArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>;
               };
               aggregate: {
                  args: Prisma.TeamMemberAggregateArgs<ExtArgs>;
                  result: $Utils.Optional<AggregateTeamMember>;
               };
               groupBy: {
                  args: Prisma.TeamMemberGroupByArgs<ExtArgs>;
                  result: $Utils.Optional<TeamMemberGroupByOutputType>[];
               };
               count: {
                  args: Prisma.TeamMemberCountArgs<ExtArgs>;
                  result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number;
               };
            };
         };
         TeamProject: {
            payload: Prisma.$TeamProjectPayload<ExtArgs>;
            fields: Prisma.TeamProjectFieldRefs;
            operations: {
               findUnique: {
                  args: Prisma.TeamProjectFindUniqueArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamProjectPayload> | null;
               };
               findUniqueOrThrow: {
                  args: Prisma.TeamProjectFindUniqueOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamProjectPayload>;
               };
               findFirst: {
                  args: Prisma.TeamProjectFindFirstArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamProjectPayload> | null;
               };
               findFirstOrThrow: {
                  args: Prisma.TeamProjectFindFirstOrThrowArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamProjectPayload>;
               };
               findMany: {
                  args: Prisma.TeamProjectFindManyArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamProjectPayload>[];
               };
               create: {
                  args: Prisma.TeamProjectCreateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamProjectPayload>;
               };
               createMany: {
                  args: Prisma.TeamProjectCreateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               createManyAndReturn: {
                  args: Prisma.TeamProjectCreateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamProjectPayload>[];
               };
               delete: {
                  args: Prisma.TeamProjectDeleteArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamProjectPayload>;
               };
               update: {
                  args: Prisma.TeamProjectUpdateArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamProjectPayload>;
               };
               deleteMany: {
                  args: Prisma.TeamProjectDeleteManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateMany: {
                  args: Prisma.TeamProjectUpdateManyArgs<ExtArgs>;
                  result: BatchPayload;
               };
               updateManyAndReturn: {
                  args: Prisma.TeamProjectUpdateManyAndReturnArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamProjectPayload>[];
               };
               upsert: {
                  args: Prisma.TeamProjectUpsertArgs<ExtArgs>;
                  result: $Utils.PayloadToResult<Prisma.$TeamProjectPayload>;
               };
               aggregate: {
                  args: Prisma.TeamProjectAggregateArgs<ExtArgs>;
                  result: $Utils.Optional<AggregateTeamProject>;
               };
               groupBy: {
                  args: Prisma.TeamProjectGroupByArgs<ExtArgs>;
                  result: $Utils.Optional<TeamProjectGroupByOutputType>[];
               };
               count: {
                  args: Prisma.TeamProjectCountArgs<ExtArgs>;
                  result: $Utils.Optional<TeamProjectCountAggregateOutputType> | number;
               };
            };
         };
      };
   } & {
      other: {
         payload: any;
         operations: {
            $executeRaw: {
               args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
               result: any;
            };
            $executeRawUnsafe: {
               args: [query: string, ...values: any[]];
               result: any;
            };
            $queryRaw: {
               args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]];
               result: any;
            };
            $queryRawUnsafe: {
               args: [query: string, ...values: any[]];
               result: any;
            };
         };
      };
   };
   export const defineExtension: $Extensions.ExtendsHook<
      'define',
      Prisma.TypeMapCb,
      $Extensions.DefaultArgs
   >;
   export type DefaultPrismaClient = PrismaClient;
   export type ErrorFormat = 'pretty' | 'colorless' | 'minimal';
   export interface PrismaClientOptions {
      /**
       * Overwrites the datasource url from your schema.prisma file
       */
      datasources?: Datasources;
      /**
       * Overwrites the datasource url from your schema.prisma file
       */
      datasourceUrl?: string;
      /**
       * @default "colorless"
       */
      errorFormat?: ErrorFormat;
      /**
       * @example
       * ```
       * // Defaults to stdout
       * log: ['query', 'info', 'warn', 'error']
       *
       * // Emit as events
       * log: [
       *   { emit: 'stdout', level: 'query' },
       *   { emit: 'stdout', level: 'info' },
       *   { emit: 'stdout', level: 'warn' }
       *   { emit: 'stdout', level: 'error' }
       * ]
       * ```
       * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
       */
      log?: (LogLevel | LogDefinition)[];
      /**
       * The default values for transactionOptions
       * maxWait ?= 2000
       * timeout ?= 5000
       */
      transactionOptions?: {
         maxWait?: number;
         timeout?: number;
         isolationLevel?: Prisma.TransactionIsolationLevel;
      };
      /**
       * Global configuration for omitting model fields by default.
       *
       * @example
       * ```
       * const prisma = new PrismaClient({
       *   omit: {
       *     user: {
       *       password: true
       *     }
       *   }
       * })
       * ```
       */
      omit?: Prisma.GlobalOmitConfig;
   }
   export type GlobalOmitConfig = {
      task?: TaskOmit;
      subtask?: SubtaskOmit;
      taskDependency?: TaskDependencyOmit;
      taskMasterMetadata?: TaskMasterMetadataOmit;
      syncOperation?: SyncOperationOmit;
      syncConflict?: SyncConflictOmit;
      user?: UserOmit;
      project?: ProjectOmit;
      label?: LabelOmit;
      issueStatus?: IssueStatusOmit;
      issuePriority?: IssuePriorityOmit;
      issue?: IssueOmit;
      issueLabel?: IssueLabelOmit;
      cycle?: CycleOmit;
      team?: TeamOmit;
      teamMember?: TeamMemberOmit;
      teamProject?: TeamProjectOmit;
   };

   /* Types for Logging */
   export type LogLevel = 'info' | 'query' | 'warn' | 'error';
   export type LogDefinition = {
      level: LogLevel;
      emit: 'stdout' | 'event';
   };

   export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition
      ? T['emit'] extends 'event'
         ? T['level']
         : never
      : never;
   export type GetEvents<T extends any> =
      T extends Array<LogLevel | LogDefinition>
         ? GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
         : never;

   export type QueryEvent = {
      timestamp: Date;
      query: string;
      params: string;
      duration: number;
      target: string;
   };

   export type LogEvent = {
      timestamp: Date;
      message: string;
      target: string;
   };
   /* End Types for Logging */

   export type PrismaAction =
      | 'findUnique'
      | 'findUniqueOrThrow'
      | 'findMany'
      | 'findFirst'
      | 'findFirstOrThrow'
      | 'create'
      | 'createMany'
      | 'createManyAndReturn'
      | 'update'
      | 'updateMany'
      | 'updateManyAndReturn'
      | 'upsert'
      | 'delete'
      | 'deleteMany'
      | 'executeRaw'
      | 'queryRaw'
      | 'aggregate'
      | 'count'
      | 'runCommandRaw'
      | 'findRaw'
      | 'groupBy';

   /**
    * These options are being passed into the middleware as "params"
    */
   export type MiddlewareParams = {
      model?: ModelName;
      action: PrismaAction;
      args: any;
      dataPath: string[];
      runInTransaction: boolean;
   };

   /**
    * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
    */
   export type Middleware<T = any> = (
      params: MiddlewareParams,
      next: (params: MiddlewareParams) => $Utils.JsPromise<T>
   ) => $Utils.JsPromise<T>;

   // tested in getLogLevel.test.ts
   export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

   /**
    * `PrismaClient` proxy available in interactive transactions.
    */
   export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>;

   export type Datasource = {
      url?: string;
   };

   /**
    * Count Types
    */

   /**
    * Count Type TaskCountOutputType
    */

   export type TaskCountOutputType = {
      subtasks: number;
      dependencies: number;
      dependents: number;
      issues: number;
   };

   export type TaskCountOutputTypeSelect<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      subtasks?: boolean | TaskCountOutputTypeCountSubtasksArgs;
      dependencies?: boolean | TaskCountOutputTypeCountDependenciesArgs;
      dependents?: boolean | TaskCountOutputTypeCountDependentsArgs;
      issues?: boolean | TaskCountOutputTypeCountIssuesArgs;
   };

   // Custom InputTypes
   /**
    * TaskCountOutputType without action
    */
   export type TaskCountOutputTypeDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskCountOutputType
       */
      select?: TaskCountOutputTypeSelect<ExtArgs> | null;
   };

   /**
    * TaskCountOutputType without action
    */
   export type TaskCountOutputTypeCountSubtasksArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: SubtaskWhereInput;
   };

   /**
    * TaskCountOutputType without action
    */
   export type TaskCountOutputTypeCountDependenciesArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: TaskDependencyWhereInput;
   };

   /**
    * TaskCountOutputType without action
    */
   export type TaskCountOutputTypeCountDependentsArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: TaskDependencyWhereInput;
   };

   /**
    * TaskCountOutputType without action
    */
   export type TaskCountOutputTypeCountIssuesArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: IssueWhereInput;
   };

   /**
    * Count Type UserCountOutputType
    */

   export type UserCountOutputType = {
      assignedIssues: number;
      teams: number;
      ledProjects: number;
   };

   export type UserCountOutputTypeSelect<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      assignedIssues?: boolean | UserCountOutputTypeCountAssignedIssuesArgs;
      teams?: boolean | UserCountOutputTypeCountTeamsArgs;
      ledProjects?: boolean | UserCountOutputTypeCountLedProjectsArgs;
   };

   // Custom InputTypes
   /**
    * UserCountOutputType without action
    */
   export type UserCountOutputTypeDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the UserCountOutputType
       */
      select?: UserCountOutputTypeSelect<ExtArgs> | null;
   };

   /**
    * UserCountOutputType without action
    */
   export type UserCountOutputTypeCountAssignedIssuesArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: IssueWhereInput;
   };

   /**
    * UserCountOutputType without action
    */
   export type UserCountOutputTypeCountTeamsArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: TeamMemberWhereInput;
   };

   /**
    * UserCountOutputType without action
    */
   export type UserCountOutputTypeCountLedProjectsArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: ProjectWhereInput;
   };

   /**
    * Count Type ProjectCountOutputType
    */

   export type ProjectCountOutputType = {
      issues: number;
      teams: number;
   };

   export type ProjectCountOutputTypeSelect<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      issues?: boolean | ProjectCountOutputTypeCountIssuesArgs;
      teams?: boolean | ProjectCountOutputTypeCountTeamsArgs;
   };

   // Custom InputTypes
   /**
    * ProjectCountOutputType without action
    */
   export type ProjectCountOutputTypeDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the ProjectCountOutputType
       */
      select?: ProjectCountOutputTypeSelect<ExtArgs> | null;
   };

   /**
    * ProjectCountOutputType without action
    */
   export type ProjectCountOutputTypeCountIssuesArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: IssueWhereInput;
   };

   /**
    * ProjectCountOutputType without action
    */
   export type ProjectCountOutputTypeCountTeamsArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: TeamProjectWhereInput;
   };

   /**
    * Count Type LabelCountOutputType
    */

   export type LabelCountOutputType = {
      issues: number;
   };

   export type LabelCountOutputTypeSelect<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      issues?: boolean | LabelCountOutputTypeCountIssuesArgs;
   };

   // Custom InputTypes
   /**
    * LabelCountOutputType without action
    */
   export type LabelCountOutputTypeDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the LabelCountOutputType
       */
      select?: LabelCountOutputTypeSelect<ExtArgs> | null;
   };

   /**
    * LabelCountOutputType without action
    */
   export type LabelCountOutputTypeCountIssuesArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: IssueLabelWhereInput;
   };

   /**
    * Count Type IssueStatusCountOutputType
    */

   export type IssueStatusCountOutputType = {
      issues: number;
   };

   export type IssueStatusCountOutputTypeSelect<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      issues?: boolean | IssueStatusCountOutputTypeCountIssuesArgs;
   };

   // Custom InputTypes
   /**
    * IssueStatusCountOutputType without action
    */
   export type IssueStatusCountOutputTypeDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueStatusCountOutputType
       */
      select?: IssueStatusCountOutputTypeSelect<ExtArgs> | null;
   };

   /**
    * IssueStatusCountOutputType without action
    */
   export type IssueStatusCountOutputTypeCountIssuesArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: IssueWhereInput;
   };

   /**
    * Count Type IssuePriorityCountOutputType
    */

   export type IssuePriorityCountOutputType = {
      issues: number;
   };

   export type IssuePriorityCountOutputTypeSelect<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      issues?: boolean | IssuePriorityCountOutputTypeCountIssuesArgs;
   };

   // Custom InputTypes
   /**
    * IssuePriorityCountOutputType without action
    */
   export type IssuePriorityCountOutputTypeDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssuePriorityCountOutputType
       */
      select?: IssuePriorityCountOutputTypeSelect<ExtArgs> | null;
   };

   /**
    * IssuePriorityCountOutputType without action
    */
   export type IssuePriorityCountOutputTypeCountIssuesArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: IssueWhereInput;
   };

   /**
    * Count Type IssueCountOutputType
    */

   export type IssueCountOutputType = {
      labels: number;
   };

   export type IssueCountOutputTypeSelect<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      labels?: boolean | IssueCountOutputTypeCountLabelsArgs;
   };

   // Custom InputTypes
   /**
    * IssueCountOutputType without action
    */
   export type IssueCountOutputTypeDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueCountOutputType
       */
      select?: IssueCountOutputTypeSelect<ExtArgs> | null;
   };

   /**
    * IssueCountOutputType without action
    */
   export type IssueCountOutputTypeCountLabelsArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: IssueLabelWhereInput;
   };

   /**
    * Count Type CycleCountOutputType
    */

   export type CycleCountOutputType = {
      issues: number;
   };

   export type CycleCountOutputTypeSelect<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      issues?: boolean | CycleCountOutputTypeCountIssuesArgs;
   };

   // Custom InputTypes
   /**
    * CycleCountOutputType without action
    */
   export type CycleCountOutputTypeDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the CycleCountOutputType
       */
      select?: CycleCountOutputTypeSelect<ExtArgs> | null;
   };

   /**
    * CycleCountOutputType without action
    */
   export type CycleCountOutputTypeCountIssuesArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: IssueWhereInput;
   };

   /**
    * Count Type TeamCountOutputType
    */

   export type TeamCountOutputType = {
      members: number;
      projects: number;
      cycles: number;
   };

   export type TeamCountOutputTypeSelect<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      members?: boolean | TeamCountOutputTypeCountMembersArgs;
      projects?: boolean | TeamCountOutputTypeCountProjectsArgs;
      cycles?: boolean | TeamCountOutputTypeCountCyclesArgs;
   };

   // Custom InputTypes
   /**
    * TeamCountOutputType without action
    */
   export type TeamCountOutputTypeDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamCountOutputType
       */
      select?: TeamCountOutputTypeSelect<ExtArgs> | null;
   };

   /**
    * TeamCountOutputType without action
    */
   export type TeamCountOutputTypeCountMembersArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: TeamMemberWhereInput;
   };

   /**
    * TeamCountOutputType without action
    */
   export type TeamCountOutputTypeCountProjectsArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: TeamProjectWhereInput;
   };

   /**
    * TeamCountOutputType without action
    */
   export type TeamCountOutputTypeCountCyclesArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: CycleWhereInput;
   };

   /**
    * Models
    */

   /**
    * Model Task
    */

   export type AggregateTask = {
      _count: TaskCountAggregateOutputType | null;
      _avg: TaskAvgAggregateOutputType | null;
      _sum: TaskSumAggregateOutputType | null;
      _min: TaskMinAggregateOutputType | null;
      _max: TaskMaxAggregateOutputType | null;
   };

   export type TaskAvgAggregateOutputType = {
      id: number | null;
      complexity: number | null;
   };

   export type TaskSumAggregateOutputType = {
      id: number | null;
      complexity: number | null;
   };

   export type TaskMinAggregateOutputType = {
      id: number | null;
      title: string | null;
      description: string | null;
      details: string | null;
      testStrategy: string | null;
      priority: string | null;
      status: string | null;
      complexity: number | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type TaskMaxAggregateOutputType = {
      id: number | null;
      title: string | null;
      description: string | null;
      details: string | null;
      testStrategy: string | null;
      priority: string | null;
      status: string | null;
      complexity: number | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type TaskCountAggregateOutputType = {
      id: number;
      title: number;
      description: number;
      details: number;
      testStrategy: number;
      priority: number;
      status: number;
      complexity: number;
      createdAt: number;
      updatedAt: number;
      _all: number;
   };

   export type TaskAvgAggregateInputType = {
      id?: true;
      complexity?: true;
   };

   export type TaskSumAggregateInputType = {
      id?: true;
      complexity?: true;
   };

   export type TaskMinAggregateInputType = {
      id?: true;
      title?: true;
      description?: true;
      details?: true;
      testStrategy?: true;
      priority?: true;
      status?: true;
      complexity?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type TaskMaxAggregateInputType = {
      id?: true;
      title?: true;
      description?: true;
      details?: true;
      testStrategy?: true;
      priority?: true;
      status?: true;
      complexity?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type TaskCountAggregateInputType = {
      id?: true;
      title?: true;
      description?: true;
      details?: true;
      testStrategy?: true;
      priority?: true;
      status?: true;
      complexity?: true;
      createdAt?: true;
      updatedAt?: true;
      _all?: true;
   };

   export type TaskAggregateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which Task to aggregate.
       */
      where?: TaskWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Tasks to fetch.
       */
      orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: TaskWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Tasks from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Tasks.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned Tasks
       **/
      _count?: true | TaskCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to average
       **/
      _avg?: TaskAvgAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to sum
       **/
      _sum?: TaskSumAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: TaskMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: TaskMaxAggregateInputType;
   };

   export type GetTaskAggregateType<T extends TaskAggregateArgs> = {
      [P in keyof T & keyof AggregateTask]: P extends '_count' | 'count'
         ? T[P] extends true
            ? number
            : GetScalarType<T[P], AggregateTask[P]>
         : GetScalarType<T[P], AggregateTask[P]>;
   };

   export type TaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         where?: TaskWhereInput;
         orderBy?: TaskOrderByWithAggregationInput | TaskOrderByWithAggregationInput[];
         by: TaskScalarFieldEnum[] | TaskScalarFieldEnum;
         having?: TaskScalarWhereWithAggregatesInput;
         take?: number;
         skip?: number;
         _count?: TaskCountAggregateInputType | true;
         _avg?: TaskAvgAggregateInputType;
         _sum?: TaskSumAggregateInputType;
         _min?: TaskMinAggregateInputType;
         _max?: TaskMaxAggregateInputType;
      };

   export type TaskGroupByOutputType = {
      id: number;
      title: string;
      description: string;
      details: string | null;
      testStrategy: string | null;
      priority: string;
      status: string;
      complexity: number | null;
      createdAt: Date;
      updatedAt: Date;
      _count: TaskCountAggregateOutputType | null;
      _avg: TaskAvgAggregateOutputType | null;
      _sum: TaskSumAggregateOutputType | null;
      _min: TaskMinAggregateOutputType | null;
      _max: TaskMaxAggregateOutputType | null;
   };

   type GetTaskGroupByPayload<T extends TaskGroupByArgs> = Prisma.PrismaPromise<
      Array<
         PickEnumerable<TaskGroupByOutputType, T['by']> & {
            [P in keyof T & keyof TaskGroupByOutputType]: P extends '_count'
               ? T[P] extends boolean
                  ? number
                  : GetScalarType<T[P], TaskGroupByOutputType[P]>
               : GetScalarType<T[P], TaskGroupByOutputType[P]>;
         }
      >
   >;

   export type TaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetSelect<
         {
            id?: boolean;
            title?: boolean;
            description?: boolean;
            details?: boolean;
            testStrategy?: boolean;
            priority?: boolean;
            status?: boolean;
            complexity?: boolean;
            createdAt?: boolean;
            updatedAt?: boolean;
            subtasks?: boolean | Task$subtasksArgs<ExtArgs>;
            dependencies?: boolean | Task$dependenciesArgs<ExtArgs>;
            dependents?: boolean | Task$dependentsArgs<ExtArgs>;
            issues?: boolean | Task$issuesArgs<ExtArgs>;
            _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>;
         },
         ExtArgs['result']['task']
      >;

   export type TaskSelectCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         title?: boolean;
         description?: boolean;
         details?: boolean;
         testStrategy?: boolean;
         priority?: boolean;
         status?: boolean;
         complexity?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
      },
      ExtArgs['result']['task']
   >;

   export type TaskSelectUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         title?: boolean;
         description?: boolean;
         details?: boolean;
         testStrategy?: boolean;
         priority?: boolean;
         status?: boolean;
         complexity?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
      },
      ExtArgs['result']['task']
   >;

   export type TaskSelectScalar = {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      details?: boolean;
      testStrategy?: boolean;
      priority?: boolean;
      status?: boolean;
      complexity?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
   };

   export type TaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetOmit<
         | 'id'
         | 'title'
         | 'description'
         | 'details'
         | 'testStrategy'
         | 'priority'
         | 'status'
         | 'complexity'
         | 'createdAt'
         | 'updatedAt',
         ExtArgs['result']['task']
      >;
   export type TaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
      subtasks?: boolean | Task$subtasksArgs<ExtArgs>;
      dependencies?: boolean | Task$dependenciesArgs<ExtArgs>;
      dependents?: boolean | Task$dependentsArgs<ExtArgs>;
      issues?: boolean | Task$issuesArgs<ExtArgs>;
      _count?: boolean | TaskCountOutputTypeDefaultArgs<ExtArgs>;
   };
   export type TaskIncludeCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {};
   export type TaskIncludeUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {};

   export type $TaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
      name: 'Task';
      objects: {
         subtasks: Prisma.$SubtaskPayload<ExtArgs>[];
         dependencies: Prisma.$TaskDependencyPayload<ExtArgs>[];
         dependents: Prisma.$TaskDependencyPayload<ExtArgs>[];
         issues: Prisma.$IssuePayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
         {
            id: number;
            title: string;
            description: string;
            details: string | null;
            testStrategy: string | null;
            priority: string;
            status: string;
            complexity: number | null;
            createdAt: Date;
            updatedAt: Date;
         },
         ExtArgs['result']['task']
      >;
      composites: {};
   };

   type TaskGetPayload<S extends boolean | null | undefined | TaskDefaultArgs> = $Result.GetResult<
      Prisma.$TaskPayload,
      S
   >;

   type TaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
      TaskFindManyArgs,
      'select' | 'include' | 'distinct' | 'omit'
   > & {
      select?: TaskCountAggregateInputType | true;
   };

   export interface TaskDelegate<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > {
      [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Task']; meta: { name: 'Task' } };
      /**
       * Find zero or one Task that matches the filter.
       * @param {TaskFindUniqueArgs} args - Arguments to find a Task
       * @example
       * // Get one Task
       * const task = await prisma.task.findUnique({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUnique<T extends TaskFindUniqueArgs>(
         args: SelectSubset<T, TaskFindUniqueArgs<ExtArgs>>
      ): Prisma__TaskClient<
         $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find one Task that matches the filter or throw an error with `error.code='P2025'`
       * if no matches were found.
       * @param {TaskFindUniqueOrThrowArgs} args - Arguments to find a Task
       * @example
       * // Get one Task
       * const task = await prisma.task.findUniqueOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUniqueOrThrow<T extends TaskFindUniqueOrThrowArgs>(
         args: SelectSubset<T, TaskFindUniqueOrThrowArgs<ExtArgs>>
      ): Prisma__TaskClient<
         $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first Task that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskFindFirstArgs} args - Arguments to find a Task
       * @example
       * // Get one Task
       * const task = await prisma.task.findFirst({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirst<T extends TaskFindFirstArgs>(
         args?: SelectSubset<T, TaskFindFirstArgs<ExtArgs>>
      ): Prisma__TaskClient<
         $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first Task that matches the filter or
       * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskFindFirstOrThrowArgs} args - Arguments to find a Task
       * @example
       * // Get one Task
       * const task = await prisma.task.findFirstOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirstOrThrow<T extends TaskFindFirstOrThrowArgs>(
         args?: SelectSubset<T, TaskFindFirstOrThrowArgs<ExtArgs>>
      ): Prisma__TaskClient<
         $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find zero or more Tasks that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskFindManyArgs} args - Arguments to filter and select certain fields only.
       * @example
       * // Get all Tasks
       * const tasks = await prisma.task.findMany()
       *
       * // Get first 10 Tasks
       * const tasks = await prisma.task.findMany({ take: 10 })
       *
       * // Only select the `id`
       * const taskWithIdOnly = await prisma.task.findMany({ select: { id: true } })
       *
       */
      findMany<T extends TaskFindManyArgs>(
         args?: SelectSubset<T, TaskFindManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      >;

      /**
       * Create a Task.
       * @param {TaskCreateArgs} args - Arguments to create a Task.
       * @example
       * // Create one Task
       * const Task = await prisma.task.create({
       *   data: {
       *     // ... data to create a Task
       *   }
       * })
       *
       */
      create<T extends TaskCreateArgs>(
         args: SelectSubset<T, TaskCreateArgs<ExtArgs>>
      ): Prisma__TaskClient<
         $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Create many Tasks.
       * @param {TaskCreateManyArgs} args - Arguments to create many Tasks.
       * @example
       * // Create many Tasks
       * const task = await prisma.task.createMany({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       */
      createMany<T extends TaskCreateManyArgs>(
         args?: SelectSubset<T, TaskCreateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Create many Tasks and returns the data saved in the database.
       * @param {TaskCreateManyAndReturnArgs} args - Arguments to create many Tasks.
       * @example
       * // Create many Tasks
       * const task = await prisma.task.createManyAndReturn({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Create many Tasks and only return the `id`
       * const taskWithIdOnly = await prisma.task.createManyAndReturn({
       *   select: { id: true },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      createManyAndReturn<T extends TaskCreateManyAndReturnArgs>(
         args?: SelectSubset<T, TaskCreateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$TaskPayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Delete a Task.
       * @param {TaskDeleteArgs} args - Arguments to delete one Task.
       * @example
       * // Delete one Task
       * const Task = await prisma.task.delete({
       *   where: {
       *     // ... filter to delete one Task
       *   }
       * })
       *
       */
      delete<T extends TaskDeleteArgs>(
         args: SelectSubset<T, TaskDeleteArgs<ExtArgs>>
      ): Prisma__TaskClient<
         $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Update one Task.
       * @param {TaskUpdateArgs} args - Arguments to update one Task.
       * @example
       * // Update one Task
       * const task = await prisma.task.update({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      update<T extends TaskUpdateArgs>(
         args: SelectSubset<T, TaskUpdateArgs<ExtArgs>>
      ): Prisma__TaskClient<
         $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Delete zero or more Tasks.
       * @param {TaskDeleteManyArgs} args - Arguments to filter Tasks to delete.
       * @example
       * // Delete a few Tasks
       * const { count } = await prisma.task.deleteMany({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       *
       */
      deleteMany<T extends TaskDeleteManyArgs>(
         args?: SelectSubset<T, TaskDeleteManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more Tasks.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskUpdateManyArgs} args - Arguments to update one or more rows.
       * @example
       * // Update many Tasks
       * const task = await prisma.task.updateMany({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      updateMany<T extends TaskUpdateManyArgs>(
         args: SelectSubset<T, TaskUpdateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more Tasks and returns the data updated in the database.
       * @param {TaskUpdateManyAndReturnArgs} args - Arguments to update many Tasks.
       * @example
       * // Update many Tasks
       * const task = await prisma.task.updateManyAndReturn({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Update zero or more Tasks and only return the `id`
       * const taskWithIdOnly = await prisma.task.updateManyAndReturn({
       *   select: { id: true },
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      updateManyAndReturn<T extends TaskUpdateManyAndReturnArgs>(
         args: SelectSubset<T, TaskUpdateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$TaskPayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Create or update one Task.
       * @param {TaskUpsertArgs} args - Arguments to update or create a Task.
       * @example
       * // Update or create a Task
       * const task = await prisma.task.upsert({
       *   create: {
       *     // ... data to create a Task
       *   },
       *   update: {
       *     // ... in case it already exists, update
       *   },
       *   where: {
       *     // ... the filter for the Task we want to update
       *   }
       * })
       */
      upsert<T extends TaskUpsertArgs>(
         args: SelectSubset<T, TaskUpsertArgs<ExtArgs>>
      ): Prisma__TaskClient<
         $Result.GetResult<Prisma.$TaskPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Count the number of Tasks.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskCountArgs} args - Arguments to filter Tasks to count.
       * @example
       * // Count the number of Tasks
       * const count = await prisma.task.count({
       *   where: {
       *     // ... the filter for the Tasks we want to count
       *   }
       * })
       **/
      count<T extends TaskCountArgs>(
         args?: Subset<T, TaskCountArgs>
      ): Prisma.PrismaPromise<
         T extends $Utils.Record<'select', any>
            ? T['select'] extends true
               ? number
               : GetScalarType<T['select'], TaskCountAggregateOutputType>
            : number
      >;

      /**
       * Allows you to perform aggregations operations on a Task.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
       * @example
       * // Ordered by age ascending
       * // Where email contains prisma.io
       * // Limited to the 10 users
       * const aggregations = await prisma.user.aggregate({
       *   _avg: {
       *     age: true,
       *   },
       *   where: {
       *     email: {
       *       contains: "prisma.io",
       *     },
       *   },
       *   orderBy: {
       *     age: "asc",
       *   },
       *   take: 10,
       * })
       **/
      aggregate<T extends TaskAggregateArgs>(
         args: Subset<T, TaskAggregateArgs>
      ): Prisma.PrismaPromise<GetTaskAggregateType<T>>;

      /**
       * Group by Task.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskGroupByArgs} args - Group by arguments.
       * @example
       * // Group by city, order by createdAt, get count
       * const result = await prisma.user.groupBy({
       *   by: ['city', 'createdAt'],
       *   orderBy: {
       *     createdAt: true
       *   },
       *   _count: {
       *     _all: true
       *   },
       * })
       *
       **/
      groupBy<
         T extends TaskGroupByArgs,
         HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
         OrderByArg extends True extends HasSelectOrTake
            ? { orderBy: TaskGroupByArgs['orderBy'] }
            : { orderBy?: TaskGroupByArgs['orderBy'] },
         OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
         ByFields extends MaybeTupleToUnion<T['by']>,
         ByValid extends Has<ByFields, OrderFields>,
         HavingFields extends GetHavingFields<T['having']>,
         HavingValid extends Has<ByFields, HavingFields>,
         ByEmpty extends T['by'] extends never[] ? True : False,
         InputErrors extends ByEmpty extends True
            ? `Error: "by" must not be empty.`
            : HavingValid extends False
              ? {
                   [P in HavingFields]: P extends ByFields
                      ? never
                      : P extends string
                        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                        : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Keys<T>
                ? 'orderBy' extends Keys<T>
                   ? ByValid extends True
                      ? {}
                      : {
                           [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                        }[OrderFields]
                   : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Keys<T>
                  ? 'orderBy' extends Keys<T>
                     ? ByValid extends True
                        ? {}
                        : {
                             [P in OrderFields]: P extends ByFields
                                ? never
                                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                     : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends True
                    ? {}
                    : {
                         [P in OrderFields]: P extends ByFields
                            ? never
                            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
      >(
         args: SubsetIntersection<T, TaskGroupByArgs, OrderByArg> & InputErrors
      ): {} extends InputErrors ? GetTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
      /**
       * Fields of the Task model
       */
      readonly fields: TaskFieldRefs;
   }

   /**
    * The delegate class that acts as a "Promise-like" for Task.
    * Why is this prefixed with `Prisma__`?
    * Because we want to prevent naming conflicts as mentioned in
    * https://github.com/prisma/prisma-client-js/issues/707
    */
   export interface Prisma__TaskClient<
      T,
      Null = never,
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > extends Prisma.PrismaPromise<T> {
      readonly [Symbol.toStringTag]: 'PrismaPromise';
      subtasks<T extends Task$subtasksArgs<ExtArgs> = {}>(
         args?: Subset<T, Task$subtasksArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
      >;
      dependencies<T extends Task$dependenciesArgs<ExtArgs> = {}>(
         args?: Subset<T, Task$dependenciesArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         | $Result.GetResult<
              Prisma.$TaskDependencyPayload<ExtArgs>,
              T,
              'findMany',
              GlobalOmitOptions
           >
         | Null
      >;
      dependents<T extends Task$dependentsArgs<ExtArgs> = {}>(
         args?: Subset<T, Task$dependentsArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         | $Result.GetResult<
              Prisma.$TaskDependencyPayload<ExtArgs>,
              T,
              'findMany',
              GlobalOmitOptions
           >
         | Null
      >;
      issues<T extends Task$issuesArgs<ExtArgs> = {}>(
         args?: Subset<T, Task$issuesArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
      >;
      /**
       * Attaches callbacks for the resolution and/or rejection of the Promise.
       * @param onfulfilled The callback to execute when the Promise is resolved.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of which ever callback is executed.
       */
      then<TResult1 = T, TResult2 = never>(
         onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
         onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
      ): $Utils.JsPromise<TResult1 | TResult2>;
      /**
       * Attaches a callback for only the rejection of the Promise.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of the callback.
       */
      catch<TResult = never>(
         onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
      ): $Utils.JsPromise<T | TResult>;
      /**
       * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
       * resolved value cannot be modified from the callback.
       * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
       * @returns A Promise for the completion of the callback.
       */
      finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
   }

   /**
    * Fields of the Task model
    */
   interface TaskFieldRefs {
      readonly id: FieldRef<'Task', 'Int'>;
      readonly title: FieldRef<'Task', 'String'>;
      readonly description: FieldRef<'Task', 'String'>;
      readonly details: FieldRef<'Task', 'String'>;
      readonly testStrategy: FieldRef<'Task', 'String'>;
      readonly priority: FieldRef<'Task', 'String'>;
      readonly status: FieldRef<'Task', 'String'>;
      readonly complexity: FieldRef<'Task', 'Int'>;
      readonly createdAt: FieldRef<'Task', 'DateTime'>;
      readonly updatedAt: FieldRef<'Task', 'DateTime'>;
   }

   // Custom InputTypes
   /**
    * Task findUnique
    */
   export type TaskFindUniqueArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Task
       */
      select?: TaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Task
       */
      omit?: TaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskInclude<ExtArgs> | null;
      /**
       * Filter, which Task to fetch.
       */
      where: TaskWhereUniqueInput;
   };

   /**
    * Task findUniqueOrThrow
    */
   export type TaskFindUniqueOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Task
       */
      select?: TaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Task
       */
      omit?: TaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskInclude<ExtArgs> | null;
      /**
       * Filter, which Task to fetch.
       */
      where: TaskWhereUniqueInput;
   };

   /**
    * Task findFirst
    */
   export type TaskFindFirstArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Task
       */
      select?: TaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Task
       */
      omit?: TaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskInclude<ExtArgs> | null;
      /**
       * Filter, which Task to fetch.
       */
      where?: TaskWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Tasks to fetch.
       */
      orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for Tasks.
       */
      cursor?: TaskWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Tasks from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Tasks.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of Tasks.
       */
      distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[];
   };

   /**
    * Task findFirstOrThrow
    */
   export type TaskFindFirstOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Task
       */
      select?: TaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Task
       */
      omit?: TaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskInclude<ExtArgs> | null;
      /**
       * Filter, which Task to fetch.
       */
      where?: TaskWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Tasks to fetch.
       */
      orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for Tasks.
       */
      cursor?: TaskWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Tasks from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Tasks.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of Tasks.
       */
      distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[];
   };

   /**
    * Task findMany
    */
   export type TaskFindManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Task
       */
      select?: TaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Task
       */
      omit?: TaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskInclude<ExtArgs> | null;
      /**
       * Filter, which Tasks to fetch.
       */
      where?: TaskWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Tasks to fetch.
       */
      orderBy?: TaskOrderByWithRelationInput | TaskOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Tasks.
       */
      cursor?: TaskWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Tasks from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Tasks.
       */
      skip?: number;
      distinct?: TaskScalarFieldEnum | TaskScalarFieldEnum[];
   };

   /**
    * Task create
    */
   export type TaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Task
          */
         select?: TaskSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Task
          */
         omit?: TaskOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: TaskInclude<ExtArgs> | null;
         /**
          * The data needed to create a Task.
          */
         data: XOR<TaskCreateInput, TaskUncheckedCreateInput>;
      };

   /**
    * Task createMany
    */
   export type TaskCreateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to create many Tasks.
       */
      data: TaskCreateManyInput | TaskCreateManyInput[];
   };

   /**
    * Task createManyAndReturn
    */
   export type TaskCreateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Task
       */
      select?: TaskSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the Task
       */
      omit?: TaskOmit<ExtArgs> | null;
      /**
       * The data used to create many Tasks.
       */
      data: TaskCreateManyInput | TaskCreateManyInput[];
   };

   /**
    * Task update
    */
   export type TaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Task
          */
         select?: TaskSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Task
          */
         omit?: TaskOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: TaskInclude<ExtArgs> | null;
         /**
          * The data needed to update a Task.
          */
         data: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>;
         /**
          * Choose, which Task to update.
          */
         where: TaskWhereUniqueInput;
      };

   /**
    * Task updateMany
    */
   export type TaskUpdateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to update Tasks.
       */
      data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>;
      /**
       * Filter which Tasks to update
       */
      where?: TaskWhereInput;
      /**
       * Limit how many Tasks to update.
       */
      limit?: number;
   };

   /**
    * Task updateManyAndReturn
    */
   export type TaskUpdateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Task
       */
      select?: TaskSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the Task
       */
      omit?: TaskOmit<ExtArgs> | null;
      /**
       * The data used to update Tasks.
       */
      data: XOR<TaskUpdateManyMutationInput, TaskUncheckedUpdateManyInput>;
      /**
       * Filter which Tasks to update
       */
      where?: TaskWhereInput;
      /**
       * Limit how many Tasks to update.
       */
      limit?: number;
   };

   /**
    * Task upsert
    */
   export type TaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Task
          */
         select?: TaskSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Task
          */
         omit?: TaskOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: TaskInclude<ExtArgs> | null;
         /**
          * The filter to search for the Task to update in case it exists.
          */
         where: TaskWhereUniqueInput;
         /**
          * In case the Task found by the `where` argument doesn't exist, create a new Task with this data.
          */
         create: XOR<TaskCreateInput, TaskUncheckedCreateInput>;
         /**
          * In case the Task was found with the provided `where` argument, update it with this data.
          */
         update: XOR<TaskUpdateInput, TaskUncheckedUpdateInput>;
      };

   /**
    * Task delete
    */
   export type TaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Task
          */
         select?: TaskSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Task
          */
         omit?: TaskOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: TaskInclude<ExtArgs> | null;
         /**
          * Filter which Task to delete.
          */
         where: TaskWhereUniqueInput;
      };

   /**
    * Task deleteMany
    */
   export type TaskDeleteManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which Tasks to delete
       */
      where?: TaskWhereInput;
      /**
       * Limit how many Tasks to delete.
       */
      limit?: number;
   };

   /**
    * Task.subtasks
    */
   export type Task$subtasksArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Subtask
       */
      select?: SubtaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Subtask
       */
      omit?: SubtaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: SubtaskInclude<ExtArgs> | null;
      where?: SubtaskWhereInput;
      orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[];
      cursor?: SubtaskWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[];
   };

   /**
    * Task.dependencies
    */
   export type Task$dependenciesArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskDependency
       */
      select?: TaskDependencySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskDependency
       */
      omit?: TaskDependencyOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskDependencyInclude<ExtArgs> | null;
      where?: TaskDependencyWhereInput;
      orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[];
      cursor?: TaskDependencyWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[];
   };

   /**
    * Task.dependents
    */
   export type Task$dependentsArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskDependency
       */
      select?: TaskDependencySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskDependency
       */
      omit?: TaskDependencyOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskDependencyInclude<ExtArgs> | null;
      where?: TaskDependencyWhereInput;
      orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[];
      cursor?: TaskDependencyWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[];
   };

   /**
    * Task.issues
    */
   export type Task$issuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Issue
          */
         select?: IssueSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Issue
          */
         omit?: IssueOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: IssueInclude<ExtArgs> | null;
         where?: IssueWhereInput;
         orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[];
         cursor?: IssueWhereUniqueInput;
         take?: number;
         skip?: number;
         distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[];
      };

   /**
    * Task without action
    */
   export type TaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Task
          */
         select?: TaskSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Task
          */
         omit?: TaskOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: TaskInclude<ExtArgs> | null;
      };

   /**
    * Model Subtask
    */

   export type AggregateSubtask = {
      _count: SubtaskCountAggregateOutputType | null;
      _avg: SubtaskAvgAggregateOutputType | null;
      _sum: SubtaskSumAggregateOutputType | null;
      _min: SubtaskMinAggregateOutputType | null;
      _max: SubtaskMaxAggregateOutputType | null;
   };

   export type SubtaskAvgAggregateOutputType = {
      parentId: number | null;
   };

   export type SubtaskSumAggregateOutputType = {
      parentId: number | null;
   };

   export type SubtaskMinAggregateOutputType = {
      id: string | null;
      title: string | null;
      description: string | null;
      details: string | null;
      testStrategy: string | null;
      status: string | null;
      parentId: number | null;
      dependencies: string | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type SubtaskMaxAggregateOutputType = {
      id: string | null;
      title: string | null;
      description: string | null;
      details: string | null;
      testStrategy: string | null;
      status: string | null;
      parentId: number | null;
      dependencies: string | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type SubtaskCountAggregateOutputType = {
      id: number;
      title: number;
      description: number;
      details: number;
      testStrategy: number;
      status: number;
      parentId: number;
      dependencies: number;
      createdAt: number;
      updatedAt: number;
      _all: number;
   };

   export type SubtaskAvgAggregateInputType = {
      parentId?: true;
   };

   export type SubtaskSumAggregateInputType = {
      parentId?: true;
   };

   export type SubtaskMinAggregateInputType = {
      id?: true;
      title?: true;
      description?: true;
      details?: true;
      testStrategy?: true;
      status?: true;
      parentId?: true;
      dependencies?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type SubtaskMaxAggregateInputType = {
      id?: true;
      title?: true;
      description?: true;
      details?: true;
      testStrategy?: true;
      status?: true;
      parentId?: true;
      dependencies?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type SubtaskCountAggregateInputType = {
      id?: true;
      title?: true;
      description?: true;
      details?: true;
      testStrategy?: true;
      status?: true;
      parentId?: true;
      dependencies?: true;
      createdAt?: true;
      updatedAt?: true;
      _all?: true;
   };

   export type SubtaskAggregateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which Subtask to aggregate.
       */
      where?: SubtaskWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Subtasks to fetch.
       */
      orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: SubtaskWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Subtasks from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Subtasks.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned Subtasks
       **/
      _count?: true | SubtaskCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to average
       **/
      _avg?: SubtaskAvgAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to sum
       **/
      _sum?: SubtaskSumAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: SubtaskMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: SubtaskMaxAggregateInputType;
   };

   export type GetSubtaskAggregateType<T extends SubtaskAggregateArgs> = {
      [P in keyof T & keyof AggregateSubtask]: P extends '_count' | 'count'
         ? T[P] extends true
            ? number
            : GetScalarType<T[P], AggregateSubtask[P]>
         : GetScalarType<T[P], AggregateSubtask[P]>;
   };

   export type SubtaskGroupByArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: SubtaskWhereInput;
      orderBy?: SubtaskOrderByWithAggregationInput | SubtaskOrderByWithAggregationInput[];
      by: SubtaskScalarFieldEnum[] | SubtaskScalarFieldEnum;
      having?: SubtaskScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: SubtaskCountAggregateInputType | true;
      _avg?: SubtaskAvgAggregateInputType;
      _sum?: SubtaskSumAggregateInputType;
      _min?: SubtaskMinAggregateInputType;
      _max?: SubtaskMaxAggregateInputType;
   };

   export type SubtaskGroupByOutputType = {
      id: string;
      title: string;
      description: string;
      details: string | null;
      testStrategy: string | null;
      status: string;
      parentId: number;
      dependencies: string;
      createdAt: Date;
      updatedAt: Date;
      _count: SubtaskCountAggregateOutputType | null;
      _avg: SubtaskAvgAggregateOutputType | null;
      _sum: SubtaskSumAggregateOutputType | null;
      _min: SubtaskMinAggregateOutputType | null;
      _max: SubtaskMaxAggregateOutputType | null;
   };

   type GetSubtaskGroupByPayload<T extends SubtaskGroupByArgs> = Prisma.PrismaPromise<
      Array<
         PickEnumerable<SubtaskGroupByOutputType, T['by']> & {
            [P in keyof T & keyof SubtaskGroupByOutputType]: P extends '_count'
               ? T[P] extends boolean
                  ? number
                  : GetScalarType<T[P], SubtaskGroupByOutputType[P]>
               : GetScalarType<T[P], SubtaskGroupByOutputType[P]>;
         }
      >
   >;

   export type SubtaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetSelect<
         {
            id?: boolean;
            title?: boolean;
            description?: boolean;
            details?: boolean;
            testStrategy?: boolean;
            status?: boolean;
            parentId?: boolean;
            dependencies?: boolean;
            createdAt?: boolean;
            updatedAt?: boolean;
            parentTask?: boolean | TaskDefaultArgs<ExtArgs>;
         },
         ExtArgs['result']['subtask']
      >;

   export type SubtaskSelectCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         title?: boolean;
         description?: boolean;
         details?: boolean;
         testStrategy?: boolean;
         status?: boolean;
         parentId?: boolean;
         dependencies?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
         parentTask?: boolean | TaskDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['subtask']
   >;

   export type SubtaskSelectUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         title?: boolean;
         description?: boolean;
         details?: boolean;
         testStrategy?: boolean;
         status?: boolean;
         parentId?: boolean;
         dependencies?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
         parentTask?: boolean | TaskDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['subtask']
   >;

   export type SubtaskSelectScalar = {
      id?: boolean;
      title?: boolean;
      description?: boolean;
      details?: boolean;
      testStrategy?: boolean;
      status?: boolean;
      parentId?: boolean;
      dependencies?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
   };

   export type SubtaskOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetOmit<
         | 'id'
         | 'title'
         | 'description'
         | 'details'
         | 'testStrategy'
         | 'status'
         | 'parentId'
         | 'dependencies'
         | 'createdAt'
         | 'updatedAt',
         ExtArgs['result']['subtask']
      >;
   export type SubtaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         parentTask?: boolean | TaskDefaultArgs<ExtArgs>;
      };
   export type SubtaskIncludeCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      parentTask?: boolean | TaskDefaultArgs<ExtArgs>;
   };
   export type SubtaskIncludeUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      parentTask?: boolean | TaskDefaultArgs<ExtArgs>;
   };

   export type $SubtaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         name: 'Subtask';
         objects: {
            parentTask: Prisma.$TaskPayload<ExtArgs>;
         };
         scalars: $Extensions.GetPayloadResult<
            {
               id: string;
               title: string;
               description: string;
               details: string | null;
               testStrategy: string | null;
               status: string;
               parentId: number;
               dependencies: string;
               createdAt: Date;
               updatedAt: Date;
            },
            ExtArgs['result']['subtask']
         >;
         composites: {};
      };

   type SubtaskGetPayload<S extends boolean | null | undefined | SubtaskDefaultArgs> =
      $Result.GetResult<Prisma.$SubtaskPayload, S>;

   type SubtaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
      SubtaskFindManyArgs,
      'select' | 'include' | 'distinct' | 'omit'
   > & {
      select?: SubtaskCountAggregateInputType | true;
   };

   export interface SubtaskDelegate<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > {
      [K: symbol]: {
         types: Prisma.TypeMap<ExtArgs>['model']['Subtask'];
         meta: { name: 'Subtask' };
      };
      /**
       * Find zero or one Subtask that matches the filter.
       * @param {SubtaskFindUniqueArgs} args - Arguments to find a Subtask
       * @example
       * // Get one Subtask
       * const subtask = await prisma.subtask.findUnique({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUnique<T extends SubtaskFindUniqueArgs>(
         args: SelectSubset<T, SubtaskFindUniqueArgs<ExtArgs>>
      ): Prisma__SubtaskClient<
         $Result.GetResult<
            Prisma.$SubtaskPayload<ExtArgs>,
            T,
            'findUnique',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find one Subtask that matches the filter or throw an error with `error.code='P2025'`
       * if no matches were found.
       * @param {SubtaskFindUniqueOrThrowArgs} args - Arguments to find a Subtask
       * @example
       * // Get one Subtask
       * const subtask = await prisma.subtask.findUniqueOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUniqueOrThrow<T extends SubtaskFindUniqueOrThrowArgs>(
         args: SelectSubset<T, SubtaskFindUniqueOrThrowArgs<ExtArgs>>
      ): Prisma__SubtaskClient<
         $Result.GetResult<
            Prisma.$SubtaskPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first Subtask that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SubtaskFindFirstArgs} args - Arguments to find a Subtask
       * @example
       * // Get one Subtask
       * const subtask = await prisma.subtask.findFirst({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirst<T extends SubtaskFindFirstArgs>(
         args?: SelectSubset<T, SubtaskFindFirstArgs<ExtArgs>>
      ): Prisma__SubtaskClient<
         $Result.GetResult<
            Prisma.$SubtaskPayload<ExtArgs>,
            T,
            'findFirst',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first Subtask that matches the filter or
       * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SubtaskFindFirstOrThrowArgs} args - Arguments to find a Subtask
       * @example
       * // Get one Subtask
       * const subtask = await prisma.subtask.findFirstOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirstOrThrow<T extends SubtaskFindFirstOrThrowArgs>(
         args?: SelectSubset<T, SubtaskFindFirstOrThrowArgs<ExtArgs>>
      ): Prisma__SubtaskClient<
         $Result.GetResult<
            Prisma.$SubtaskPayload<ExtArgs>,
            T,
            'findFirstOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find zero or more Subtasks that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SubtaskFindManyArgs} args - Arguments to filter and select certain fields only.
       * @example
       * // Get all Subtasks
       * const subtasks = await prisma.subtask.findMany()
       *
       * // Get first 10 Subtasks
       * const subtasks = await prisma.subtask.findMany({ take: 10 })
       *
       * // Only select the `id`
       * const subtaskWithIdOnly = await prisma.subtask.findMany({ select: { id: true } })
       *
       */
      findMany<T extends SubtaskFindManyArgs>(
         args?: SelectSubset<T, SubtaskFindManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      >;

      /**
       * Create a Subtask.
       * @param {SubtaskCreateArgs} args - Arguments to create a Subtask.
       * @example
       * // Create one Subtask
       * const Subtask = await prisma.subtask.create({
       *   data: {
       *     // ... data to create a Subtask
       *   }
       * })
       *
       */
      create<T extends SubtaskCreateArgs>(
         args: SelectSubset<T, SubtaskCreateArgs<ExtArgs>>
      ): Prisma__SubtaskClient<
         $Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Create many Subtasks.
       * @param {SubtaskCreateManyArgs} args - Arguments to create many Subtasks.
       * @example
       * // Create many Subtasks
       * const subtask = await prisma.subtask.createMany({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       */
      createMany<T extends SubtaskCreateManyArgs>(
         args?: SelectSubset<T, SubtaskCreateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Create many Subtasks and returns the data saved in the database.
       * @param {SubtaskCreateManyAndReturnArgs} args - Arguments to create many Subtasks.
       * @example
       * // Create many Subtasks
       * const subtask = await prisma.subtask.createManyAndReturn({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Create many Subtasks and only return the `id`
       * const subtaskWithIdOnly = await prisma.subtask.createManyAndReturn({
       *   select: { id: true },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      createManyAndReturn<T extends SubtaskCreateManyAndReturnArgs>(
         args?: SelectSubset<T, SubtaskCreateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$SubtaskPayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Delete a Subtask.
       * @param {SubtaskDeleteArgs} args - Arguments to delete one Subtask.
       * @example
       * // Delete one Subtask
       * const Subtask = await prisma.subtask.delete({
       *   where: {
       *     // ... filter to delete one Subtask
       *   }
       * })
       *
       */
      delete<T extends SubtaskDeleteArgs>(
         args: SelectSubset<T, SubtaskDeleteArgs<ExtArgs>>
      ): Prisma__SubtaskClient<
         $Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Update one Subtask.
       * @param {SubtaskUpdateArgs} args - Arguments to update one Subtask.
       * @example
       * // Update one Subtask
       * const subtask = await prisma.subtask.update({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      update<T extends SubtaskUpdateArgs>(
         args: SelectSubset<T, SubtaskUpdateArgs<ExtArgs>>
      ): Prisma__SubtaskClient<
         $Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Delete zero or more Subtasks.
       * @param {SubtaskDeleteManyArgs} args - Arguments to filter Subtasks to delete.
       * @example
       * // Delete a few Subtasks
       * const { count } = await prisma.subtask.deleteMany({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       *
       */
      deleteMany<T extends SubtaskDeleteManyArgs>(
         args?: SelectSubset<T, SubtaskDeleteManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more Subtasks.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SubtaskUpdateManyArgs} args - Arguments to update one or more rows.
       * @example
       * // Update many Subtasks
       * const subtask = await prisma.subtask.updateMany({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      updateMany<T extends SubtaskUpdateManyArgs>(
         args: SelectSubset<T, SubtaskUpdateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more Subtasks and returns the data updated in the database.
       * @param {SubtaskUpdateManyAndReturnArgs} args - Arguments to update many Subtasks.
       * @example
       * // Update many Subtasks
       * const subtask = await prisma.subtask.updateManyAndReturn({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Update zero or more Subtasks and only return the `id`
       * const subtaskWithIdOnly = await prisma.subtask.updateManyAndReturn({
       *   select: { id: true },
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      updateManyAndReturn<T extends SubtaskUpdateManyAndReturnArgs>(
         args: SelectSubset<T, SubtaskUpdateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$SubtaskPayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Create or update one Subtask.
       * @param {SubtaskUpsertArgs} args - Arguments to update or create a Subtask.
       * @example
       * // Update or create a Subtask
       * const subtask = await prisma.subtask.upsert({
       *   create: {
       *     // ... data to create a Subtask
       *   },
       *   update: {
       *     // ... in case it already exists, update
       *   },
       *   where: {
       *     // ... the filter for the Subtask we want to update
       *   }
       * })
       */
      upsert<T extends SubtaskUpsertArgs>(
         args: SelectSubset<T, SubtaskUpsertArgs<ExtArgs>>
      ): Prisma__SubtaskClient<
         $Result.GetResult<Prisma.$SubtaskPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Count the number of Subtasks.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SubtaskCountArgs} args - Arguments to filter Subtasks to count.
       * @example
       * // Count the number of Subtasks
       * const count = await prisma.subtask.count({
       *   where: {
       *     // ... the filter for the Subtasks we want to count
       *   }
       * })
       **/
      count<T extends SubtaskCountArgs>(
         args?: Subset<T, SubtaskCountArgs>
      ): Prisma.PrismaPromise<
         T extends $Utils.Record<'select', any>
            ? T['select'] extends true
               ? number
               : GetScalarType<T['select'], SubtaskCountAggregateOutputType>
            : number
      >;

      /**
       * Allows you to perform aggregations operations on a Subtask.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SubtaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
       * @example
       * // Ordered by age ascending
       * // Where email contains prisma.io
       * // Limited to the 10 users
       * const aggregations = await prisma.user.aggregate({
       *   _avg: {
       *     age: true,
       *   },
       *   where: {
       *     email: {
       *       contains: "prisma.io",
       *     },
       *   },
       *   orderBy: {
       *     age: "asc",
       *   },
       *   take: 10,
       * })
       **/
      aggregate<T extends SubtaskAggregateArgs>(
         args: Subset<T, SubtaskAggregateArgs>
      ): Prisma.PrismaPromise<GetSubtaskAggregateType<T>>;

      /**
       * Group by Subtask.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SubtaskGroupByArgs} args - Group by arguments.
       * @example
       * // Group by city, order by createdAt, get count
       * const result = await prisma.user.groupBy({
       *   by: ['city', 'createdAt'],
       *   orderBy: {
       *     createdAt: true
       *   },
       *   _count: {
       *     _all: true
       *   },
       * })
       *
       **/
      groupBy<
         T extends SubtaskGroupByArgs,
         HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
         OrderByArg extends True extends HasSelectOrTake
            ? { orderBy: SubtaskGroupByArgs['orderBy'] }
            : { orderBy?: SubtaskGroupByArgs['orderBy'] },
         OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
         ByFields extends MaybeTupleToUnion<T['by']>,
         ByValid extends Has<ByFields, OrderFields>,
         HavingFields extends GetHavingFields<T['having']>,
         HavingValid extends Has<ByFields, HavingFields>,
         ByEmpty extends T['by'] extends never[] ? True : False,
         InputErrors extends ByEmpty extends True
            ? `Error: "by" must not be empty.`
            : HavingValid extends False
              ? {
                   [P in HavingFields]: P extends ByFields
                      ? never
                      : P extends string
                        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                        : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Keys<T>
                ? 'orderBy' extends Keys<T>
                   ? ByValid extends True
                      ? {}
                      : {
                           [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                        }[OrderFields]
                   : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Keys<T>
                  ? 'orderBy' extends Keys<T>
                     ? ByValid extends True
                        ? {}
                        : {
                             [P in OrderFields]: P extends ByFields
                                ? never
                                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                     : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends True
                    ? {}
                    : {
                         [P in OrderFields]: P extends ByFields
                            ? never
                            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
      >(
         args: SubsetIntersection<T, SubtaskGroupByArgs, OrderByArg> & InputErrors
      ): {} extends InputErrors ? GetSubtaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
      /**
       * Fields of the Subtask model
       */
      readonly fields: SubtaskFieldRefs;
   }

   /**
    * The delegate class that acts as a "Promise-like" for Subtask.
    * Why is this prefixed with `Prisma__`?
    * Because we want to prevent naming conflicts as mentioned in
    * https://github.com/prisma/prisma-client-js/issues/707
    */
   export interface Prisma__SubtaskClient<
      T,
      Null = never,
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > extends Prisma.PrismaPromise<T> {
      readonly [Symbol.toStringTag]: 'PrismaPromise';
      parentTask<T extends TaskDefaultArgs<ExtArgs> = {}>(
         args?: Subset<T, TaskDefaultArgs<ExtArgs>>
      ): Prisma__TaskClient<
         | $Result.GetResult<
              Prisma.$TaskPayload<ExtArgs>,
              T,
              'findUniqueOrThrow',
              GlobalOmitOptions
           >
         | Null,
         Null,
         ExtArgs,
         GlobalOmitOptions
      >;
      /**
       * Attaches callbacks for the resolution and/or rejection of the Promise.
       * @param onfulfilled The callback to execute when the Promise is resolved.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of which ever callback is executed.
       */
      then<TResult1 = T, TResult2 = never>(
         onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
         onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
      ): $Utils.JsPromise<TResult1 | TResult2>;
      /**
       * Attaches a callback for only the rejection of the Promise.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of the callback.
       */
      catch<TResult = never>(
         onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
      ): $Utils.JsPromise<T | TResult>;
      /**
       * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
       * resolved value cannot be modified from the callback.
       * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
       * @returns A Promise for the completion of the callback.
       */
      finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
   }

   /**
    * Fields of the Subtask model
    */
   interface SubtaskFieldRefs {
      readonly id: FieldRef<'Subtask', 'String'>;
      readonly title: FieldRef<'Subtask', 'String'>;
      readonly description: FieldRef<'Subtask', 'String'>;
      readonly details: FieldRef<'Subtask', 'String'>;
      readonly testStrategy: FieldRef<'Subtask', 'String'>;
      readonly status: FieldRef<'Subtask', 'String'>;
      readonly parentId: FieldRef<'Subtask', 'Int'>;
      readonly dependencies: FieldRef<'Subtask', 'String'>;
      readonly createdAt: FieldRef<'Subtask', 'DateTime'>;
      readonly updatedAt: FieldRef<'Subtask', 'DateTime'>;
   }

   // Custom InputTypes
   /**
    * Subtask findUnique
    */
   export type SubtaskFindUniqueArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Subtask
       */
      select?: SubtaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Subtask
       */
      omit?: SubtaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: SubtaskInclude<ExtArgs> | null;
      /**
       * Filter, which Subtask to fetch.
       */
      where: SubtaskWhereUniqueInput;
   };

   /**
    * Subtask findUniqueOrThrow
    */
   export type SubtaskFindUniqueOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Subtask
       */
      select?: SubtaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Subtask
       */
      omit?: SubtaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: SubtaskInclude<ExtArgs> | null;
      /**
       * Filter, which Subtask to fetch.
       */
      where: SubtaskWhereUniqueInput;
   };

   /**
    * Subtask findFirst
    */
   export type SubtaskFindFirstArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Subtask
       */
      select?: SubtaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Subtask
       */
      omit?: SubtaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: SubtaskInclude<ExtArgs> | null;
      /**
       * Filter, which Subtask to fetch.
       */
      where?: SubtaskWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Subtasks to fetch.
       */
      orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for Subtasks.
       */
      cursor?: SubtaskWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Subtasks from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Subtasks.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of Subtasks.
       */
      distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[];
   };

   /**
    * Subtask findFirstOrThrow
    */
   export type SubtaskFindFirstOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Subtask
       */
      select?: SubtaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Subtask
       */
      omit?: SubtaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: SubtaskInclude<ExtArgs> | null;
      /**
       * Filter, which Subtask to fetch.
       */
      where?: SubtaskWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Subtasks to fetch.
       */
      orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for Subtasks.
       */
      cursor?: SubtaskWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Subtasks from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Subtasks.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of Subtasks.
       */
      distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[];
   };

   /**
    * Subtask findMany
    */
   export type SubtaskFindManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Subtask
       */
      select?: SubtaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Subtask
       */
      omit?: SubtaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: SubtaskInclude<ExtArgs> | null;
      /**
       * Filter, which Subtasks to fetch.
       */
      where?: SubtaskWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Subtasks to fetch.
       */
      orderBy?: SubtaskOrderByWithRelationInput | SubtaskOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Subtasks.
       */
      cursor?: SubtaskWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Subtasks from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Subtasks.
       */
      skip?: number;
      distinct?: SubtaskScalarFieldEnum | SubtaskScalarFieldEnum[];
   };

   /**
    * Subtask create
    */
   export type SubtaskCreateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Subtask
       */
      select?: SubtaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Subtask
       */
      omit?: SubtaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: SubtaskInclude<ExtArgs> | null;
      /**
       * The data needed to create a Subtask.
       */
      data: XOR<SubtaskCreateInput, SubtaskUncheckedCreateInput>;
   };

   /**
    * Subtask createMany
    */
   export type SubtaskCreateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to create many Subtasks.
       */
      data: SubtaskCreateManyInput | SubtaskCreateManyInput[];
   };

   /**
    * Subtask createManyAndReturn
    */
   export type SubtaskCreateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Subtask
       */
      select?: SubtaskSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the Subtask
       */
      omit?: SubtaskOmit<ExtArgs> | null;
      /**
       * The data used to create many Subtasks.
       */
      data: SubtaskCreateManyInput | SubtaskCreateManyInput[];
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: SubtaskIncludeCreateManyAndReturn<ExtArgs> | null;
   };

   /**
    * Subtask update
    */
   export type SubtaskUpdateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Subtask
       */
      select?: SubtaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Subtask
       */
      omit?: SubtaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: SubtaskInclude<ExtArgs> | null;
      /**
       * The data needed to update a Subtask.
       */
      data: XOR<SubtaskUpdateInput, SubtaskUncheckedUpdateInput>;
      /**
       * Choose, which Subtask to update.
       */
      where: SubtaskWhereUniqueInput;
   };

   /**
    * Subtask updateMany
    */
   export type SubtaskUpdateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to update Subtasks.
       */
      data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyInput>;
      /**
       * Filter which Subtasks to update
       */
      where?: SubtaskWhereInput;
      /**
       * Limit how many Subtasks to update.
       */
      limit?: number;
   };

   /**
    * Subtask updateManyAndReturn
    */
   export type SubtaskUpdateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Subtask
       */
      select?: SubtaskSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the Subtask
       */
      omit?: SubtaskOmit<ExtArgs> | null;
      /**
       * The data used to update Subtasks.
       */
      data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyInput>;
      /**
       * Filter which Subtasks to update
       */
      where?: SubtaskWhereInput;
      /**
       * Limit how many Subtasks to update.
       */
      limit?: number;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: SubtaskIncludeUpdateManyAndReturn<ExtArgs> | null;
   };

   /**
    * Subtask upsert
    */
   export type SubtaskUpsertArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Subtask
       */
      select?: SubtaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Subtask
       */
      omit?: SubtaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: SubtaskInclude<ExtArgs> | null;
      /**
       * The filter to search for the Subtask to update in case it exists.
       */
      where: SubtaskWhereUniqueInput;
      /**
       * In case the Subtask found by the `where` argument doesn't exist, create a new Subtask with this data.
       */
      create: XOR<SubtaskCreateInput, SubtaskUncheckedCreateInput>;
      /**
       * In case the Subtask was found with the provided `where` argument, update it with this data.
       */
      update: XOR<SubtaskUpdateInput, SubtaskUncheckedUpdateInput>;
   };

   /**
    * Subtask delete
    */
   export type SubtaskDeleteArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Subtask
       */
      select?: SubtaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Subtask
       */
      omit?: SubtaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: SubtaskInclude<ExtArgs> | null;
      /**
       * Filter which Subtask to delete.
       */
      where: SubtaskWhereUniqueInput;
   };

   /**
    * Subtask deleteMany
    */
   export type SubtaskDeleteManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which Subtasks to delete
       */
      where?: SubtaskWhereInput;
      /**
       * Limit how many Subtasks to delete.
       */
      limit?: number;
   };

   /**
    * Subtask without action
    */
   export type SubtaskDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Subtask
       */
      select?: SubtaskSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Subtask
       */
      omit?: SubtaskOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: SubtaskInclude<ExtArgs> | null;
   };

   /**
    * Model TaskDependency
    */

   export type AggregateTaskDependency = {
      _count: TaskDependencyCountAggregateOutputType | null;
      _avg: TaskDependencyAvgAggregateOutputType | null;
      _sum: TaskDependencySumAggregateOutputType | null;
      _min: TaskDependencyMinAggregateOutputType | null;
      _max: TaskDependencyMaxAggregateOutputType | null;
   };

   export type TaskDependencyAvgAggregateOutputType = {
      id: number | null;
      taskId: number | null;
      dependsOnId: number | null;
   };

   export type TaskDependencySumAggregateOutputType = {
      id: number | null;
      taskId: number | null;
      dependsOnId: number | null;
   };

   export type TaskDependencyMinAggregateOutputType = {
      id: number | null;
      taskId: number | null;
      dependsOnId: number | null;
      createdAt: Date | null;
   };

   export type TaskDependencyMaxAggregateOutputType = {
      id: number | null;
      taskId: number | null;
      dependsOnId: number | null;
      createdAt: Date | null;
   };

   export type TaskDependencyCountAggregateOutputType = {
      id: number;
      taskId: number;
      dependsOnId: number;
      createdAt: number;
      _all: number;
   };

   export type TaskDependencyAvgAggregateInputType = {
      id?: true;
      taskId?: true;
      dependsOnId?: true;
   };

   export type TaskDependencySumAggregateInputType = {
      id?: true;
      taskId?: true;
      dependsOnId?: true;
   };

   export type TaskDependencyMinAggregateInputType = {
      id?: true;
      taskId?: true;
      dependsOnId?: true;
      createdAt?: true;
   };

   export type TaskDependencyMaxAggregateInputType = {
      id?: true;
      taskId?: true;
      dependsOnId?: true;
      createdAt?: true;
   };

   export type TaskDependencyCountAggregateInputType = {
      id?: true;
      taskId?: true;
      dependsOnId?: true;
      createdAt?: true;
      _all?: true;
   };

   export type TaskDependencyAggregateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which TaskDependency to aggregate.
       */
      where?: TaskDependencyWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of TaskDependencies to fetch.
       */
      orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: TaskDependencyWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` TaskDependencies from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` TaskDependencies.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned TaskDependencies
       **/
      _count?: true | TaskDependencyCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to average
       **/
      _avg?: TaskDependencyAvgAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to sum
       **/
      _sum?: TaskDependencySumAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: TaskDependencyMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: TaskDependencyMaxAggregateInputType;
   };

   export type GetTaskDependencyAggregateType<T extends TaskDependencyAggregateArgs> = {
      [P in keyof T & keyof AggregateTaskDependency]: P extends '_count' | 'count'
         ? T[P] extends true
            ? number
            : GetScalarType<T[P], AggregateTaskDependency[P]>
         : GetScalarType<T[P], AggregateTaskDependency[P]>;
   };

   export type TaskDependencyGroupByArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: TaskDependencyWhereInput;
      orderBy?:
         | TaskDependencyOrderByWithAggregationInput
         | TaskDependencyOrderByWithAggregationInput[];
      by: TaskDependencyScalarFieldEnum[] | TaskDependencyScalarFieldEnum;
      having?: TaskDependencyScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: TaskDependencyCountAggregateInputType | true;
      _avg?: TaskDependencyAvgAggregateInputType;
      _sum?: TaskDependencySumAggregateInputType;
      _min?: TaskDependencyMinAggregateInputType;
      _max?: TaskDependencyMaxAggregateInputType;
   };

   export type TaskDependencyGroupByOutputType = {
      id: number;
      taskId: number;
      dependsOnId: number;
      createdAt: Date;
      _count: TaskDependencyCountAggregateOutputType | null;
      _avg: TaskDependencyAvgAggregateOutputType | null;
      _sum: TaskDependencySumAggregateOutputType | null;
      _min: TaskDependencyMinAggregateOutputType | null;
      _max: TaskDependencyMaxAggregateOutputType | null;
   };

   type GetTaskDependencyGroupByPayload<T extends TaskDependencyGroupByArgs> = Prisma.PrismaPromise<
      Array<
         PickEnumerable<TaskDependencyGroupByOutputType, T['by']> & {
            [P in keyof T & keyof TaskDependencyGroupByOutputType]: P extends '_count'
               ? T[P] extends boolean
                  ? number
                  : GetScalarType<T[P], TaskDependencyGroupByOutputType[P]>
               : GetScalarType<T[P], TaskDependencyGroupByOutputType[P]>;
         }
      >
   >;

   export type TaskDependencySelect<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         taskId?: boolean;
         dependsOnId?: boolean;
         createdAt?: boolean;
         task?: boolean | TaskDefaultArgs<ExtArgs>;
         dependsOn?: boolean | TaskDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['taskDependency']
   >;

   export type TaskDependencySelectCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         taskId?: boolean;
         dependsOnId?: boolean;
         createdAt?: boolean;
         task?: boolean | TaskDefaultArgs<ExtArgs>;
         dependsOn?: boolean | TaskDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['taskDependency']
   >;

   export type TaskDependencySelectUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         taskId?: boolean;
         dependsOnId?: boolean;
         createdAt?: boolean;
         task?: boolean | TaskDefaultArgs<ExtArgs>;
         dependsOn?: boolean | TaskDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['taskDependency']
   >;

   export type TaskDependencySelectScalar = {
      id?: boolean;
      taskId?: boolean;
      dependsOnId?: boolean;
      createdAt?: boolean;
   };

   export type TaskDependencyOmit<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetOmit<
      'id' | 'taskId' | 'dependsOnId' | 'createdAt',
      ExtArgs['result']['taskDependency']
   >;
   export type TaskDependencyInclude<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      task?: boolean | TaskDefaultArgs<ExtArgs>;
      dependsOn?: boolean | TaskDefaultArgs<ExtArgs>;
   };
   export type TaskDependencyIncludeCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      task?: boolean | TaskDefaultArgs<ExtArgs>;
      dependsOn?: boolean | TaskDefaultArgs<ExtArgs>;
   };
   export type TaskDependencyIncludeUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      task?: boolean | TaskDefaultArgs<ExtArgs>;
      dependsOn?: boolean | TaskDefaultArgs<ExtArgs>;
   };

   export type $TaskDependencyPayload<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      name: 'TaskDependency';
      objects: {
         task: Prisma.$TaskPayload<ExtArgs>;
         dependsOn: Prisma.$TaskPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
         {
            id: number;
            taskId: number;
            dependsOnId: number;
            createdAt: Date;
         },
         ExtArgs['result']['taskDependency']
      >;
      composites: {};
   };

   type TaskDependencyGetPayload<S extends boolean | null | undefined | TaskDependencyDefaultArgs> =
      $Result.GetResult<Prisma.$TaskDependencyPayload, S>;

   type TaskDependencyCountArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = Omit<TaskDependencyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskDependencyCountAggregateInputType | true;
   };

   export interface TaskDependencyDelegate<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > {
      [K: symbol]: {
         types: Prisma.TypeMap<ExtArgs>['model']['TaskDependency'];
         meta: { name: 'TaskDependency' };
      };
      /**
       * Find zero or one TaskDependency that matches the filter.
       * @param {TaskDependencyFindUniqueArgs} args - Arguments to find a TaskDependency
       * @example
       * // Get one TaskDependency
       * const taskDependency = await prisma.taskDependency.findUnique({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUnique<T extends TaskDependencyFindUniqueArgs>(
         args: SelectSubset<T, TaskDependencyFindUniqueArgs<ExtArgs>>
      ): Prisma__TaskDependencyClient<
         $Result.GetResult<
            Prisma.$TaskDependencyPayload<ExtArgs>,
            T,
            'findUnique',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find one TaskDependency that matches the filter or throw an error with `error.code='P2025'`
       * if no matches were found.
       * @param {TaskDependencyFindUniqueOrThrowArgs} args - Arguments to find a TaskDependency
       * @example
       * // Get one TaskDependency
       * const taskDependency = await prisma.taskDependency.findUniqueOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUniqueOrThrow<T extends TaskDependencyFindUniqueOrThrowArgs>(
         args: SelectSubset<T, TaskDependencyFindUniqueOrThrowArgs<ExtArgs>>
      ): Prisma__TaskDependencyClient<
         $Result.GetResult<
            Prisma.$TaskDependencyPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first TaskDependency that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskDependencyFindFirstArgs} args - Arguments to find a TaskDependency
       * @example
       * // Get one TaskDependency
       * const taskDependency = await prisma.taskDependency.findFirst({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirst<T extends TaskDependencyFindFirstArgs>(
         args?: SelectSubset<T, TaskDependencyFindFirstArgs<ExtArgs>>
      ): Prisma__TaskDependencyClient<
         $Result.GetResult<
            Prisma.$TaskDependencyPayload<ExtArgs>,
            T,
            'findFirst',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first TaskDependency that matches the filter or
       * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskDependencyFindFirstOrThrowArgs} args - Arguments to find a TaskDependency
       * @example
       * // Get one TaskDependency
       * const taskDependency = await prisma.taskDependency.findFirstOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirstOrThrow<T extends TaskDependencyFindFirstOrThrowArgs>(
         args?: SelectSubset<T, TaskDependencyFindFirstOrThrowArgs<ExtArgs>>
      ): Prisma__TaskDependencyClient<
         $Result.GetResult<
            Prisma.$TaskDependencyPayload<ExtArgs>,
            T,
            'findFirstOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find zero or more TaskDependencies that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskDependencyFindManyArgs} args - Arguments to filter and select certain fields only.
       * @example
       * // Get all TaskDependencies
       * const taskDependencies = await prisma.taskDependency.findMany()
       *
       * // Get first 10 TaskDependencies
       * const taskDependencies = await prisma.taskDependency.findMany({ take: 10 })
       *
       * // Only select the `id`
       * const taskDependencyWithIdOnly = await prisma.taskDependency.findMany({ select: { id: true } })
       *
       */
      findMany<T extends TaskDependencyFindManyArgs>(
         args?: SelectSubset<T, TaskDependencyFindManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      >;

      /**
       * Create a TaskDependency.
       * @param {TaskDependencyCreateArgs} args - Arguments to create a TaskDependency.
       * @example
       * // Create one TaskDependency
       * const TaskDependency = await prisma.taskDependency.create({
       *   data: {
       *     // ... data to create a TaskDependency
       *   }
       * })
       *
       */
      create<T extends TaskDependencyCreateArgs>(
         args: SelectSubset<T, TaskDependencyCreateArgs<ExtArgs>>
      ): Prisma__TaskDependencyClient<
         $Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Create many TaskDependencies.
       * @param {TaskDependencyCreateManyArgs} args - Arguments to create many TaskDependencies.
       * @example
       * // Create many TaskDependencies
       * const taskDependency = await prisma.taskDependency.createMany({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       */
      createMany<T extends TaskDependencyCreateManyArgs>(
         args?: SelectSubset<T, TaskDependencyCreateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Create many TaskDependencies and returns the data saved in the database.
       * @param {TaskDependencyCreateManyAndReturnArgs} args - Arguments to create many TaskDependencies.
       * @example
       * // Create many TaskDependencies
       * const taskDependency = await prisma.taskDependency.createManyAndReturn({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Create many TaskDependencies and only return the `id`
       * const taskDependencyWithIdOnly = await prisma.taskDependency.createManyAndReturn({
       *   select: { id: true },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      createManyAndReturn<T extends TaskDependencyCreateManyAndReturnArgs>(
         args?: SelectSubset<T, TaskDependencyCreateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$TaskDependencyPayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Delete a TaskDependency.
       * @param {TaskDependencyDeleteArgs} args - Arguments to delete one TaskDependency.
       * @example
       * // Delete one TaskDependency
       * const TaskDependency = await prisma.taskDependency.delete({
       *   where: {
       *     // ... filter to delete one TaskDependency
       *   }
       * })
       *
       */
      delete<T extends TaskDependencyDeleteArgs>(
         args: SelectSubset<T, TaskDependencyDeleteArgs<ExtArgs>>
      ): Prisma__TaskDependencyClient<
         $Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Update one TaskDependency.
       * @param {TaskDependencyUpdateArgs} args - Arguments to update one TaskDependency.
       * @example
       * // Update one TaskDependency
       * const taskDependency = await prisma.taskDependency.update({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      update<T extends TaskDependencyUpdateArgs>(
         args: SelectSubset<T, TaskDependencyUpdateArgs<ExtArgs>>
      ): Prisma__TaskDependencyClient<
         $Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Delete zero or more TaskDependencies.
       * @param {TaskDependencyDeleteManyArgs} args - Arguments to filter TaskDependencies to delete.
       * @example
       * // Delete a few TaskDependencies
       * const { count } = await prisma.taskDependency.deleteMany({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       *
       */
      deleteMany<T extends TaskDependencyDeleteManyArgs>(
         args?: SelectSubset<T, TaskDependencyDeleteManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more TaskDependencies.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskDependencyUpdateManyArgs} args - Arguments to update one or more rows.
       * @example
       * // Update many TaskDependencies
       * const taskDependency = await prisma.taskDependency.updateMany({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      updateMany<T extends TaskDependencyUpdateManyArgs>(
         args: SelectSubset<T, TaskDependencyUpdateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more TaskDependencies and returns the data updated in the database.
       * @param {TaskDependencyUpdateManyAndReturnArgs} args - Arguments to update many TaskDependencies.
       * @example
       * // Update many TaskDependencies
       * const taskDependency = await prisma.taskDependency.updateManyAndReturn({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Update zero or more TaskDependencies and only return the `id`
       * const taskDependencyWithIdOnly = await prisma.taskDependency.updateManyAndReturn({
       *   select: { id: true },
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      updateManyAndReturn<T extends TaskDependencyUpdateManyAndReturnArgs>(
         args: SelectSubset<T, TaskDependencyUpdateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$TaskDependencyPayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Create or update one TaskDependency.
       * @param {TaskDependencyUpsertArgs} args - Arguments to update or create a TaskDependency.
       * @example
       * // Update or create a TaskDependency
       * const taskDependency = await prisma.taskDependency.upsert({
       *   create: {
       *     // ... data to create a TaskDependency
       *   },
       *   update: {
       *     // ... in case it already exists, update
       *   },
       *   where: {
       *     // ... the filter for the TaskDependency we want to update
       *   }
       * })
       */
      upsert<T extends TaskDependencyUpsertArgs>(
         args: SelectSubset<T, TaskDependencyUpsertArgs<ExtArgs>>
      ): Prisma__TaskDependencyClient<
         $Result.GetResult<Prisma.$TaskDependencyPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Count the number of TaskDependencies.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskDependencyCountArgs} args - Arguments to filter TaskDependencies to count.
       * @example
       * // Count the number of TaskDependencies
       * const count = await prisma.taskDependency.count({
       *   where: {
       *     // ... the filter for the TaskDependencies we want to count
       *   }
       * })
       **/
      count<T extends TaskDependencyCountArgs>(
         args?: Subset<T, TaskDependencyCountArgs>
      ): Prisma.PrismaPromise<
         T extends $Utils.Record<'select', any>
            ? T['select'] extends true
               ? number
               : GetScalarType<T['select'], TaskDependencyCountAggregateOutputType>
            : number
      >;

      /**
       * Allows you to perform aggregations operations on a TaskDependency.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskDependencyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
       * @example
       * // Ordered by age ascending
       * // Where email contains prisma.io
       * // Limited to the 10 users
       * const aggregations = await prisma.user.aggregate({
       *   _avg: {
       *     age: true,
       *   },
       *   where: {
       *     email: {
       *       contains: "prisma.io",
       *     },
       *   },
       *   orderBy: {
       *     age: "asc",
       *   },
       *   take: 10,
       * })
       **/
      aggregate<T extends TaskDependencyAggregateArgs>(
         args: Subset<T, TaskDependencyAggregateArgs>
      ): Prisma.PrismaPromise<GetTaskDependencyAggregateType<T>>;

      /**
       * Group by TaskDependency.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskDependencyGroupByArgs} args - Group by arguments.
       * @example
       * // Group by city, order by createdAt, get count
       * const result = await prisma.user.groupBy({
       *   by: ['city', 'createdAt'],
       *   orderBy: {
       *     createdAt: true
       *   },
       *   _count: {
       *     _all: true
       *   },
       * })
       *
       **/
      groupBy<
         T extends TaskDependencyGroupByArgs,
         HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
         OrderByArg extends True extends HasSelectOrTake
            ? { orderBy: TaskDependencyGroupByArgs['orderBy'] }
            : { orderBy?: TaskDependencyGroupByArgs['orderBy'] },
         OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
         ByFields extends MaybeTupleToUnion<T['by']>,
         ByValid extends Has<ByFields, OrderFields>,
         HavingFields extends GetHavingFields<T['having']>,
         HavingValid extends Has<ByFields, HavingFields>,
         ByEmpty extends T['by'] extends never[] ? True : False,
         InputErrors extends ByEmpty extends True
            ? `Error: "by" must not be empty.`
            : HavingValid extends False
              ? {
                   [P in HavingFields]: P extends ByFields
                      ? never
                      : P extends string
                        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                        : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Keys<T>
                ? 'orderBy' extends Keys<T>
                   ? ByValid extends True
                      ? {}
                      : {
                           [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                        }[OrderFields]
                   : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Keys<T>
                  ? 'orderBy' extends Keys<T>
                     ? ByValid extends True
                        ? {}
                        : {
                             [P in OrderFields]: P extends ByFields
                                ? never
                                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                     : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends True
                    ? {}
                    : {
                         [P in OrderFields]: P extends ByFields
                            ? never
                            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
      >(
         args: SubsetIntersection<T, TaskDependencyGroupByArgs, OrderByArg> & InputErrors
      ): {} extends InputErrors
         ? GetTaskDependencyGroupByPayload<T>
         : Prisma.PrismaPromise<InputErrors>;
      /**
       * Fields of the TaskDependency model
       */
      readonly fields: TaskDependencyFieldRefs;
   }

   /**
    * The delegate class that acts as a "Promise-like" for TaskDependency.
    * Why is this prefixed with `Prisma__`?
    * Because we want to prevent naming conflicts as mentioned in
    * https://github.com/prisma/prisma-client-js/issues/707
    */
   export interface Prisma__TaskDependencyClient<
      T,
      Null = never,
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > extends Prisma.PrismaPromise<T> {
      readonly [Symbol.toStringTag]: 'PrismaPromise';
      task<T extends TaskDefaultArgs<ExtArgs> = {}>(
         args?: Subset<T, TaskDefaultArgs<ExtArgs>>
      ): Prisma__TaskClient<
         | $Result.GetResult<
              Prisma.$TaskPayload<ExtArgs>,
              T,
              'findUniqueOrThrow',
              GlobalOmitOptions
           >
         | Null,
         Null,
         ExtArgs,
         GlobalOmitOptions
      >;
      dependsOn<T extends TaskDefaultArgs<ExtArgs> = {}>(
         args?: Subset<T, TaskDefaultArgs<ExtArgs>>
      ): Prisma__TaskClient<
         | $Result.GetResult<
              Prisma.$TaskPayload<ExtArgs>,
              T,
              'findUniqueOrThrow',
              GlobalOmitOptions
           >
         | Null,
         Null,
         ExtArgs,
         GlobalOmitOptions
      >;
      /**
       * Attaches callbacks for the resolution and/or rejection of the Promise.
       * @param onfulfilled The callback to execute when the Promise is resolved.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of which ever callback is executed.
       */
      then<TResult1 = T, TResult2 = never>(
         onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
         onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
      ): $Utils.JsPromise<TResult1 | TResult2>;
      /**
       * Attaches a callback for only the rejection of the Promise.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of the callback.
       */
      catch<TResult = never>(
         onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
      ): $Utils.JsPromise<T | TResult>;
      /**
       * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
       * resolved value cannot be modified from the callback.
       * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
       * @returns A Promise for the completion of the callback.
       */
      finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
   }

   /**
    * Fields of the TaskDependency model
    */
   interface TaskDependencyFieldRefs {
      readonly id: FieldRef<'TaskDependency', 'Int'>;
      readonly taskId: FieldRef<'TaskDependency', 'Int'>;
      readonly dependsOnId: FieldRef<'TaskDependency', 'Int'>;
      readonly createdAt: FieldRef<'TaskDependency', 'DateTime'>;
   }

   // Custom InputTypes
   /**
    * TaskDependency findUnique
    */
   export type TaskDependencyFindUniqueArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskDependency
       */
      select?: TaskDependencySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskDependency
       */
      omit?: TaskDependencyOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskDependencyInclude<ExtArgs> | null;
      /**
       * Filter, which TaskDependency to fetch.
       */
      where: TaskDependencyWhereUniqueInput;
   };

   /**
    * TaskDependency findUniqueOrThrow
    */
   export type TaskDependencyFindUniqueOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskDependency
       */
      select?: TaskDependencySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskDependency
       */
      omit?: TaskDependencyOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskDependencyInclude<ExtArgs> | null;
      /**
       * Filter, which TaskDependency to fetch.
       */
      where: TaskDependencyWhereUniqueInput;
   };

   /**
    * TaskDependency findFirst
    */
   export type TaskDependencyFindFirstArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskDependency
       */
      select?: TaskDependencySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskDependency
       */
      omit?: TaskDependencyOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskDependencyInclude<ExtArgs> | null;
      /**
       * Filter, which TaskDependency to fetch.
       */
      where?: TaskDependencyWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of TaskDependencies to fetch.
       */
      orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for TaskDependencies.
       */
      cursor?: TaskDependencyWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` TaskDependencies from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` TaskDependencies.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of TaskDependencies.
       */
      distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[];
   };

   /**
    * TaskDependency findFirstOrThrow
    */
   export type TaskDependencyFindFirstOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskDependency
       */
      select?: TaskDependencySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskDependency
       */
      omit?: TaskDependencyOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskDependencyInclude<ExtArgs> | null;
      /**
       * Filter, which TaskDependency to fetch.
       */
      where?: TaskDependencyWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of TaskDependencies to fetch.
       */
      orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for TaskDependencies.
       */
      cursor?: TaskDependencyWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` TaskDependencies from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` TaskDependencies.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of TaskDependencies.
       */
      distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[];
   };

   /**
    * TaskDependency findMany
    */
   export type TaskDependencyFindManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskDependency
       */
      select?: TaskDependencySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskDependency
       */
      omit?: TaskDependencyOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskDependencyInclude<ExtArgs> | null;
      /**
       * Filter, which TaskDependencies to fetch.
       */
      where?: TaskDependencyWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of TaskDependencies to fetch.
       */
      orderBy?: TaskDependencyOrderByWithRelationInput | TaskDependencyOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing TaskDependencies.
       */
      cursor?: TaskDependencyWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` TaskDependencies from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` TaskDependencies.
       */
      skip?: number;
      distinct?: TaskDependencyScalarFieldEnum | TaskDependencyScalarFieldEnum[];
   };

   /**
    * TaskDependency create
    */
   export type TaskDependencyCreateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskDependency
       */
      select?: TaskDependencySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskDependency
       */
      omit?: TaskDependencyOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskDependencyInclude<ExtArgs> | null;
      /**
       * The data needed to create a TaskDependency.
       */
      data: XOR<TaskDependencyCreateInput, TaskDependencyUncheckedCreateInput>;
   };

   /**
    * TaskDependency createMany
    */
   export type TaskDependencyCreateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to create many TaskDependencies.
       */
      data: TaskDependencyCreateManyInput | TaskDependencyCreateManyInput[];
   };

   /**
    * TaskDependency createManyAndReturn
    */
   export type TaskDependencyCreateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskDependency
       */
      select?: TaskDependencySelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskDependency
       */
      omit?: TaskDependencyOmit<ExtArgs> | null;
      /**
       * The data used to create many TaskDependencies.
       */
      data: TaskDependencyCreateManyInput | TaskDependencyCreateManyInput[];
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskDependencyIncludeCreateManyAndReturn<ExtArgs> | null;
   };

   /**
    * TaskDependency update
    */
   export type TaskDependencyUpdateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskDependency
       */
      select?: TaskDependencySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskDependency
       */
      omit?: TaskDependencyOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskDependencyInclude<ExtArgs> | null;
      /**
       * The data needed to update a TaskDependency.
       */
      data: XOR<TaskDependencyUpdateInput, TaskDependencyUncheckedUpdateInput>;
      /**
       * Choose, which TaskDependency to update.
       */
      where: TaskDependencyWhereUniqueInput;
   };

   /**
    * TaskDependency updateMany
    */
   export type TaskDependencyUpdateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to update TaskDependencies.
       */
      data: XOR<TaskDependencyUpdateManyMutationInput, TaskDependencyUncheckedUpdateManyInput>;
      /**
       * Filter which TaskDependencies to update
       */
      where?: TaskDependencyWhereInput;
      /**
       * Limit how many TaskDependencies to update.
       */
      limit?: number;
   };

   /**
    * TaskDependency updateManyAndReturn
    */
   export type TaskDependencyUpdateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskDependency
       */
      select?: TaskDependencySelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskDependency
       */
      omit?: TaskDependencyOmit<ExtArgs> | null;
      /**
       * The data used to update TaskDependencies.
       */
      data: XOR<TaskDependencyUpdateManyMutationInput, TaskDependencyUncheckedUpdateManyInput>;
      /**
       * Filter which TaskDependencies to update
       */
      where?: TaskDependencyWhereInput;
      /**
       * Limit how many TaskDependencies to update.
       */
      limit?: number;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskDependencyIncludeUpdateManyAndReturn<ExtArgs> | null;
   };

   /**
    * TaskDependency upsert
    */
   export type TaskDependencyUpsertArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskDependency
       */
      select?: TaskDependencySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskDependency
       */
      omit?: TaskDependencyOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskDependencyInclude<ExtArgs> | null;
      /**
       * The filter to search for the TaskDependency to update in case it exists.
       */
      where: TaskDependencyWhereUniqueInput;
      /**
       * In case the TaskDependency found by the `where` argument doesn't exist, create a new TaskDependency with this data.
       */
      create: XOR<TaskDependencyCreateInput, TaskDependencyUncheckedCreateInput>;
      /**
       * In case the TaskDependency was found with the provided `where` argument, update it with this data.
       */
      update: XOR<TaskDependencyUpdateInput, TaskDependencyUncheckedUpdateInput>;
   };

   /**
    * TaskDependency delete
    */
   export type TaskDependencyDeleteArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskDependency
       */
      select?: TaskDependencySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskDependency
       */
      omit?: TaskDependencyOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskDependencyInclude<ExtArgs> | null;
      /**
       * Filter which TaskDependency to delete.
       */
      where: TaskDependencyWhereUniqueInput;
   };

   /**
    * TaskDependency deleteMany
    */
   export type TaskDependencyDeleteManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which TaskDependencies to delete
       */
      where?: TaskDependencyWhereInput;
      /**
       * Limit how many TaskDependencies to delete.
       */
      limit?: number;
   };

   /**
    * TaskDependency without action
    */
   export type TaskDependencyDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskDependency
       */
      select?: TaskDependencySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskDependency
       */
      omit?: TaskDependencyOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TaskDependencyInclude<ExtArgs> | null;
   };

   /**
    * Model TaskMasterMetadata
    */

   export type AggregateTaskMasterMetadata = {
      _count: TaskMasterMetadataCountAggregateOutputType | null;
      _avg: TaskMasterMetadataAvgAggregateOutputType | null;
      _sum: TaskMasterMetadataSumAggregateOutputType | null;
      _min: TaskMasterMetadataMinAggregateOutputType | null;
      _max: TaskMasterMetadataMaxAggregateOutputType | null;
   };

   export type TaskMasterMetadataAvgAggregateOutputType = {
      id: number | null;
   };

   export type TaskMasterMetadataSumAggregateOutputType = {
      id: number | null;
   };

   export type TaskMasterMetadataMinAggregateOutputType = {
      id: number | null;
      created: Date | null;
      updated: Date | null;
      description: string | null;
   };

   export type TaskMasterMetadataMaxAggregateOutputType = {
      id: number | null;
      created: Date | null;
      updated: Date | null;
      description: string | null;
   };

   export type TaskMasterMetadataCountAggregateOutputType = {
      id: number;
      created: number;
      updated: number;
      description: number;
      _all: number;
   };

   export type TaskMasterMetadataAvgAggregateInputType = {
      id?: true;
   };

   export type TaskMasterMetadataSumAggregateInputType = {
      id?: true;
   };

   export type TaskMasterMetadataMinAggregateInputType = {
      id?: true;
      created?: true;
      updated?: true;
      description?: true;
   };

   export type TaskMasterMetadataMaxAggregateInputType = {
      id?: true;
      created?: true;
      updated?: true;
      description?: true;
   };

   export type TaskMasterMetadataCountAggregateInputType = {
      id?: true;
      created?: true;
      updated?: true;
      description?: true;
      _all?: true;
   };

   export type TaskMasterMetadataAggregateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which TaskMasterMetadata to aggregate.
       */
      where?: TaskMasterMetadataWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of TaskMasterMetadata to fetch.
       */
      orderBy?:
         | TaskMasterMetadataOrderByWithRelationInput
         | TaskMasterMetadataOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: TaskMasterMetadataWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` TaskMasterMetadata from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` TaskMasterMetadata.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned TaskMasterMetadata
       **/
      _count?: true | TaskMasterMetadataCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to average
       **/
      _avg?: TaskMasterMetadataAvgAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to sum
       **/
      _sum?: TaskMasterMetadataSumAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: TaskMasterMetadataMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: TaskMasterMetadataMaxAggregateInputType;
   };

   export type GetTaskMasterMetadataAggregateType<T extends TaskMasterMetadataAggregateArgs> = {
      [P in keyof T & keyof AggregateTaskMasterMetadata]: P extends '_count' | 'count'
         ? T[P] extends true
            ? number
            : GetScalarType<T[P], AggregateTaskMasterMetadata[P]>
         : GetScalarType<T[P], AggregateTaskMasterMetadata[P]>;
   };

   export type TaskMasterMetadataGroupByArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: TaskMasterMetadataWhereInput;
      orderBy?:
         | TaskMasterMetadataOrderByWithAggregationInput
         | TaskMasterMetadataOrderByWithAggregationInput[];
      by: TaskMasterMetadataScalarFieldEnum[] | TaskMasterMetadataScalarFieldEnum;
      having?: TaskMasterMetadataScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: TaskMasterMetadataCountAggregateInputType | true;
      _avg?: TaskMasterMetadataAvgAggregateInputType;
      _sum?: TaskMasterMetadataSumAggregateInputType;
      _min?: TaskMasterMetadataMinAggregateInputType;
      _max?: TaskMasterMetadataMaxAggregateInputType;
   };

   export type TaskMasterMetadataGroupByOutputType = {
      id: number;
      created: Date;
      updated: Date;
      description: string;
      _count: TaskMasterMetadataCountAggregateOutputType | null;
      _avg: TaskMasterMetadataAvgAggregateOutputType | null;
      _sum: TaskMasterMetadataSumAggregateOutputType | null;
      _min: TaskMasterMetadataMinAggregateOutputType | null;
      _max: TaskMasterMetadataMaxAggregateOutputType | null;
   };

   type GetTaskMasterMetadataGroupByPayload<T extends TaskMasterMetadataGroupByArgs> =
      Prisma.PrismaPromise<
         Array<
            PickEnumerable<TaskMasterMetadataGroupByOutputType, T['by']> & {
               [P in keyof T & keyof TaskMasterMetadataGroupByOutputType]: P extends '_count'
                  ? T[P] extends boolean
                     ? number
                     : GetScalarType<T[P], TaskMasterMetadataGroupByOutputType[P]>
                  : GetScalarType<T[P], TaskMasterMetadataGroupByOutputType[P]>;
            }
         >
      >;

   export type TaskMasterMetadataSelect<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         created?: boolean;
         updated?: boolean;
         description?: boolean;
      },
      ExtArgs['result']['taskMasterMetadata']
   >;

   export type TaskMasterMetadataSelectCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         created?: boolean;
         updated?: boolean;
         description?: boolean;
      },
      ExtArgs['result']['taskMasterMetadata']
   >;

   export type TaskMasterMetadataSelectUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         created?: boolean;
         updated?: boolean;
         description?: boolean;
      },
      ExtArgs['result']['taskMasterMetadata']
   >;

   export type TaskMasterMetadataSelectScalar = {
      id?: boolean;
      created?: boolean;
      updated?: boolean;
      description?: boolean;
   };

   export type TaskMasterMetadataOmit<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetOmit<
      'id' | 'created' | 'updated' | 'description',
      ExtArgs['result']['taskMasterMetadata']
   >;

   export type $TaskMasterMetadataPayload<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      name: 'TaskMasterMetadata';
      objects: {};
      scalars: $Extensions.GetPayloadResult<
         {
            id: number;
            created: Date;
            updated: Date;
            description: string;
         },
         ExtArgs['result']['taskMasterMetadata']
      >;
      composites: {};
   };

   type TaskMasterMetadataGetPayload<
      S extends boolean | null | undefined | TaskMasterMetadataDefaultArgs,
   > = $Result.GetResult<Prisma.$TaskMasterMetadataPayload, S>;

   type TaskMasterMetadataCountArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = Omit<TaskMasterMetadataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TaskMasterMetadataCountAggregateInputType | true;
   };

   export interface TaskMasterMetadataDelegate<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > {
      [K: symbol]: {
         types: Prisma.TypeMap<ExtArgs>['model']['TaskMasterMetadata'];
         meta: { name: 'TaskMasterMetadata' };
      };
      /**
       * Find zero or one TaskMasterMetadata that matches the filter.
       * @param {TaskMasterMetadataFindUniqueArgs} args - Arguments to find a TaskMasterMetadata
       * @example
       * // Get one TaskMasterMetadata
       * const taskMasterMetadata = await prisma.taskMasterMetadata.findUnique({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUnique<T extends TaskMasterMetadataFindUniqueArgs>(
         args: SelectSubset<T, TaskMasterMetadataFindUniqueArgs<ExtArgs>>
      ): Prisma__TaskMasterMetadataClient<
         $Result.GetResult<
            Prisma.$TaskMasterMetadataPayload<ExtArgs>,
            T,
            'findUnique',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find one TaskMasterMetadata that matches the filter or throw an error with `error.code='P2025'`
       * if no matches were found.
       * @param {TaskMasterMetadataFindUniqueOrThrowArgs} args - Arguments to find a TaskMasterMetadata
       * @example
       * // Get one TaskMasterMetadata
       * const taskMasterMetadata = await prisma.taskMasterMetadata.findUniqueOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUniqueOrThrow<T extends TaskMasterMetadataFindUniqueOrThrowArgs>(
         args: SelectSubset<T, TaskMasterMetadataFindUniqueOrThrowArgs<ExtArgs>>
      ): Prisma__TaskMasterMetadataClient<
         $Result.GetResult<
            Prisma.$TaskMasterMetadataPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first TaskMasterMetadata that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskMasterMetadataFindFirstArgs} args - Arguments to find a TaskMasterMetadata
       * @example
       * // Get one TaskMasterMetadata
       * const taskMasterMetadata = await prisma.taskMasterMetadata.findFirst({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirst<T extends TaskMasterMetadataFindFirstArgs>(
         args?: SelectSubset<T, TaskMasterMetadataFindFirstArgs<ExtArgs>>
      ): Prisma__TaskMasterMetadataClient<
         $Result.GetResult<
            Prisma.$TaskMasterMetadataPayload<ExtArgs>,
            T,
            'findFirst',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first TaskMasterMetadata that matches the filter or
       * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskMasterMetadataFindFirstOrThrowArgs} args - Arguments to find a TaskMasterMetadata
       * @example
       * // Get one TaskMasterMetadata
       * const taskMasterMetadata = await prisma.taskMasterMetadata.findFirstOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirstOrThrow<T extends TaskMasterMetadataFindFirstOrThrowArgs>(
         args?: SelectSubset<T, TaskMasterMetadataFindFirstOrThrowArgs<ExtArgs>>
      ): Prisma__TaskMasterMetadataClient<
         $Result.GetResult<
            Prisma.$TaskMasterMetadataPayload<ExtArgs>,
            T,
            'findFirstOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find zero or more TaskMasterMetadata that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskMasterMetadataFindManyArgs} args - Arguments to filter and select certain fields only.
       * @example
       * // Get all TaskMasterMetadata
       * const taskMasterMetadata = await prisma.taskMasterMetadata.findMany()
       *
       * // Get first 10 TaskMasterMetadata
       * const taskMasterMetadata = await prisma.taskMasterMetadata.findMany({ take: 10 })
       *
       * // Only select the `id`
       * const taskMasterMetadataWithIdOnly = await prisma.taskMasterMetadata.findMany({ select: { id: true } })
       *
       */
      findMany<T extends TaskMasterMetadataFindManyArgs>(
         args?: SelectSubset<T, TaskMasterMetadataFindManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$TaskMasterMetadataPayload<ExtArgs>,
            T,
            'findMany',
            GlobalOmitOptions
         >
      >;

      /**
       * Create a TaskMasterMetadata.
       * @param {TaskMasterMetadataCreateArgs} args - Arguments to create a TaskMasterMetadata.
       * @example
       * // Create one TaskMasterMetadata
       * const TaskMasterMetadata = await prisma.taskMasterMetadata.create({
       *   data: {
       *     // ... data to create a TaskMasterMetadata
       *   }
       * })
       *
       */
      create<T extends TaskMasterMetadataCreateArgs>(
         args: SelectSubset<T, TaskMasterMetadataCreateArgs<ExtArgs>>
      ): Prisma__TaskMasterMetadataClient<
         $Result.GetResult<
            Prisma.$TaskMasterMetadataPayload<ExtArgs>,
            T,
            'create',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Create many TaskMasterMetadata.
       * @param {TaskMasterMetadataCreateManyArgs} args - Arguments to create many TaskMasterMetadata.
       * @example
       * // Create many TaskMasterMetadata
       * const taskMasterMetadata = await prisma.taskMasterMetadata.createMany({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       */
      createMany<T extends TaskMasterMetadataCreateManyArgs>(
         args?: SelectSubset<T, TaskMasterMetadataCreateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Create many TaskMasterMetadata and returns the data saved in the database.
       * @param {TaskMasterMetadataCreateManyAndReturnArgs} args - Arguments to create many TaskMasterMetadata.
       * @example
       * // Create many TaskMasterMetadata
       * const taskMasterMetadata = await prisma.taskMasterMetadata.createManyAndReturn({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Create many TaskMasterMetadata and only return the `id`
       * const taskMasterMetadataWithIdOnly = await prisma.taskMasterMetadata.createManyAndReturn({
       *   select: { id: true },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      createManyAndReturn<T extends TaskMasterMetadataCreateManyAndReturnArgs>(
         args?: SelectSubset<T, TaskMasterMetadataCreateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$TaskMasterMetadataPayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Delete a TaskMasterMetadata.
       * @param {TaskMasterMetadataDeleteArgs} args - Arguments to delete one TaskMasterMetadata.
       * @example
       * // Delete one TaskMasterMetadata
       * const TaskMasterMetadata = await prisma.taskMasterMetadata.delete({
       *   where: {
       *     // ... filter to delete one TaskMasterMetadata
       *   }
       * })
       *
       */
      delete<T extends TaskMasterMetadataDeleteArgs>(
         args: SelectSubset<T, TaskMasterMetadataDeleteArgs<ExtArgs>>
      ): Prisma__TaskMasterMetadataClient<
         $Result.GetResult<
            Prisma.$TaskMasterMetadataPayload<ExtArgs>,
            T,
            'delete',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Update one TaskMasterMetadata.
       * @param {TaskMasterMetadataUpdateArgs} args - Arguments to update one TaskMasterMetadata.
       * @example
       * // Update one TaskMasterMetadata
       * const taskMasterMetadata = await prisma.taskMasterMetadata.update({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      update<T extends TaskMasterMetadataUpdateArgs>(
         args: SelectSubset<T, TaskMasterMetadataUpdateArgs<ExtArgs>>
      ): Prisma__TaskMasterMetadataClient<
         $Result.GetResult<
            Prisma.$TaskMasterMetadataPayload<ExtArgs>,
            T,
            'update',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Delete zero or more TaskMasterMetadata.
       * @param {TaskMasterMetadataDeleteManyArgs} args - Arguments to filter TaskMasterMetadata to delete.
       * @example
       * // Delete a few TaskMasterMetadata
       * const { count } = await prisma.taskMasterMetadata.deleteMany({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       *
       */
      deleteMany<T extends TaskMasterMetadataDeleteManyArgs>(
         args?: SelectSubset<T, TaskMasterMetadataDeleteManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more TaskMasterMetadata.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskMasterMetadataUpdateManyArgs} args - Arguments to update one or more rows.
       * @example
       * // Update many TaskMasterMetadata
       * const taskMasterMetadata = await prisma.taskMasterMetadata.updateMany({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      updateMany<T extends TaskMasterMetadataUpdateManyArgs>(
         args: SelectSubset<T, TaskMasterMetadataUpdateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more TaskMasterMetadata and returns the data updated in the database.
       * @param {TaskMasterMetadataUpdateManyAndReturnArgs} args - Arguments to update many TaskMasterMetadata.
       * @example
       * // Update many TaskMasterMetadata
       * const taskMasterMetadata = await prisma.taskMasterMetadata.updateManyAndReturn({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Update zero or more TaskMasterMetadata and only return the `id`
       * const taskMasterMetadataWithIdOnly = await prisma.taskMasterMetadata.updateManyAndReturn({
       *   select: { id: true },
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      updateManyAndReturn<T extends TaskMasterMetadataUpdateManyAndReturnArgs>(
         args: SelectSubset<T, TaskMasterMetadataUpdateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$TaskMasterMetadataPayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Create or update one TaskMasterMetadata.
       * @param {TaskMasterMetadataUpsertArgs} args - Arguments to update or create a TaskMasterMetadata.
       * @example
       * // Update or create a TaskMasterMetadata
       * const taskMasterMetadata = await prisma.taskMasterMetadata.upsert({
       *   create: {
       *     // ... data to create a TaskMasterMetadata
       *   },
       *   update: {
       *     // ... in case it already exists, update
       *   },
       *   where: {
       *     // ... the filter for the TaskMasterMetadata we want to update
       *   }
       * })
       */
      upsert<T extends TaskMasterMetadataUpsertArgs>(
         args: SelectSubset<T, TaskMasterMetadataUpsertArgs<ExtArgs>>
      ): Prisma__TaskMasterMetadataClient<
         $Result.GetResult<
            Prisma.$TaskMasterMetadataPayload<ExtArgs>,
            T,
            'upsert',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Count the number of TaskMasterMetadata.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskMasterMetadataCountArgs} args - Arguments to filter TaskMasterMetadata to count.
       * @example
       * // Count the number of TaskMasterMetadata
       * const count = await prisma.taskMasterMetadata.count({
       *   where: {
       *     // ... the filter for the TaskMasterMetadata we want to count
       *   }
       * })
       **/
      count<T extends TaskMasterMetadataCountArgs>(
         args?: Subset<T, TaskMasterMetadataCountArgs>
      ): Prisma.PrismaPromise<
         T extends $Utils.Record<'select', any>
            ? T['select'] extends true
               ? number
               : GetScalarType<T['select'], TaskMasterMetadataCountAggregateOutputType>
            : number
      >;

      /**
       * Allows you to perform aggregations operations on a TaskMasterMetadata.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskMasterMetadataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
       * @example
       * // Ordered by age ascending
       * // Where email contains prisma.io
       * // Limited to the 10 users
       * const aggregations = await prisma.user.aggregate({
       *   _avg: {
       *     age: true,
       *   },
       *   where: {
       *     email: {
       *       contains: "prisma.io",
       *     },
       *   },
       *   orderBy: {
       *     age: "asc",
       *   },
       *   take: 10,
       * })
       **/
      aggregate<T extends TaskMasterMetadataAggregateArgs>(
         args: Subset<T, TaskMasterMetadataAggregateArgs>
      ): Prisma.PrismaPromise<GetTaskMasterMetadataAggregateType<T>>;

      /**
       * Group by TaskMasterMetadata.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TaskMasterMetadataGroupByArgs} args - Group by arguments.
       * @example
       * // Group by city, order by createdAt, get count
       * const result = await prisma.user.groupBy({
       *   by: ['city', 'createdAt'],
       *   orderBy: {
       *     createdAt: true
       *   },
       *   _count: {
       *     _all: true
       *   },
       * })
       *
       **/
      groupBy<
         T extends TaskMasterMetadataGroupByArgs,
         HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
         OrderByArg extends True extends HasSelectOrTake
            ? { orderBy: TaskMasterMetadataGroupByArgs['orderBy'] }
            : { orderBy?: TaskMasterMetadataGroupByArgs['orderBy'] },
         OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
         ByFields extends MaybeTupleToUnion<T['by']>,
         ByValid extends Has<ByFields, OrderFields>,
         HavingFields extends GetHavingFields<T['having']>,
         HavingValid extends Has<ByFields, HavingFields>,
         ByEmpty extends T['by'] extends never[] ? True : False,
         InputErrors extends ByEmpty extends True
            ? `Error: "by" must not be empty.`
            : HavingValid extends False
              ? {
                   [P in HavingFields]: P extends ByFields
                      ? never
                      : P extends string
                        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                        : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Keys<T>
                ? 'orderBy' extends Keys<T>
                   ? ByValid extends True
                      ? {}
                      : {
                           [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                        }[OrderFields]
                   : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Keys<T>
                  ? 'orderBy' extends Keys<T>
                     ? ByValid extends True
                        ? {}
                        : {
                             [P in OrderFields]: P extends ByFields
                                ? never
                                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                     : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends True
                    ? {}
                    : {
                         [P in OrderFields]: P extends ByFields
                            ? never
                            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
      >(
         args: SubsetIntersection<T, TaskMasterMetadataGroupByArgs, OrderByArg> & InputErrors
      ): {} extends InputErrors
         ? GetTaskMasterMetadataGroupByPayload<T>
         : Prisma.PrismaPromise<InputErrors>;
      /**
       * Fields of the TaskMasterMetadata model
       */
      readonly fields: TaskMasterMetadataFieldRefs;
   }

   /**
    * The delegate class that acts as a "Promise-like" for TaskMasterMetadata.
    * Why is this prefixed with `Prisma__`?
    * Because we want to prevent naming conflicts as mentioned in
    * https://github.com/prisma/prisma-client-js/issues/707
    */
   export interface Prisma__TaskMasterMetadataClient<
      T,
      Null = never,
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > extends Prisma.PrismaPromise<T> {
      readonly [Symbol.toStringTag]: 'PrismaPromise';
      /**
       * Attaches callbacks for the resolution and/or rejection of the Promise.
       * @param onfulfilled The callback to execute when the Promise is resolved.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of which ever callback is executed.
       */
      then<TResult1 = T, TResult2 = never>(
         onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
         onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
      ): $Utils.JsPromise<TResult1 | TResult2>;
      /**
       * Attaches a callback for only the rejection of the Promise.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of the callback.
       */
      catch<TResult = never>(
         onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
      ): $Utils.JsPromise<T | TResult>;
      /**
       * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
       * resolved value cannot be modified from the callback.
       * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
       * @returns A Promise for the completion of the callback.
       */
      finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
   }

   /**
    * Fields of the TaskMasterMetadata model
    */
   interface TaskMasterMetadataFieldRefs {
      readonly id: FieldRef<'TaskMasterMetadata', 'Int'>;
      readonly created: FieldRef<'TaskMasterMetadata', 'DateTime'>;
      readonly updated: FieldRef<'TaskMasterMetadata', 'DateTime'>;
      readonly description: FieldRef<'TaskMasterMetadata', 'String'>;
   }

   // Custom InputTypes
   /**
    * TaskMasterMetadata findUnique
    */
   export type TaskMasterMetadataFindUniqueArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskMasterMetadata
       */
      select?: TaskMasterMetadataSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskMasterMetadata
       */
      omit?: TaskMasterMetadataOmit<ExtArgs> | null;
      /**
       * Filter, which TaskMasterMetadata to fetch.
       */
      where: TaskMasterMetadataWhereUniqueInput;
   };

   /**
    * TaskMasterMetadata findUniqueOrThrow
    */
   export type TaskMasterMetadataFindUniqueOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskMasterMetadata
       */
      select?: TaskMasterMetadataSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskMasterMetadata
       */
      omit?: TaskMasterMetadataOmit<ExtArgs> | null;
      /**
       * Filter, which TaskMasterMetadata to fetch.
       */
      where: TaskMasterMetadataWhereUniqueInput;
   };

   /**
    * TaskMasterMetadata findFirst
    */
   export type TaskMasterMetadataFindFirstArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskMasterMetadata
       */
      select?: TaskMasterMetadataSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskMasterMetadata
       */
      omit?: TaskMasterMetadataOmit<ExtArgs> | null;
      /**
       * Filter, which TaskMasterMetadata to fetch.
       */
      where?: TaskMasterMetadataWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of TaskMasterMetadata to fetch.
       */
      orderBy?:
         | TaskMasterMetadataOrderByWithRelationInput
         | TaskMasterMetadataOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for TaskMasterMetadata.
       */
      cursor?: TaskMasterMetadataWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` TaskMasterMetadata from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` TaskMasterMetadata.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of TaskMasterMetadata.
       */
      distinct?: TaskMasterMetadataScalarFieldEnum | TaskMasterMetadataScalarFieldEnum[];
   };

   /**
    * TaskMasterMetadata findFirstOrThrow
    */
   export type TaskMasterMetadataFindFirstOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskMasterMetadata
       */
      select?: TaskMasterMetadataSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskMasterMetadata
       */
      omit?: TaskMasterMetadataOmit<ExtArgs> | null;
      /**
       * Filter, which TaskMasterMetadata to fetch.
       */
      where?: TaskMasterMetadataWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of TaskMasterMetadata to fetch.
       */
      orderBy?:
         | TaskMasterMetadataOrderByWithRelationInput
         | TaskMasterMetadataOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for TaskMasterMetadata.
       */
      cursor?: TaskMasterMetadataWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` TaskMasterMetadata from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` TaskMasterMetadata.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of TaskMasterMetadata.
       */
      distinct?: TaskMasterMetadataScalarFieldEnum | TaskMasterMetadataScalarFieldEnum[];
   };

   /**
    * TaskMasterMetadata findMany
    */
   export type TaskMasterMetadataFindManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskMasterMetadata
       */
      select?: TaskMasterMetadataSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskMasterMetadata
       */
      omit?: TaskMasterMetadataOmit<ExtArgs> | null;
      /**
       * Filter, which TaskMasterMetadata to fetch.
       */
      where?: TaskMasterMetadataWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of TaskMasterMetadata to fetch.
       */
      orderBy?:
         | TaskMasterMetadataOrderByWithRelationInput
         | TaskMasterMetadataOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing TaskMasterMetadata.
       */
      cursor?: TaskMasterMetadataWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` TaskMasterMetadata from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` TaskMasterMetadata.
       */
      skip?: number;
      distinct?: TaskMasterMetadataScalarFieldEnum | TaskMasterMetadataScalarFieldEnum[];
   };

   /**
    * TaskMasterMetadata create
    */
   export type TaskMasterMetadataCreateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskMasterMetadata
       */
      select?: TaskMasterMetadataSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskMasterMetadata
       */
      omit?: TaskMasterMetadataOmit<ExtArgs> | null;
      /**
       * The data needed to create a TaskMasterMetadata.
       */
      data: XOR<TaskMasterMetadataCreateInput, TaskMasterMetadataUncheckedCreateInput>;
   };

   /**
    * TaskMasterMetadata createMany
    */
   export type TaskMasterMetadataCreateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to create many TaskMasterMetadata.
       */
      data: TaskMasterMetadataCreateManyInput | TaskMasterMetadataCreateManyInput[];
   };

   /**
    * TaskMasterMetadata createManyAndReturn
    */
   export type TaskMasterMetadataCreateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskMasterMetadata
       */
      select?: TaskMasterMetadataSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskMasterMetadata
       */
      omit?: TaskMasterMetadataOmit<ExtArgs> | null;
      /**
       * The data used to create many TaskMasterMetadata.
       */
      data: TaskMasterMetadataCreateManyInput | TaskMasterMetadataCreateManyInput[];
   };

   /**
    * TaskMasterMetadata update
    */
   export type TaskMasterMetadataUpdateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskMasterMetadata
       */
      select?: TaskMasterMetadataSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskMasterMetadata
       */
      omit?: TaskMasterMetadataOmit<ExtArgs> | null;
      /**
       * The data needed to update a TaskMasterMetadata.
       */
      data: XOR<TaskMasterMetadataUpdateInput, TaskMasterMetadataUncheckedUpdateInput>;
      /**
       * Choose, which TaskMasterMetadata to update.
       */
      where: TaskMasterMetadataWhereUniqueInput;
   };

   /**
    * TaskMasterMetadata updateMany
    */
   export type TaskMasterMetadataUpdateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to update TaskMasterMetadata.
       */
      data: XOR<
         TaskMasterMetadataUpdateManyMutationInput,
         TaskMasterMetadataUncheckedUpdateManyInput
      >;
      /**
       * Filter which TaskMasterMetadata to update
       */
      where?: TaskMasterMetadataWhereInput;
      /**
       * Limit how many TaskMasterMetadata to update.
       */
      limit?: number;
   };

   /**
    * TaskMasterMetadata updateManyAndReturn
    */
   export type TaskMasterMetadataUpdateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskMasterMetadata
       */
      select?: TaskMasterMetadataSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskMasterMetadata
       */
      omit?: TaskMasterMetadataOmit<ExtArgs> | null;
      /**
       * The data used to update TaskMasterMetadata.
       */
      data: XOR<
         TaskMasterMetadataUpdateManyMutationInput,
         TaskMasterMetadataUncheckedUpdateManyInput
      >;
      /**
       * Filter which TaskMasterMetadata to update
       */
      where?: TaskMasterMetadataWhereInput;
      /**
       * Limit how many TaskMasterMetadata to update.
       */
      limit?: number;
   };

   /**
    * TaskMasterMetadata upsert
    */
   export type TaskMasterMetadataUpsertArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskMasterMetadata
       */
      select?: TaskMasterMetadataSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskMasterMetadata
       */
      omit?: TaskMasterMetadataOmit<ExtArgs> | null;
      /**
       * The filter to search for the TaskMasterMetadata to update in case it exists.
       */
      where: TaskMasterMetadataWhereUniqueInput;
      /**
       * In case the TaskMasterMetadata found by the `where` argument doesn't exist, create a new TaskMasterMetadata with this data.
       */
      create: XOR<TaskMasterMetadataCreateInput, TaskMasterMetadataUncheckedCreateInput>;
      /**
       * In case the TaskMasterMetadata was found with the provided `where` argument, update it with this data.
       */
      update: XOR<TaskMasterMetadataUpdateInput, TaskMasterMetadataUncheckedUpdateInput>;
   };

   /**
    * TaskMasterMetadata delete
    */
   export type TaskMasterMetadataDeleteArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskMasterMetadata
       */
      select?: TaskMasterMetadataSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskMasterMetadata
       */
      omit?: TaskMasterMetadataOmit<ExtArgs> | null;
      /**
       * Filter which TaskMasterMetadata to delete.
       */
      where: TaskMasterMetadataWhereUniqueInput;
   };

   /**
    * TaskMasterMetadata deleteMany
    */
   export type TaskMasterMetadataDeleteManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which TaskMasterMetadata to delete
       */
      where?: TaskMasterMetadataWhereInput;
      /**
       * Limit how many TaskMasterMetadata to delete.
       */
      limit?: number;
   };

   /**
    * TaskMasterMetadata without action
    */
   export type TaskMasterMetadataDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TaskMasterMetadata
       */
      select?: TaskMasterMetadataSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TaskMasterMetadata
       */
      omit?: TaskMasterMetadataOmit<ExtArgs> | null;
   };

   /**
    * Model SyncOperation
    */

   export type AggregateSyncOperation = {
      _count: SyncOperationCountAggregateOutputType | null;
      _avg: SyncOperationAvgAggregateOutputType | null;
      _sum: SyncOperationSumAggregateOutputType | null;
      _min: SyncOperationMinAggregateOutputType | null;
      _max: SyncOperationMaxAggregateOutputType | null;
   };

   export type SyncOperationAvgAggregateOutputType = {
      retryCount: number | null;
      maxRetries: number | null;
   };

   export type SyncOperationSumAggregateOutputType = {
      retryCount: number | null;
      maxRetries: number | null;
   };

   export type SyncOperationMinAggregateOutputType = {
      id: string | null;
      type: string | null;
      status: string | null;
      source: string | null;
      timestamp: Date | null;
      completedAt: Date | null;
      data: string | null;
      rollbackData: string | null;
      metadata: string | null;
      retryCount: number | null;
      maxRetries: number | null;
      error: string | null;
      taskIds: string | null;
   };

   export type SyncOperationMaxAggregateOutputType = {
      id: string | null;
      type: string | null;
      status: string | null;
      source: string | null;
      timestamp: Date | null;
      completedAt: Date | null;
      data: string | null;
      rollbackData: string | null;
      metadata: string | null;
      retryCount: number | null;
      maxRetries: number | null;
      error: string | null;
      taskIds: string | null;
   };

   export type SyncOperationCountAggregateOutputType = {
      id: number;
      type: number;
      status: number;
      source: number;
      timestamp: number;
      completedAt: number;
      data: number;
      rollbackData: number;
      metadata: number;
      retryCount: number;
      maxRetries: number;
      error: number;
      taskIds: number;
      _all: number;
   };

   export type SyncOperationAvgAggregateInputType = {
      retryCount?: true;
      maxRetries?: true;
   };

   export type SyncOperationSumAggregateInputType = {
      retryCount?: true;
      maxRetries?: true;
   };

   export type SyncOperationMinAggregateInputType = {
      id?: true;
      type?: true;
      status?: true;
      source?: true;
      timestamp?: true;
      completedAt?: true;
      data?: true;
      rollbackData?: true;
      metadata?: true;
      retryCount?: true;
      maxRetries?: true;
      error?: true;
      taskIds?: true;
   };

   export type SyncOperationMaxAggregateInputType = {
      id?: true;
      type?: true;
      status?: true;
      source?: true;
      timestamp?: true;
      completedAt?: true;
      data?: true;
      rollbackData?: true;
      metadata?: true;
      retryCount?: true;
      maxRetries?: true;
      error?: true;
      taskIds?: true;
   };

   export type SyncOperationCountAggregateInputType = {
      id?: true;
      type?: true;
      status?: true;
      source?: true;
      timestamp?: true;
      completedAt?: true;
      data?: true;
      rollbackData?: true;
      metadata?: true;
      retryCount?: true;
      maxRetries?: true;
      error?: true;
      taskIds?: true;
      _all?: true;
   };

   export type SyncOperationAggregateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which SyncOperation to aggregate.
       */
      where?: SyncOperationWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of SyncOperations to fetch.
       */
      orderBy?: SyncOperationOrderByWithRelationInput | SyncOperationOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: SyncOperationWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` SyncOperations from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` SyncOperations.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned SyncOperations
       **/
      _count?: true | SyncOperationCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to average
       **/
      _avg?: SyncOperationAvgAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to sum
       **/
      _sum?: SyncOperationSumAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: SyncOperationMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: SyncOperationMaxAggregateInputType;
   };

   export type GetSyncOperationAggregateType<T extends SyncOperationAggregateArgs> = {
      [P in keyof T & keyof AggregateSyncOperation]: P extends '_count' | 'count'
         ? T[P] extends true
            ? number
            : GetScalarType<T[P], AggregateSyncOperation[P]>
         : GetScalarType<T[P], AggregateSyncOperation[P]>;
   };

   export type SyncOperationGroupByArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: SyncOperationWhereInput;
      orderBy?:
         | SyncOperationOrderByWithAggregationInput
         | SyncOperationOrderByWithAggregationInput[];
      by: SyncOperationScalarFieldEnum[] | SyncOperationScalarFieldEnum;
      having?: SyncOperationScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: SyncOperationCountAggregateInputType | true;
      _avg?: SyncOperationAvgAggregateInputType;
      _sum?: SyncOperationSumAggregateInputType;
      _min?: SyncOperationMinAggregateInputType;
      _max?: SyncOperationMaxAggregateInputType;
   };

   export type SyncOperationGroupByOutputType = {
      id: string;
      type: string;
      status: string;
      source: string;
      timestamp: Date;
      completedAt: Date | null;
      data: string;
      rollbackData: string | null;
      metadata: string | null;
      retryCount: number;
      maxRetries: number;
      error: string | null;
      taskIds: string;
      _count: SyncOperationCountAggregateOutputType | null;
      _avg: SyncOperationAvgAggregateOutputType | null;
      _sum: SyncOperationSumAggregateOutputType | null;
      _min: SyncOperationMinAggregateOutputType | null;
      _max: SyncOperationMaxAggregateOutputType | null;
   };

   type GetSyncOperationGroupByPayload<T extends SyncOperationGroupByArgs> = Prisma.PrismaPromise<
      Array<
         PickEnumerable<SyncOperationGroupByOutputType, T['by']> & {
            [P in keyof T & keyof SyncOperationGroupByOutputType]: P extends '_count'
               ? T[P] extends boolean
                  ? number
                  : GetScalarType<T[P], SyncOperationGroupByOutputType[P]>
               : GetScalarType<T[P], SyncOperationGroupByOutputType[P]>;
         }
      >
   >;

   export type SyncOperationSelect<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         type?: boolean;
         status?: boolean;
         source?: boolean;
         timestamp?: boolean;
         completedAt?: boolean;
         data?: boolean;
         rollbackData?: boolean;
         metadata?: boolean;
         retryCount?: boolean;
         maxRetries?: boolean;
         error?: boolean;
         taskIds?: boolean;
      },
      ExtArgs['result']['syncOperation']
   >;

   export type SyncOperationSelectCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         type?: boolean;
         status?: boolean;
         source?: boolean;
         timestamp?: boolean;
         completedAt?: boolean;
         data?: boolean;
         rollbackData?: boolean;
         metadata?: boolean;
         retryCount?: boolean;
         maxRetries?: boolean;
         error?: boolean;
         taskIds?: boolean;
      },
      ExtArgs['result']['syncOperation']
   >;

   export type SyncOperationSelectUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         type?: boolean;
         status?: boolean;
         source?: boolean;
         timestamp?: boolean;
         completedAt?: boolean;
         data?: boolean;
         rollbackData?: boolean;
         metadata?: boolean;
         retryCount?: boolean;
         maxRetries?: boolean;
         error?: boolean;
         taskIds?: boolean;
      },
      ExtArgs['result']['syncOperation']
   >;

   export type SyncOperationSelectScalar = {
      id?: boolean;
      type?: boolean;
      status?: boolean;
      source?: boolean;
      timestamp?: boolean;
      completedAt?: boolean;
      data?: boolean;
      rollbackData?: boolean;
      metadata?: boolean;
      retryCount?: boolean;
      maxRetries?: boolean;
      error?: boolean;
      taskIds?: boolean;
   };

   export type SyncOperationOmit<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetOmit<
      | 'id'
      | 'type'
      | 'status'
      | 'source'
      | 'timestamp'
      | 'completedAt'
      | 'data'
      | 'rollbackData'
      | 'metadata'
      | 'retryCount'
      | 'maxRetries'
      | 'error'
      | 'taskIds',
      ExtArgs['result']['syncOperation']
   >;

   export type $SyncOperationPayload<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      name: 'SyncOperation';
      objects: {};
      scalars: $Extensions.GetPayloadResult<
         {
            id: string;
            type: string;
            status: string;
            source: string;
            timestamp: Date;
            completedAt: Date | null;
            data: string;
            rollbackData: string | null;
            metadata: string | null;
            retryCount: number;
            maxRetries: number;
            error: string | null;
            taskIds: string;
         },
         ExtArgs['result']['syncOperation']
      >;
      composites: {};
   };

   type SyncOperationGetPayload<S extends boolean | null | undefined | SyncOperationDefaultArgs> =
      $Result.GetResult<Prisma.$SyncOperationPayload, S>;

   type SyncOperationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      Omit<SyncOperationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
         select?: SyncOperationCountAggregateInputType | true;
      };

   export interface SyncOperationDelegate<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > {
      [K: symbol]: {
         types: Prisma.TypeMap<ExtArgs>['model']['SyncOperation'];
         meta: { name: 'SyncOperation' };
      };
      /**
       * Find zero or one SyncOperation that matches the filter.
       * @param {SyncOperationFindUniqueArgs} args - Arguments to find a SyncOperation
       * @example
       * // Get one SyncOperation
       * const syncOperation = await prisma.syncOperation.findUnique({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUnique<T extends SyncOperationFindUniqueArgs>(
         args: SelectSubset<T, SyncOperationFindUniqueArgs<ExtArgs>>
      ): Prisma__SyncOperationClient<
         $Result.GetResult<
            Prisma.$SyncOperationPayload<ExtArgs>,
            T,
            'findUnique',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find one SyncOperation that matches the filter or throw an error with `error.code='P2025'`
       * if no matches were found.
       * @param {SyncOperationFindUniqueOrThrowArgs} args - Arguments to find a SyncOperation
       * @example
       * // Get one SyncOperation
       * const syncOperation = await prisma.syncOperation.findUniqueOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUniqueOrThrow<T extends SyncOperationFindUniqueOrThrowArgs>(
         args: SelectSubset<T, SyncOperationFindUniqueOrThrowArgs<ExtArgs>>
      ): Prisma__SyncOperationClient<
         $Result.GetResult<
            Prisma.$SyncOperationPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first SyncOperation that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SyncOperationFindFirstArgs} args - Arguments to find a SyncOperation
       * @example
       * // Get one SyncOperation
       * const syncOperation = await prisma.syncOperation.findFirst({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirst<T extends SyncOperationFindFirstArgs>(
         args?: SelectSubset<T, SyncOperationFindFirstArgs<ExtArgs>>
      ): Prisma__SyncOperationClient<
         $Result.GetResult<
            Prisma.$SyncOperationPayload<ExtArgs>,
            T,
            'findFirst',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first SyncOperation that matches the filter or
       * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SyncOperationFindFirstOrThrowArgs} args - Arguments to find a SyncOperation
       * @example
       * // Get one SyncOperation
       * const syncOperation = await prisma.syncOperation.findFirstOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirstOrThrow<T extends SyncOperationFindFirstOrThrowArgs>(
         args?: SelectSubset<T, SyncOperationFindFirstOrThrowArgs<ExtArgs>>
      ): Prisma__SyncOperationClient<
         $Result.GetResult<
            Prisma.$SyncOperationPayload<ExtArgs>,
            T,
            'findFirstOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find zero or more SyncOperations that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SyncOperationFindManyArgs} args - Arguments to filter and select certain fields only.
       * @example
       * // Get all SyncOperations
       * const syncOperations = await prisma.syncOperation.findMany()
       *
       * // Get first 10 SyncOperations
       * const syncOperations = await prisma.syncOperation.findMany({ take: 10 })
       *
       * // Only select the `id`
       * const syncOperationWithIdOnly = await prisma.syncOperation.findMany({ select: { id: true } })
       *
       */
      findMany<T extends SyncOperationFindManyArgs>(
         args?: SelectSubset<T, SyncOperationFindManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$SyncOperationPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      >;

      /**
       * Create a SyncOperation.
       * @param {SyncOperationCreateArgs} args - Arguments to create a SyncOperation.
       * @example
       * // Create one SyncOperation
       * const SyncOperation = await prisma.syncOperation.create({
       *   data: {
       *     // ... data to create a SyncOperation
       *   }
       * })
       *
       */
      create<T extends SyncOperationCreateArgs>(
         args: SelectSubset<T, SyncOperationCreateArgs<ExtArgs>>
      ): Prisma__SyncOperationClient<
         $Result.GetResult<Prisma.$SyncOperationPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Create many SyncOperations.
       * @param {SyncOperationCreateManyArgs} args - Arguments to create many SyncOperations.
       * @example
       * // Create many SyncOperations
       * const syncOperation = await prisma.syncOperation.createMany({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       */
      createMany<T extends SyncOperationCreateManyArgs>(
         args?: SelectSubset<T, SyncOperationCreateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Create many SyncOperations and returns the data saved in the database.
       * @param {SyncOperationCreateManyAndReturnArgs} args - Arguments to create many SyncOperations.
       * @example
       * // Create many SyncOperations
       * const syncOperation = await prisma.syncOperation.createManyAndReturn({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Create many SyncOperations and only return the `id`
       * const syncOperationWithIdOnly = await prisma.syncOperation.createManyAndReturn({
       *   select: { id: true },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      createManyAndReturn<T extends SyncOperationCreateManyAndReturnArgs>(
         args?: SelectSubset<T, SyncOperationCreateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$SyncOperationPayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Delete a SyncOperation.
       * @param {SyncOperationDeleteArgs} args - Arguments to delete one SyncOperation.
       * @example
       * // Delete one SyncOperation
       * const SyncOperation = await prisma.syncOperation.delete({
       *   where: {
       *     // ... filter to delete one SyncOperation
       *   }
       * })
       *
       */
      delete<T extends SyncOperationDeleteArgs>(
         args: SelectSubset<T, SyncOperationDeleteArgs<ExtArgs>>
      ): Prisma__SyncOperationClient<
         $Result.GetResult<Prisma.$SyncOperationPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Update one SyncOperation.
       * @param {SyncOperationUpdateArgs} args - Arguments to update one SyncOperation.
       * @example
       * // Update one SyncOperation
       * const syncOperation = await prisma.syncOperation.update({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      update<T extends SyncOperationUpdateArgs>(
         args: SelectSubset<T, SyncOperationUpdateArgs<ExtArgs>>
      ): Prisma__SyncOperationClient<
         $Result.GetResult<Prisma.$SyncOperationPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Delete zero or more SyncOperations.
       * @param {SyncOperationDeleteManyArgs} args - Arguments to filter SyncOperations to delete.
       * @example
       * // Delete a few SyncOperations
       * const { count } = await prisma.syncOperation.deleteMany({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       *
       */
      deleteMany<T extends SyncOperationDeleteManyArgs>(
         args?: SelectSubset<T, SyncOperationDeleteManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more SyncOperations.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SyncOperationUpdateManyArgs} args - Arguments to update one or more rows.
       * @example
       * // Update many SyncOperations
       * const syncOperation = await prisma.syncOperation.updateMany({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      updateMany<T extends SyncOperationUpdateManyArgs>(
         args: SelectSubset<T, SyncOperationUpdateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more SyncOperations and returns the data updated in the database.
       * @param {SyncOperationUpdateManyAndReturnArgs} args - Arguments to update many SyncOperations.
       * @example
       * // Update many SyncOperations
       * const syncOperation = await prisma.syncOperation.updateManyAndReturn({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Update zero or more SyncOperations and only return the `id`
       * const syncOperationWithIdOnly = await prisma.syncOperation.updateManyAndReturn({
       *   select: { id: true },
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      updateManyAndReturn<T extends SyncOperationUpdateManyAndReturnArgs>(
         args: SelectSubset<T, SyncOperationUpdateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$SyncOperationPayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Create or update one SyncOperation.
       * @param {SyncOperationUpsertArgs} args - Arguments to update or create a SyncOperation.
       * @example
       * // Update or create a SyncOperation
       * const syncOperation = await prisma.syncOperation.upsert({
       *   create: {
       *     // ... data to create a SyncOperation
       *   },
       *   update: {
       *     // ... in case it already exists, update
       *   },
       *   where: {
       *     // ... the filter for the SyncOperation we want to update
       *   }
       * })
       */
      upsert<T extends SyncOperationUpsertArgs>(
         args: SelectSubset<T, SyncOperationUpsertArgs<ExtArgs>>
      ): Prisma__SyncOperationClient<
         $Result.GetResult<Prisma.$SyncOperationPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Count the number of SyncOperations.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SyncOperationCountArgs} args - Arguments to filter SyncOperations to count.
       * @example
       * // Count the number of SyncOperations
       * const count = await prisma.syncOperation.count({
       *   where: {
       *     // ... the filter for the SyncOperations we want to count
       *   }
       * })
       **/
      count<T extends SyncOperationCountArgs>(
         args?: Subset<T, SyncOperationCountArgs>
      ): Prisma.PrismaPromise<
         T extends $Utils.Record<'select', any>
            ? T['select'] extends true
               ? number
               : GetScalarType<T['select'], SyncOperationCountAggregateOutputType>
            : number
      >;

      /**
       * Allows you to perform aggregations operations on a SyncOperation.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SyncOperationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
       * @example
       * // Ordered by age ascending
       * // Where email contains prisma.io
       * // Limited to the 10 users
       * const aggregations = await prisma.user.aggregate({
       *   _avg: {
       *     age: true,
       *   },
       *   where: {
       *     email: {
       *       contains: "prisma.io",
       *     },
       *   },
       *   orderBy: {
       *     age: "asc",
       *   },
       *   take: 10,
       * })
       **/
      aggregate<T extends SyncOperationAggregateArgs>(
         args: Subset<T, SyncOperationAggregateArgs>
      ): Prisma.PrismaPromise<GetSyncOperationAggregateType<T>>;

      /**
       * Group by SyncOperation.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SyncOperationGroupByArgs} args - Group by arguments.
       * @example
       * // Group by city, order by createdAt, get count
       * const result = await prisma.user.groupBy({
       *   by: ['city', 'createdAt'],
       *   orderBy: {
       *     createdAt: true
       *   },
       *   _count: {
       *     _all: true
       *   },
       * })
       *
       **/
      groupBy<
         T extends SyncOperationGroupByArgs,
         HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
         OrderByArg extends True extends HasSelectOrTake
            ? { orderBy: SyncOperationGroupByArgs['orderBy'] }
            : { orderBy?: SyncOperationGroupByArgs['orderBy'] },
         OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
         ByFields extends MaybeTupleToUnion<T['by']>,
         ByValid extends Has<ByFields, OrderFields>,
         HavingFields extends GetHavingFields<T['having']>,
         HavingValid extends Has<ByFields, HavingFields>,
         ByEmpty extends T['by'] extends never[] ? True : False,
         InputErrors extends ByEmpty extends True
            ? `Error: "by" must not be empty.`
            : HavingValid extends False
              ? {
                   [P in HavingFields]: P extends ByFields
                      ? never
                      : P extends string
                        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                        : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Keys<T>
                ? 'orderBy' extends Keys<T>
                   ? ByValid extends True
                      ? {}
                      : {
                           [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                        }[OrderFields]
                   : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Keys<T>
                  ? 'orderBy' extends Keys<T>
                     ? ByValid extends True
                        ? {}
                        : {
                             [P in OrderFields]: P extends ByFields
                                ? never
                                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                     : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends True
                    ? {}
                    : {
                         [P in OrderFields]: P extends ByFields
                            ? never
                            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
      >(
         args: SubsetIntersection<T, SyncOperationGroupByArgs, OrderByArg> & InputErrors
      ): {} extends InputErrors
         ? GetSyncOperationGroupByPayload<T>
         : Prisma.PrismaPromise<InputErrors>;
      /**
       * Fields of the SyncOperation model
       */
      readonly fields: SyncOperationFieldRefs;
   }

   /**
    * The delegate class that acts as a "Promise-like" for SyncOperation.
    * Why is this prefixed with `Prisma__`?
    * Because we want to prevent naming conflicts as mentioned in
    * https://github.com/prisma/prisma-client-js/issues/707
    */
   export interface Prisma__SyncOperationClient<
      T,
      Null = never,
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > extends Prisma.PrismaPromise<T> {
      readonly [Symbol.toStringTag]: 'PrismaPromise';
      /**
       * Attaches callbacks for the resolution and/or rejection of the Promise.
       * @param onfulfilled The callback to execute when the Promise is resolved.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of which ever callback is executed.
       */
      then<TResult1 = T, TResult2 = never>(
         onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
         onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
      ): $Utils.JsPromise<TResult1 | TResult2>;
      /**
       * Attaches a callback for only the rejection of the Promise.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of the callback.
       */
      catch<TResult = never>(
         onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
      ): $Utils.JsPromise<T | TResult>;
      /**
       * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
       * resolved value cannot be modified from the callback.
       * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
       * @returns A Promise for the completion of the callback.
       */
      finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
   }

   /**
    * Fields of the SyncOperation model
    */
   interface SyncOperationFieldRefs {
      readonly id: FieldRef<'SyncOperation', 'String'>;
      readonly type: FieldRef<'SyncOperation', 'String'>;
      readonly status: FieldRef<'SyncOperation', 'String'>;
      readonly source: FieldRef<'SyncOperation', 'String'>;
      readonly timestamp: FieldRef<'SyncOperation', 'DateTime'>;
      readonly completedAt: FieldRef<'SyncOperation', 'DateTime'>;
      readonly data: FieldRef<'SyncOperation', 'String'>;
      readonly rollbackData: FieldRef<'SyncOperation', 'String'>;
      readonly metadata: FieldRef<'SyncOperation', 'String'>;
      readonly retryCount: FieldRef<'SyncOperation', 'Int'>;
      readonly maxRetries: FieldRef<'SyncOperation', 'Int'>;
      readonly error: FieldRef<'SyncOperation', 'String'>;
      readonly taskIds: FieldRef<'SyncOperation', 'String'>;
   }

   // Custom InputTypes
   /**
    * SyncOperation findUnique
    */
   export type SyncOperationFindUniqueArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncOperation
       */
      select?: SyncOperationSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncOperation
       */
      omit?: SyncOperationOmit<ExtArgs> | null;
      /**
       * Filter, which SyncOperation to fetch.
       */
      where: SyncOperationWhereUniqueInput;
   };

   /**
    * SyncOperation findUniqueOrThrow
    */
   export type SyncOperationFindUniqueOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncOperation
       */
      select?: SyncOperationSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncOperation
       */
      omit?: SyncOperationOmit<ExtArgs> | null;
      /**
       * Filter, which SyncOperation to fetch.
       */
      where: SyncOperationWhereUniqueInput;
   };

   /**
    * SyncOperation findFirst
    */
   export type SyncOperationFindFirstArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncOperation
       */
      select?: SyncOperationSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncOperation
       */
      omit?: SyncOperationOmit<ExtArgs> | null;
      /**
       * Filter, which SyncOperation to fetch.
       */
      where?: SyncOperationWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of SyncOperations to fetch.
       */
      orderBy?: SyncOperationOrderByWithRelationInput | SyncOperationOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for SyncOperations.
       */
      cursor?: SyncOperationWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` SyncOperations from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` SyncOperations.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of SyncOperations.
       */
      distinct?: SyncOperationScalarFieldEnum | SyncOperationScalarFieldEnum[];
   };

   /**
    * SyncOperation findFirstOrThrow
    */
   export type SyncOperationFindFirstOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncOperation
       */
      select?: SyncOperationSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncOperation
       */
      omit?: SyncOperationOmit<ExtArgs> | null;
      /**
       * Filter, which SyncOperation to fetch.
       */
      where?: SyncOperationWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of SyncOperations to fetch.
       */
      orderBy?: SyncOperationOrderByWithRelationInput | SyncOperationOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for SyncOperations.
       */
      cursor?: SyncOperationWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` SyncOperations from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` SyncOperations.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of SyncOperations.
       */
      distinct?: SyncOperationScalarFieldEnum | SyncOperationScalarFieldEnum[];
   };

   /**
    * SyncOperation findMany
    */
   export type SyncOperationFindManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncOperation
       */
      select?: SyncOperationSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncOperation
       */
      omit?: SyncOperationOmit<ExtArgs> | null;
      /**
       * Filter, which SyncOperations to fetch.
       */
      where?: SyncOperationWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of SyncOperations to fetch.
       */
      orderBy?: SyncOperationOrderByWithRelationInput | SyncOperationOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing SyncOperations.
       */
      cursor?: SyncOperationWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` SyncOperations from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` SyncOperations.
       */
      skip?: number;
      distinct?: SyncOperationScalarFieldEnum | SyncOperationScalarFieldEnum[];
   };

   /**
    * SyncOperation create
    */
   export type SyncOperationCreateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncOperation
       */
      select?: SyncOperationSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncOperation
       */
      omit?: SyncOperationOmit<ExtArgs> | null;
      /**
       * The data needed to create a SyncOperation.
       */
      data: XOR<SyncOperationCreateInput, SyncOperationUncheckedCreateInput>;
   };

   /**
    * SyncOperation createMany
    */
   export type SyncOperationCreateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to create many SyncOperations.
       */
      data: SyncOperationCreateManyInput | SyncOperationCreateManyInput[];
   };

   /**
    * SyncOperation createManyAndReturn
    */
   export type SyncOperationCreateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncOperation
       */
      select?: SyncOperationSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncOperation
       */
      omit?: SyncOperationOmit<ExtArgs> | null;
      /**
       * The data used to create many SyncOperations.
       */
      data: SyncOperationCreateManyInput | SyncOperationCreateManyInput[];
   };

   /**
    * SyncOperation update
    */
   export type SyncOperationUpdateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncOperation
       */
      select?: SyncOperationSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncOperation
       */
      omit?: SyncOperationOmit<ExtArgs> | null;
      /**
       * The data needed to update a SyncOperation.
       */
      data: XOR<SyncOperationUpdateInput, SyncOperationUncheckedUpdateInput>;
      /**
       * Choose, which SyncOperation to update.
       */
      where: SyncOperationWhereUniqueInput;
   };

   /**
    * SyncOperation updateMany
    */
   export type SyncOperationUpdateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to update SyncOperations.
       */
      data: XOR<SyncOperationUpdateManyMutationInput, SyncOperationUncheckedUpdateManyInput>;
      /**
       * Filter which SyncOperations to update
       */
      where?: SyncOperationWhereInput;
      /**
       * Limit how many SyncOperations to update.
       */
      limit?: number;
   };

   /**
    * SyncOperation updateManyAndReturn
    */
   export type SyncOperationUpdateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncOperation
       */
      select?: SyncOperationSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncOperation
       */
      omit?: SyncOperationOmit<ExtArgs> | null;
      /**
       * The data used to update SyncOperations.
       */
      data: XOR<SyncOperationUpdateManyMutationInput, SyncOperationUncheckedUpdateManyInput>;
      /**
       * Filter which SyncOperations to update
       */
      where?: SyncOperationWhereInput;
      /**
       * Limit how many SyncOperations to update.
       */
      limit?: number;
   };

   /**
    * SyncOperation upsert
    */
   export type SyncOperationUpsertArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncOperation
       */
      select?: SyncOperationSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncOperation
       */
      omit?: SyncOperationOmit<ExtArgs> | null;
      /**
       * The filter to search for the SyncOperation to update in case it exists.
       */
      where: SyncOperationWhereUniqueInput;
      /**
       * In case the SyncOperation found by the `where` argument doesn't exist, create a new SyncOperation with this data.
       */
      create: XOR<SyncOperationCreateInput, SyncOperationUncheckedCreateInput>;
      /**
       * In case the SyncOperation was found with the provided `where` argument, update it with this data.
       */
      update: XOR<SyncOperationUpdateInput, SyncOperationUncheckedUpdateInput>;
   };

   /**
    * SyncOperation delete
    */
   export type SyncOperationDeleteArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncOperation
       */
      select?: SyncOperationSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncOperation
       */
      omit?: SyncOperationOmit<ExtArgs> | null;
      /**
       * Filter which SyncOperation to delete.
       */
      where: SyncOperationWhereUniqueInput;
   };

   /**
    * SyncOperation deleteMany
    */
   export type SyncOperationDeleteManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which SyncOperations to delete
       */
      where?: SyncOperationWhereInput;
      /**
       * Limit how many SyncOperations to delete.
       */
      limit?: number;
   };

   /**
    * SyncOperation without action
    */
   export type SyncOperationDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncOperation
       */
      select?: SyncOperationSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncOperation
       */
      omit?: SyncOperationOmit<ExtArgs> | null;
   };

   /**
    * Model SyncConflict
    */

   export type AggregateSyncConflict = {
      _count: SyncConflictCountAggregateOutputType | null;
      _min: SyncConflictMinAggregateOutputType | null;
      _max: SyncConflictMaxAggregateOutputType | null;
   };

   export type SyncConflictMinAggregateOutputType = {
      id: string | null;
      operationType: string | null;
      taskId: string | null;
      uiVersion: string | null;
      cliVersion: string | null;
      resolved: boolean | null;
      resolution: string | null;
      resolvedAt: Date | null;
      resolvedBy: string | null;
      timestamp: Date | null;
   };

   export type SyncConflictMaxAggregateOutputType = {
      id: string | null;
      operationType: string | null;
      taskId: string | null;
      uiVersion: string | null;
      cliVersion: string | null;
      resolved: boolean | null;
      resolution: string | null;
      resolvedAt: Date | null;
      resolvedBy: string | null;
      timestamp: Date | null;
   };

   export type SyncConflictCountAggregateOutputType = {
      id: number;
      operationType: number;
      taskId: number;
      uiVersion: number;
      cliVersion: number;
      resolved: number;
      resolution: number;
      resolvedAt: number;
      resolvedBy: number;
      timestamp: number;
      _all: number;
   };

   export type SyncConflictMinAggregateInputType = {
      id?: true;
      operationType?: true;
      taskId?: true;
      uiVersion?: true;
      cliVersion?: true;
      resolved?: true;
      resolution?: true;
      resolvedAt?: true;
      resolvedBy?: true;
      timestamp?: true;
   };

   export type SyncConflictMaxAggregateInputType = {
      id?: true;
      operationType?: true;
      taskId?: true;
      uiVersion?: true;
      cliVersion?: true;
      resolved?: true;
      resolution?: true;
      resolvedAt?: true;
      resolvedBy?: true;
      timestamp?: true;
   };

   export type SyncConflictCountAggregateInputType = {
      id?: true;
      operationType?: true;
      taskId?: true;
      uiVersion?: true;
      cliVersion?: true;
      resolved?: true;
      resolution?: true;
      resolvedAt?: true;
      resolvedBy?: true;
      timestamp?: true;
      _all?: true;
   };

   export type SyncConflictAggregateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which SyncConflict to aggregate.
       */
      where?: SyncConflictWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of SyncConflicts to fetch.
       */
      orderBy?: SyncConflictOrderByWithRelationInput | SyncConflictOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: SyncConflictWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` SyncConflicts from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` SyncConflicts.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned SyncConflicts
       **/
      _count?: true | SyncConflictCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: SyncConflictMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: SyncConflictMaxAggregateInputType;
   };

   export type GetSyncConflictAggregateType<T extends SyncConflictAggregateArgs> = {
      [P in keyof T & keyof AggregateSyncConflict]: P extends '_count' | 'count'
         ? T[P] extends true
            ? number
            : GetScalarType<T[P], AggregateSyncConflict[P]>
         : GetScalarType<T[P], AggregateSyncConflict[P]>;
   };

   export type SyncConflictGroupByArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: SyncConflictWhereInput;
      orderBy?: SyncConflictOrderByWithAggregationInput | SyncConflictOrderByWithAggregationInput[];
      by: SyncConflictScalarFieldEnum[] | SyncConflictScalarFieldEnum;
      having?: SyncConflictScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: SyncConflictCountAggregateInputType | true;
      _min?: SyncConflictMinAggregateInputType;
      _max?: SyncConflictMaxAggregateInputType;
   };

   export type SyncConflictGroupByOutputType = {
      id: string;
      operationType: string;
      taskId: string;
      uiVersion: string;
      cliVersion: string;
      resolved: boolean;
      resolution: string | null;
      resolvedAt: Date | null;
      resolvedBy: string | null;
      timestamp: Date;
      _count: SyncConflictCountAggregateOutputType | null;
      _min: SyncConflictMinAggregateOutputType | null;
      _max: SyncConflictMaxAggregateOutputType | null;
   };

   type GetSyncConflictGroupByPayload<T extends SyncConflictGroupByArgs> = Prisma.PrismaPromise<
      Array<
         PickEnumerable<SyncConflictGroupByOutputType, T['by']> & {
            [P in keyof T & keyof SyncConflictGroupByOutputType]: P extends '_count'
               ? T[P] extends boolean
                  ? number
                  : GetScalarType<T[P], SyncConflictGroupByOutputType[P]>
               : GetScalarType<T[P], SyncConflictGroupByOutputType[P]>;
         }
      >
   >;

   export type SyncConflictSelect<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         operationType?: boolean;
         taskId?: boolean;
         uiVersion?: boolean;
         cliVersion?: boolean;
         resolved?: boolean;
         resolution?: boolean;
         resolvedAt?: boolean;
         resolvedBy?: boolean;
         timestamp?: boolean;
      },
      ExtArgs['result']['syncConflict']
   >;

   export type SyncConflictSelectCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         operationType?: boolean;
         taskId?: boolean;
         uiVersion?: boolean;
         cliVersion?: boolean;
         resolved?: boolean;
         resolution?: boolean;
         resolvedAt?: boolean;
         resolvedBy?: boolean;
         timestamp?: boolean;
      },
      ExtArgs['result']['syncConflict']
   >;

   export type SyncConflictSelectUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         operationType?: boolean;
         taskId?: boolean;
         uiVersion?: boolean;
         cliVersion?: boolean;
         resolved?: boolean;
         resolution?: boolean;
         resolvedAt?: boolean;
         resolvedBy?: boolean;
         timestamp?: boolean;
      },
      ExtArgs['result']['syncConflict']
   >;

   export type SyncConflictSelectScalar = {
      id?: boolean;
      operationType?: boolean;
      taskId?: boolean;
      uiVersion?: boolean;
      cliVersion?: boolean;
      resolved?: boolean;
      resolution?: boolean;
      resolvedAt?: boolean;
      resolvedBy?: boolean;
      timestamp?: boolean;
   };

   export type SyncConflictOmit<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetOmit<
      | 'id'
      | 'operationType'
      | 'taskId'
      | 'uiVersion'
      | 'cliVersion'
      | 'resolved'
      | 'resolution'
      | 'resolvedAt'
      | 'resolvedBy'
      | 'timestamp',
      ExtArgs['result']['syncConflict']
   >;

   export type $SyncConflictPayload<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      name: 'SyncConflict';
      objects: {};
      scalars: $Extensions.GetPayloadResult<
         {
            id: string;
            operationType: string;
            taskId: string;
            uiVersion: string;
            cliVersion: string;
            resolved: boolean;
            resolution: string | null;
            resolvedAt: Date | null;
            resolvedBy: string | null;
            timestamp: Date;
         },
         ExtArgs['result']['syncConflict']
      >;
      composites: {};
   };

   type SyncConflictGetPayload<S extends boolean | null | undefined | SyncConflictDefaultArgs> =
      $Result.GetResult<Prisma.$SyncConflictPayload, S>;

   type SyncConflictCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      Omit<SyncConflictFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
         select?: SyncConflictCountAggregateInputType | true;
      };

   export interface SyncConflictDelegate<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > {
      [K: symbol]: {
         types: Prisma.TypeMap<ExtArgs>['model']['SyncConflict'];
         meta: { name: 'SyncConflict' };
      };
      /**
       * Find zero or one SyncConflict that matches the filter.
       * @param {SyncConflictFindUniqueArgs} args - Arguments to find a SyncConflict
       * @example
       * // Get one SyncConflict
       * const syncConflict = await prisma.syncConflict.findUnique({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUnique<T extends SyncConflictFindUniqueArgs>(
         args: SelectSubset<T, SyncConflictFindUniqueArgs<ExtArgs>>
      ): Prisma__SyncConflictClient<
         $Result.GetResult<
            Prisma.$SyncConflictPayload<ExtArgs>,
            T,
            'findUnique',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find one SyncConflict that matches the filter or throw an error with `error.code='P2025'`
       * if no matches were found.
       * @param {SyncConflictFindUniqueOrThrowArgs} args - Arguments to find a SyncConflict
       * @example
       * // Get one SyncConflict
       * const syncConflict = await prisma.syncConflict.findUniqueOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUniqueOrThrow<T extends SyncConflictFindUniqueOrThrowArgs>(
         args: SelectSubset<T, SyncConflictFindUniqueOrThrowArgs<ExtArgs>>
      ): Prisma__SyncConflictClient<
         $Result.GetResult<
            Prisma.$SyncConflictPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first SyncConflict that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SyncConflictFindFirstArgs} args - Arguments to find a SyncConflict
       * @example
       * // Get one SyncConflict
       * const syncConflict = await prisma.syncConflict.findFirst({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirst<T extends SyncConflictFindFirstArgs>(
         args?: SelectSubset<T, SyncConflictFindFirstArgs<ExtArgs>>
      ): Prisma__SyncConflictClient<
         $Result.GetResult<
            Prisma.$SyncConflictPayload<ExtArgs>,
            T,
            'findFirst',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first SyncConflict that matches the filter or
       * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SyncConflictFindFirstOrThrowArgs} args - Arguments to find a SyncConflict
       * @example
       * // Get one SyncConflict
       * const syncConflict = await prisma.syncConflict.findFirstOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirstOrThrow<T extends SyncConflictFindFirstOrThrowArgs>(
         args?: SelectSubset<T, SyncConflictFindFirstOrThrowArgs<ExtArgs>>
      ): Prisma__SyncConflictClient<
         $Result.GetResult<
            Prisma.$SyncConflictPayload<ExtArgs>,
            T,
            'findFirstOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find zero or more SyncConflicts that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SyncConflictFindManyArgs} args - Arguments to filter and select certain fields only.
       * @example
       * // Get all SyncConflicts
       * const syncConflicts = await prisma.syncConflict.findMany()
       *
       * // Get first 10 SyncConflicts
       * const syncConflicts = await prisma.syncConflict.findMany({ take: 10 })
       *
       * // Only select the `id`
       * const syncConflictWithIdOnly = await prisma.syncConflict.findMany({ select: { id: true } })
       *
       */
      findMany<T extends SyncConflictFindManyArgs>(
         args?: SelectSubset<T, SyncConflictFindManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$SyncConflictPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      >;

      /**
       * Create a SyncConflict.
       * @param {SyncConflictCreateArgs} args - Arguments to create a SyncConflict.
       * @example
       * // Create one SyncConflict
       * const SyncConflict = await prisma.syncConflict.create({
       *   data: {
       *     // ... data to create a SyncConflict
       *   }
       * })
       *
       */
      create<T extends SyncConflictCreateArgs>(
         args: SelectSubset<T, SyncConflictCreateArgs<ExtArgs>>
      ): Prisma__SyncConflictClient<
         $Result.GetResult<Prisma.$SyncConflictPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Create many SyncConflicts.
       * @param {SyncConflictCreateManyArgs} args - Arguments to create many SyncConflicts.
       * @example
       * // Create many SyncConflicts
       * const syncConflict = await prisma.syncConflict.createMany({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       */
      createMany<T extends SyncConflictCreateManyArgs>(
         args?: SelectSubset<T, SyncConflictCreateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Create many SyncConflicts and returns the data saved in the database.
       * @param {SyncConflictCreateManyAndReturnArgs} args - Arguments to create many SyncConflicts.
       * @example
       * // Create many SyncConflicts
       * const syncConflict = await prisma.syncConflict.createManyAndReturn({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Create many SyncConflicts and only return the `id`
       * const syncConflictWithIdOnly = await prisma.syncConflict.createManyAndReturn({
       *   select: { id: true },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      createManyAndReturn<T extends SyncConflictCreateManyAndReturnArgs>(
         args?: SelectSubset<T, SyncConflictCreateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$SyncConflictPayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Delete a SyncConflict.
       * @param {SyncConflictDeleteArgs} args - Arguments to delete one SyncConflict.
       * @example
       * // Delete one SyncConflict
       * const SyncConflict = await prisma.syncConflict.delete({
       *   where: {
       *     // ... filter to delete one SyncConflict
       *   }
       * })
       *
       */
      delete<T extends SyncConflictDeleteArgs>(
         args: SelectSubset<T, SyncConflictDeleteArgs<ExtArgs>>
      ): Prisma__SyncConflictClient<
         $Result.GetResult<Prisma.$SyncConflictPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Update one SyncConflict.
       * @param {SyncConflictUpdateArgs} args - Arguments to update one SyncConflict.
       * @example
       * // Update one SyncConflict
       * const syncConflict = await prisma.syncConflict.update({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      update<T extends SyncConflictUpdateArgs>(
         args: SelectSubset<T, SyncConflictUpdateArgs<ExtArgs>>
      ): Prisma__SyncConflictClient<
         $Result.GetResult<Prisma.$SyncConflictPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Delete zero or more SyncConflicts.
       * @param {SyncConflictDeleteManyArgs} args - Arguments to filter SyncConflicts to delete.
       * @example
       * // Delete a few SyncConflicts
       * const { count } = await prisma.syncConflict.deleteMany({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       *
       */
      deleteMany<T extends SyncConflictDeleteManyArgs>(
         args?: SelectSubset<T, SyncConflictDeleteManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more SyncConflicts.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SyncConflictUpdateManyArgs} args - Arguments to update one or more rows.
       * @example
       * // Update many SyncConflicts
       * const syncConflict = await prisma.syncConflict.updateMany({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      updateMany<T extends SyncConflictUpdateManyArgs>(
         args: SelectSubset<T, SyncConflictUpdateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more SyncConflicts and returns the data updated in the database.
       * @param {SyncConflictUpdateManyAndReturnArgs} args - Arguments to update many SyncConflicts.
       * @example
       * // Update many SyncConflicts
       * const syncConflict = await prisma.syncConflict.updateManyAndReturn({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Update zero or more SyncConflicts and only return the `id`
       * const syncConflictWithIdOnly = await prisma.syncConflict.updateManyAndReturn({
       *   select: { id: true },
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      updateManyAndReturn<T extends SyncConflictUpdateManyAndReturnArgs>(
         args: SelectSubset<T, SyncConflictUpdateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$SyncConflictPayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Create or update one SyncConflict.
       * @param {SyncConflictUpsertArgs} args - Arguments to update or create a SyncConflict.
       * @example
       * // Update or create a SyncConflict
       * const syncConflict = await prisma.syncConflict.upsert({
       *   create: {
       *     // ... data to create a SyncConflict
       *   },
       *   update: {
       *     // ... in case it already exists, update
       *   },
       *   where: {
       *     // ... the filter for the SyncConflict we want to update
       *   }
       * })
       */
      upsert<T extends SyncConflictUpsertArgs>(
         args: SelectSubset<T, SyncConflictUpsertArgs<ExtArgs>>
      ): Prisma__SyncConflictClient<
         $Result.GetResult<Prisma.$SyncConflictPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Count the number of SyncConflicts.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SyncConflictCountArgs} args - Arguments to filter SyncConflicts to count.
       * @example
       * // Count the number of SyncConflicts
       * const count = await prisma.syncConflict.count({
       *   where: {
       *     // ... the filter for the SyncConflicts we want to count
       *   }
       * })
       **/
      count<T extends SyncConflictCountArgs>(
         args?: Subset<T, SyncConflictCountArgs>
      ): Prisma.PrismaPromise<
         T extends $Utils.Record<'select', any>
            ? T['select'] extends true
               ? number
               : GetScalarType<T['select'], SyncConflictCountAggregateOutputType>
            : number
      >;

      /**
       * Allows you to perform aggregations operations on a SyncConflict.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SyncConflictAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
       * @example
       * // Ordered by age ascending
       * // Where email contains prisma.io
       * // Limited to the 10 users
       * const aggregations = await prisma.user.aggregate({
       *   _avg: {
       *     age: true,
       *   },
       *   where: {
       *     email: {
       *       contains: "prisma.io",
       *     },
       *   },
       *   orderBy: {
       *     age: "asc",
       *   },
       *   take: 10,
       * })
       **/
      aggregate<T extends SyncConflictAggregateArgs>(
         args: Subset<T, SyncConflictAggregateArgs>
      ): Prisma.PrismaPromise<GetSyncConflictAggregateType<T>>;

      /**
       * Group by SyncConflict.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {SyncConflictGroupByArgs} args - Group by arguments.
       * @example
       * // Group by city, order by createdAt, get count
       * const result = await prisma.user.groupBy({
       *   by: ['city', 'createdAt'],
       *   orderBy: {
       *     createdAt: true
       *   },
       *   _count: {
       *     _all: true
       *   },
       * })
       *
       **/
      groupBy<
         T extends SyncConflictGroupByArgs,
         HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
         OrderByArg extends True extends HasSelectOrTake
            ? { orderBy: SyncConflictGroupByArgs['orderBy'] }
            : { orderBy?: SyncConflictGroupByArgs['orderBy'] },
         OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
         ByFields extends MaybeTupleToUnion<T['by']>,
         ByValid extends Has<ByFields, OrderFields>,
         HavingFields extends GetHavingFields<T['having']>,
         HavingValid extends Has<ByFields, HavingFields>,
         ByEmpty extends T['by'] extends never[] ? True : False,
         InputErrors extends ByEmpty extends True
            ? `Error: "by" must not be empty.`
            : HavingValid extends False
              ? {
                   [P in HavingFields]: P extends ByFields
                      ? never
                      : P extends string
                        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                        : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Keys<T>
                ? 'orderBy' extends Keys<T>
                   ? ByValid extends True
                      ? {}
                      : {
                           [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                        }[OrderFields]
                   : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Keys<T>
                  ? 'orderBy' extends Keys<T>
                     ? ByValid extends True
                        ? {}
                        : {
                             [P in OrderFields]: P extends ByFields
                                ? never
                                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                     : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends True
                    ? {}
                    : {
                         [P in OrderFields]: P extends ByFields
                            ? never
                            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
      >(
         args: SubsetIntersection<T, SyncConflictGroupByArgs, OrderByArg> & InputErrors
      ): {} extends InputErrors
         ? GetSyncConflictGroupByPayload<T>
         : Prisma.PrismaPromise<InputErrors>;
      /**
       * Fields of the SyncConflict model
       */
      readonly fields: SyncConflictFieldRefs;
   }

   /**
    * The delegate class that acts as a "Promise-like" for SyncConflict.
    * Why is this prefixed with `Prisma__`?
    * Because we want to prevent naming conflicts as mentioned in
    * https://github.com/prisma/prisma-client-js/issues/707
    */
   export interface Prisma__SyncConflictClient<
      T,
      Null = never,
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > extends Prisma.PrismaPromise<T> {
      readonly [Symbol.toStringTag]: 'PrismaPromise';
      /**
       * Attaches callbacks for the resolution and/or rejection of the Promise.
       * @param onfulfilled The callback to execute when the Promise is resolved.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of which ever callback is executed.
       */
      then<TResult1 = T, TResult2 = never>(
         onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
         onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
      ): $Utils.JsPromise<TResult1 | TResult2>;
      /**
       * Attaches a callback for only the rejection of the Promise.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of the callback.
       */
      catch<TResult = never>(
         onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
      ): $Utils.JsPromise<T | TResult>;
      /**
       * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
       * resolved value cannot be modified from the callback.
       * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
       * @returns A Promise for the completion of the callback.
       */
      finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
   }

   /**
    * Fields of the SyncConflict model
    */
   interface SyncConflictFieldRefs {
      readonly id: FieldRef<'SyncConflict', 'String'>;
      readonly operationType: FieldRef<'SyncConflict', 'String'>;
      readonly taskId: FieldRef<'SyncConflict', 'String'>;
      readonly uiVersion: FieldRef<'SyncConflict', 'String'>;
      readonly cliVersion: FieldRef<'SyncConflict', 'String'>;
      readonly resolved: FieldRef<'SyncConflict', 'Boolean'>;
      readonly resolution: FieldRef<'SyncConflict', 'String'>;
      readonly resolvedAt: FieldRef<'SyncConflict', 'DateTime'>;
      readonly resolvedBy: FieldRef<'SyncConflict', 'String'>;
      readonly timestamp: FieldRef<'SyncConflict', 'DateTime'>;
   }

   // Custom InputTypes
   /**
    * SyncConflict findUnique
    */
   export type SyncConflictFindUniqueArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncConflict
       */
      select?: SyncConflictSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncConflict
       */
      omit?: SyncConflictOmit<ExtArgs> | null;
      /**
       * Filter, which SyncConflict to fetch.
       */
      where: SyncConflictWhereUniqueInput;
   };

   /**
    * SyncConflict findUniqueOrThrow
    */
   export type SyncConflictFindUniqueOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncConflict
       */
      select?: SyncConflictSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncConflict
       */
      omit?: SyncConflictOmit<ExtArgs> | null;
      /**
       * Filter, which SyncConflict to fetch.
       */
      where: SyncConflictWhereUniqueInput;
   };

   /**
    * SyncConflict findFirst
    */
   export type SyncConflictFindFirstArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncConflict
       */
      select?: SyncConflictSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncConflict
       */
      omit?: SyncConflictOmit<ExtArgs> | null;
      /**
       * Filter, which SyncConflict to fetch.
       */
      where?: SyncConflictWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of SyncConflicts to fetch.
       */
      orderBy?: SyncConflictOrderByWithRelationInput | SyncConflictOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for SyncConflicts.
       */
      cursor?: SyncConflictWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` SyncConflicts from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` SyncConflicts.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of SyncConflicts.
       */
      distinct?: SyncConflictScalarFieldEnum | SyncConflictScalarFieldEnum[];
   };

   /**
    * SyncConflict findFirstOrThrow
    */
   export type SyncConflictFindFirstOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncConflict
       */
      select?: SyncConflictSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncConflict
       */
      omit?: SyncConflictOmit<ExtArgs> | null;
      /**
       * Filter, which SyncConflict to fetch.
       */
      where?: SyncConflictWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of SyncConflicts to fetch.
       */
      orderBy?: SyncConflictOrderByWithRelationInput | SyncConflictOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for SyncConflicts.
       */
      cursor?: SyncConflictWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` SyncConflicts from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` SyncConflicts.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of SyncConflicts.
       */
      distinct?: SyncConflictScalarFieldEnum | SyncConflictScalarFieldEnum[];
   };

   /**
    * SyncConflict findMany
    */
   export type SyncConflictFindManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncConflict
       */
      select?: SyncConflictSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncConflict
       */
      omit?: SyncConflictOmit<ExtArgs> | null;
      /**
       * Filter, which SyncConflicts to fetch.
       */
      where?: SyncConflictWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of SyncConflicts to fetch.
       */
      orderBy?: SyncConflictOrderByWithRelationInput | SyncConflictOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing SyncConflicts.
       */
      cursor?: SyncConflictWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` SyncConflicts from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` SyncConflicts.
       */
      skip?: number;
      distinct?: SyncConflictScalarFieldEnum | SyncConflictScalarFieldEnum[];
   };

   /**
    * SyncConflict create
    */
   export type SyncConflictCreateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncConflict
       */
      select?: SyncConflictSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncConflict
       */
      omit?: SyncConflictOmit<ExtArgs> | null;
      /**
       * The data needed to create a SyncConflict.
       */
      data: XOR<SyncConflictCreateInput, SyncConflictUncheckedCreateInput>;
   };

   /**
    * SyncConflict createMany
    */
   export type SyncConflictCreateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to create many SyncConflicts.
       */
      data: SyncConflictCreateManyInput | SyncConflictCreateManyInput[];
   };

   /**
    * SyncConflict createManyAndReturn
    */
   export type SyncConflictCreateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncConflict
       */
      select?: SyncConflictSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncConflict
       */
      omit?: SyncConflictOmit<ExtArgs> | null;
      /**
       * The data used to create many SyncConflicts.
       */
      data: SyncConflictCreateManyInput | SyncConflictCreateManyInput[];
   };

   /**
    * SyncConflict update
    */
   export type SyncConflictUpdateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncConflict
       */
      select?: SyncConflictSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncConflict
       */
      omit?: SyncConflictOmit<ExtArgs> | null;
      /**
       * The data needed to update a SyncConflict.
       */
      data: XOR<SyncConflictUpdateInput, SyncConflictUncheckedUpdateInput>;
      /**
       * Choose, which SyncConflict to update.
       */
      where: SyncConflictWhereUniqueInput;
   };

   /**
    * SyncConflict updateMany
    */
   export type SyncConflictUpdateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to update SyncConflicts.
       */
      data: XOR<SyncConflictUpdateManyMutationInput, SyncConflictUncheckedUpdateManyInput>;
      /**
       * Filter which SyncConflicts to update
       */
      where?: SyncConflictWhereInput;
      /**
       * Limit how many SyncConflicts to update.
       */
      limit?: number;
   };

   /**
    * SyncConflict updateManyAndReturn
    */
   export type SyncConflictUpdateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncConflict
       */
      select?: SyncConflictSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncConflict
       */
      omit?: SyncConflictOmit<ExtArgs> | null;
      /**
       * The data used to update SyncConflicts.
       */
      data: XOR<SyncConflictUpdateManyMutationInput, SyncConflictUncheckedUpdateManyInput>;
      /**
       * Filter which SyncConflicts to update
       */
      where?: SyncConflictWhereInput;
      /**
       * Limit how many SyncConflicts to update.
       */
      limit?: number;
   };

   /**
    * SyncConflict upsert
    */
   export type SyncConflictUpsertArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncConflict
       */
      select?: SyncConflictSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncConflict
       */
      omit?: SyncConflictOmit<ExtArgs> | null;
      /**
       * The filter to search for the SyncConflict to update in case it exists.
       */
      where: SyncConflictWhereUniqueInput;
      /**
       * In case the SyncConflict found by the `where` argument doesn't exist, create a new SyncConflict with this data.
       */
      create: XOR<SyncConflictCreateInput, SyncConflictUncheckedCreateInput>;
      /**
       * In case the SyncConflict was found with the provided `where` argument, update it with this data.
       */
      update: XOR<SyncConflictUpdateInput, SyncConflictUncheckedUpdateInput>;
   };

   /**
    * SyncConflict delete
    */
   export type SyncConflictDeleteArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncConflict
       */
      select?: SyncConflictSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncConflict
       */
      omit?: SyncConflictOmit<ExtArgs> | null;
      /**
       * Filter which SyncConflict to delete.
       */
      where: SyncConflictWhereUniqueInput;
   };

   /**
    * SyncConflict deleteMany
    */
   export type SyncConflictDeleteManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which SyncConflicts to delete
       */
      where?: SyncConflictWhereInput;
      /**
       * Limit how many SyncConflicts to delete.
       */
      limit?: number;
   };

   /**
    * SyncConflict without action
    */
   export type SyncConflictDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the SyncConflict
       */
      select?: SyncConflictSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the SyncConflict
       */
      omit?: SyncConflictOmit<ExtArgs> | null;
   };

   /**
    * Model User
    */

   export type AggregateUser = {
      _count: UserCountAggregateOutputType | null;
      _min: UserMinAggregateOutputType | null;
      _max: UserMaxAggregateOutputType | null;
   };

   export type UserMinAggregateOutputType = {
      id: string | null;
      name: string | null;
      email: string | null;
      avatarUrl: string | null;
      status: $Enums.UserStatus | null;
      role: $Enums.UserRole | null;
      joinedDate: Date | null;
      teamIds: string | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type UserMaxAggregateOutputType = {
      id: string | null;
      name: string | null;
      email: string | null;
      avatarUrl: string | null;
      status: $Enums.UserStatus | null;
      role: $Enums.UserRole | null;
      joinedDate: Date | null;
      teamIds: string | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type UserCountAggregateOutputType = {
      id: number;
      name: number;
      email: number;
      avatarUrl: number;
      status: number;
      role: number;
      joinedDate: number;
      teamIds: number;
      createdAt: number;
      updatedAt: number;
      _all: number;
   };

   export type UserMinAggregateInputType = {
      id?: true;
      name?: true;
      email?: true;
      avatarUrl?: true;
      status?: true;
      role?: true;
      joinedDate?: true;
      teamIds?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type UserMaxAggregateInputType = {
      id?: true;
      name?: true;
      email?: true;
      avatarUrl?: true;
      status?: true;
      role?: true;
      joinedDate?: true;
      teamIds?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type UserCountAggregateInputType = {
      id?: true;
      name?: true;
      email?: true;
      avatarUrl?: true;
      status?: true;
      role?: true;
      joinedDate?: true;
      teamIds?: true;
      createdAt?: true;
      updatedAt?: true;
      _all?: true;
   };

   export type UserAggregateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which User to aggregate.
       */
      where?: UserWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Users to fetch.
       */
      orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: UserWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Users from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Users.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned Users
       **/
      _count?: true | UserCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: UserMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: UserMaxAggregateInputType;
   };

   export type GetUserAggregateType<T extends UserAggregateArgs> = {
      [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
         ? T[P] extends true
            ? number
            : GetScalarType<T[P], AggregateUser[P]>
         : GetScalarType<T[P], AggregateUser[P]>;
   };

   export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         where?: UserWhereInput;
         orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[];
         by: UserScalarFieldEnum[] | UserScalarFieldEnum;
         having?: UserScalarWhereWithAggregatesInput;
         take?: number;
         skip?: number;
         _count?: UserCountAggregateInputType | true;
         _min?: UserMinAggregateInputType;
         _max?: UserMaxAggregateInputType;
      };

   export type UserGroupByOutputType = {
      id: string;
      name: string;
      email: string;
      avatarUrl: string | null;
      status: $Enums.UserStatus;
      role: $Enums.UserRole;
      joinedDate: Date;
      teamIds: string;
      createdAt: Date;
      updatedAt: Date;
      _count: UserCountAggregateOutputType | null;
      _min: UserMinAggregateOutputType | null;
      _max: UserMaxAggregateOutputType | null;
   };

   type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
      Array<
         PickEnumerable<UserGroupByOutputType, T['by']> & {
            [P in keyof T & keyof UserGroupByOutputType]: P extends '_count'
               ? T[P] extends boolean
                  ? number
                  : GetScalarType<T[P], UserGroupByOutputType[P]>
               : GetScalarType<T[P], UserGroupByOutputType[P]>;
         }
      >
   >;

   export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetSelect<
         {
            id?: boolean;
            name?: boolean;
            email?: boolean;
            avatarUrl?: boolean;
            status?: boolean;
            role?: boolean;
            joinedDate?: boolean;
            teamIds?: boolean;
            createdAt?: boolean;
            updatedAt?: boolean;
            assignedIssues?: boolean | User$assignedIssuesArgs<ExtArgs>;
            teams?: boolean | User$teamsArgs<ExtArgs>;
            ledProjects?: boolean | User$ledProjectsArgs<ExtArgs>;
            _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
         },
         ExtArgs['result']['user']
      >;

   export type UserSelectCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         name?: boolean;
         email?: boolean;
         avatarUrl?: boolean;
         status?: boolean;
         role?: boolean;
         joinedDate?: boolean;
         teamIds?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
      },
      ExtArgs['result']['user']
   >;

   export type UserSelectUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         name?: boolean;
         email?: boolean;
         avatarUrl?: boolean;
         status?: boolean;
         role?: boolean;
         joinedDate?: boolean;
         teamIds?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
      },
      ExtArgs['result']['user']
   >;

   export type UserSelectScalar = {
      id?: boolean;
      name?: boolean;
      email?: boolean;
      avatarUrl?: boolean;
      status?: boolean;
      role?: boolean;
      joinedDate?: boolean;
      teamIds?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
   };

   export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetOmit<
         | 'id'
         | 'name'
         | 'email'
         | 'avatarUrl'
         | 'status'
         | 'role'
         | 'joinedDate'
         | 'teamIds'
         | 'createdAt'
         | 'updatedAt',
         ExtArgs['result']['user']
      >;
   export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
      assignedIssues?: boolean | User$assignedIssuesArgs<ExtArgs>;
      teams?: boolean | User$teamsArgs<ExtArgs>;
      ledProjects?: boolean | User$ledProjectsArgs<ExtArgs>;
      _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>;
   };
   export type UserIncludeCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {};
   export type UserIncludeUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {};

   export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
      name: 'User';
      objects: {
         assignedIssues: Prisma.$IssuePayload<ExtArgs>[];
         teams: Prisma.$TeamMemberPayload<ExtArgs>[];
         ledProjects: Prisma.$ProjectPayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
         {
            id: string;
            name: string;
            email: string;
            avatarUrl: string | null;
            status: $Enums.UserStatus;
            role: $Enums.UserRole;
            joinedDate: Date;
            teamIds: string;
            createdAt: Date;
            updatedAt: Date;
         },
         ExtArgs['result']['user']
      >;
      composites: {};
   };

   type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<
      Prisma.$UserPayload,
      S
   >;

   type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
      UserFindManyArgs,
      'select' | 'include' | 'distinct' | 'omit'
   > & {
      select?: UserCountAggregateInputType | true;
   };

   export interface UserDelegate<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > {
      [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User']; meta: { name: 'User' } };
      /**
       * Find zero or one User that matches the filter.
       * @param {UserFindUniqueArgs} args - Arguments to find a User
       * @example
       * // Get one User
       * const user = await prisma.user.findUnique({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUnique<T extends UserFindUniqueArgs>(
         args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
      ): Prisma__UserClient<
         $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find one User that matches the filter or throw an error with `error.code='P2025'`
       * if no matches were found.
       * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
       * @example
       * // Get one User
       * const user = await prisma.user.findUniqueOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(
         args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
      ): Prisma__UserClient<
         $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first User that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {UserFindFirstArgs} args - Arguments to find a User
       * @example
       * // Get one User
       * const user = await prisma.user.findFirst({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirst<T extends UserFindFirstArgs>(
         args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
      ): Prisma__UserClient<
         $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first User that matches the filter or
       * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
       * @example
       * // Get one User
       * const user = await prisma.user.findFirstOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(
         args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
      ): Prisma__UserClient<
         $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find zero or more Users that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
       * @example
       * // Get all Users
       * const users = await prisma.user.findMany()
       *
       * // Get first 10 Users
       * const users = await prisma.user.findMany({ take: 10 })
       *
       * // Only select the `id`
       * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
       *
       */
      findMany<T extends UserFindManyArgs>(
         args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      >;

      /**
       * Create a User.
       * @param {UserCreateArgs} args - Arguments to create a User.
       * @example
       * // Create one User
       * const User = await prisma.user.create({
       *   data: {
       *     // ... data to create a User
       *   }
       * })
       *
       */
      create<T extends UserCreateArgs>(
         args: SelectSubset<T, UserCreateArgs<ExtArgs>>
      ): Prisma__UserClient<
         $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Create many Users.
       * @param {UserCreateManyArgs} args - Arguments to create many Users.
       * @example
       * // Create many Users
       * const user = await prisma.user.createMany({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       */
      createMany<T extends UserCreateManyArgs>(
         args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Create many Users and returns the data saved in the database.
       * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
       * @example
       * // Create many Users
       * const user = await prisma.user.createManyAndReturn({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Create many Users and only return the `id`
       * const userWithIdOnly = await prisma.user.createManyAndReturn({
       *   select: { id: true },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      createManyAndReturn<T extends UserCreateManyAndReturnArgs>(
         args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$UserPayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Delete a User.
       * @param {UserDeleteArgs} args - Arguments to delete one User.
       * @example
       * // Delete one User
       * const User = await prisma.user.delete({
       *   where: {
       *     // ... filter to delete one User
       *   }
       * })
       *
       */
      delete<T extends UserDeleteArgs>(
         args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
      ): Prisma__UserClient<
         $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Update one User.
       * @param {UserUpdateArgs} args - Arguments to update one User.
       * @example
       * // Update one User
       * const user = await prisma.user.update({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      update<T extends UserUpdateArgs>(
         args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
      ): Prisma__UserClient<
         $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Delete zero or more Users.
       * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
       * @example
       * // Delete a few Users
       * const { count } = await prisma.user.deleteMany({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       *
       */
      deleteMany<T extends UserDeleteManyArgs>(
         args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more Users.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
       * @example
       * // Update many Users
       * const user = await prisma.user.updateMany({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      updateMany<T extends UserUpdateManyArgs>(
         args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more Users and returns the data updated in the database.
       * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
       * @example
       * // Update many Users
       * const user = await prisma.user.updateManyAndReturn({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Update zero or more Users and only return the `id`
       * const userWithIdOnly = await prisma.user.updateManyAndReturn({
       *   select: { id: true },
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(
         args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$UserPayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Create or update one User.
       * @param {UserUpsertArgs} args - Arguments to update or create a User.
       * @example
       * // Update or create a User
       * const user = await prisma.user.upsert({
       *   create: {
       *     // ... data to create a User
       *   },
       *   update: {
       *     // ... in case it already exists, update
       *   },
       *   where: {
       *     // ... the filter for the User we want to update
       *   }
       * })
       */
      upsert<T extends UserUpsertArgs>(
         args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
      ): Prisma__UserClient<
         $Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Count the number of Users.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {UserCountArgs} args - Arguments to filter Users to count.
       * @example
       * // Count the number of Users
       * const count = await prisma.user.count({
       *   where: {
       *     // ... the filter for the Users we want to count
       *   }
       * })
       **/
      count<T extends UserCountArgs>(
         args?: Subset<T, UserCountArgs>
      ): Prisma.PrismaPromise<
         T extends $Utils.Record<'select', any>
            ? T['select'] extends true
               ? number
               : GetScalarType<T['select'], UserCountAggregateOutputType>
            : number
      >;

      /**
       * Allows you to perform aggregations operations on a User.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
       * @example
       * // Ordered by age ascending
       * // Where email contains prisma.io
       * // Limited to the 10 users
       * const aggregations = await prisma.user.aggregate({
       *   _avg: {
       *     age: true,
       *   },
       *   where: {
       *     email: {
       *       contains: "prisma.io",
       *     },
       *   },
       *   orderBy: {
       *     age: "asc",
       *   },
       *   take: 10,
       * })
       **/
      aggregate<T extends UserAggregateArgs>(
         args: Subset<T, UserAggregateArgs>
      ): Prisma.PrismaPromise<GetUserAggregateType<T>>;

      /**
       * Group by User.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {UserGroupByArgs} args - Group by arguments.
       * @example
       * // Group by city, order by createdAt, get count
       * const result = await prisma.user.groupBy({
       *   by: ['city', 'createdAt'],
       *   orderBy: {
       *     createdAt: true
       *   },
       *   _count: {
       *     _all: true
       *   },
       * })
       *
       **/
      groupBy<
         T extends UserGroupByArgs,
         HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
         OrderByArg extends True extends HasSelectOrTake
            ? { orderBy: UserGroupByArgs['orderBy'] }
            : { orderBy?: UserGroupByArgs['orderBy'] },
         OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
         ByFields extends MaybeTupleToUnion<T['by']>,
         ByValid extends Has<ByFields, OrderFields>,
         HavingFields extends GetHavingFields<T['having']>,
         HavingValid extends Has<ByFields, HavingFields>,
         ByEmpty extends T['by'] extends never[] ? True : False,
         InputErrors extends ByEmpty extends True
            ? `Error: "by" must not be empty.`
            : HavingValid extends False
              ? {
                   [P in HavingFields]: P extends ByFields
                      ? never
                      : P extends string
                        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                        : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Keys<T>
                ? 'orderBy' extends Keys<T>
                   ? ByValid extends True
                      ? {}
                      : {
                           [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                        }[OrderFields]
                   : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Keys<T>
                  ? 'orderBy' extends Keys<T>
                     ? ByValid extends True
                        ? {}
                        : {
                             [P in OrderFields]: P extends ByFields
                                ? never
                                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                     : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends True
                    ? {}
                    : {
                         [P in OrderFields]: P extends ByFields
                            ? never
                            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
      >(
         args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors
      ): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
      /**
       * Fields of the User model
       */
      readonly fields: UserFieldRefs;
   }

   /**
    * The delegate class that acts as a "Promise-like" for User.
    * Why is this prefixed with `Prisma__`?
    * Because we want to prevent naming conflicts as mentioned in
    * https://github.com/prisma/prisma-client-js/issues/707
    */
   export interface Prisma__UserClient<
      T,
      Null = never,
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > extends Prisma.PrismaPromise<T> {
      readonly [Symbol.toStringTag]: 'PrismaPromise';
      assignedIssues<T extends User$assignedIssuesArgs<ExtArgs> = {}>(
         args?: Subset<T, User$assignedIssuesArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
      >;
      teams<T extends User$teamsArgs<ExtArgs> = {}>(
         args?: Subset<T, User$teamsArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         | $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
         | Null
      >;
      ledProjects<T extends User$ledProjectsArgs<ExtArgs> = {}>(
         args?: Subset<T, User$ledProjectsArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
      >;
      /**
       * Attaches callbacks for the resolution and/or rejection of the Promise.
       * @param onfulfilled The callback to execute when the Promise is resolved.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of which ever callback is executed.
       */
      then<TResult1 = T, TResult2 = never>(
         onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
         onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
      ): $Utils.JsPromise<TResult1 | TResult2>;
      /**
       * Attaches a callback for only the rejection of the Promise.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of the callback.
       */
      catch<TResult = never>(
         onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
      ): $Utils.JsPromise<T | TResult>;
      /**
       * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
       * resolved value cannot be modified from the callback.
       * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
       * @returns A Promise for the completion of the callback.
       */
      finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
   }

   /**
    * Fields of the User model
    */
   interface UserFieldRefs {
      readonly id: FieldRef<'User', 'String'>;
      readonly name: FieldRef<'User', 'String'>;
      readonly email: FieldRef<'User', 'String'>;
      readonly avatarUrl: FieldRef<'User', 'String'>;
      readonly status: FieldRef<'User', 'UserStatus'>;
      readonly role: FieldRef<'User', 'UserRole'>;
      readonly joinedDate: FieldRef<'User', 'DateTime'>;
      readonly teamIds: FieldRef<'User', 'String'>;
      readonly createdAt: FieldRef<'User', 'DateTime'>;
      readonly updatedAt: FieldRef<'User', 'DateTime'>;
   }

   // Custom InputTypes
   /**
    * User findUnique
    */
   export type UserFindUniqueArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
      /**
       * Filter, which User to fetch.
       */
      where: UserWhereUniqueInput;
   };

   /**
    * User findUniqueOrThrow
    */
   export type UserFindUniqueOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
      /**
       * Filter, which User to fetch.
       */
      where: UserWhereUniqueInput;
   };

   /**
    * User findFirst
    */
   export type UserFindFirstArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
      /**
       * Filter, which User to fetch.
       */
      where?: UserWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Users to fetch.
       */
      orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for Users.
       */
      cursor?: UserWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Users from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Users.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of Users.
       */
      distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
   };

   /**
    * User findFirstOrThrow
    */
   export type UserFindFirstOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
      /**
       * Filter, which User to fetch.
       */
      where?: UserWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Users to fetch.
       */
      orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for Users.
       */
      cursor?: UserWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Users from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Users.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of Users.
       */
      distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
   };

   /**
    * User findMany
    */
   export type UserFindManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
      /**
       * Filter, which Users to fetch.
       */
      where?: UserWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Users to fetch.
       */
      orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Users.
       */
      cursor?: UserWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Users from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Users.
       */
      skip?: number;
      distinct?: UserScalarFieldEnum | UserScalarFieldEnum[];
   };

   /**
    * User create
    */
   export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the User
          */
         select?: UserSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the User
          */
         omit?: UserOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: UserInclude<ExtArgs> | null;
         /**
          * The data needed to create a User.
          */
         data: XOR<UserCreateInput, UserUncheckedCreateInput>;
      };

   /**
    * User createMany
    */
   export type UserCreateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to create many Users.
       */
      data: UserCreateManyInput | UserCreateManyInput[];
   };

   /**
    * User createManyAndReturn
    */
   export type UserCreateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * The data used to create many Users.
       */
      data: UserCreateManyInput | UserCreateManyInput[];
   };

   /**
    * User update
    */
   export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the User
          */
         select?: UserSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the User
          */
         omit?: UserOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: UserInclude<ExtArgs> | null;
         /**
          * The data needed to update a User.
          */
         data: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
         /**
          * Choose, which User to update.
          */
         where: UserWhereUniqueInput;
      };

   /**
    * User updateMany
    */
   export type UserUpdateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to update Users.
       */
      data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
      /**
       * Filter which Users to update
       */
      where?: UserWhereInput;
      /**
       * Limit how many Users to update.
       */
      limit?: number;
   };

   /**
    * User updateManyAndReturn
    */
   export type UserUpdateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * The data used to update Users.
       */
      data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>;
      /**
       * Filter which Users to update
       */
      where?: UserWhereInput;
      /**
       * Limit how many Users to update.
       */
      limit?: number;
   };

   /**
    * User upsert
    */
   export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the User
          */
         select?: UserSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the User
          */
         omit?: UserOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: UserInclude<ExtArgs> | null;
         /**
          * The filter to search for the User to update in case it exists.
          */
         where: UserWhereUniqueInput;
         /**
          * In case the User found by the `where` argument doesn't exist, create a new User with this data.
          */
         create: XOR<UserCreateInput, UserUncheckedCreateInput>;
         /**
          * In case the User was found with the provided `where` argument, update it with this data.
          */
         update: XOR<UserUpdateInput, UserUncheckedUpdateInput>;
      };

   /**
    * User delete
    */
   export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the User
          */
         select?: UserSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the User
          */
         omit?: UserOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: UserInclude<ExtArgs> | null;
         /**
          * Filter which User to delete.
          */
         where: UserWhereUniqueInput;
      };

   /**
    * User deleteMany
    */
   export type UserDeleteManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which Users to delete
       */
      where?: UserWhereInput;
      /**
       * Limit how many Users to delete.
       */
      limit?: number;
   };

   /**
    * User.assignedIssues
    */
   export type User$assignedIssuesArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Issue
       */
      select?: IssueSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Issue
       */
      omit?: IssueOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueInclude<ExtArgs> | null;
      where?: IssueWhereInput;
      orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[];
      cursor?: IssueWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[];
   };

   /**
    * User.teams
    */
   export type User$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the TeamMember
          */
         select?: TeamMemberSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the TeamMember
          */
         omit?: TeamMemberOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: TeamMemberInclude<ExtArgs> | null;
         where?: TeamMemberWhereInput;
         orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[];
         cursor?: TeamMemberWhereUniqueInput;
         take?: number;
         skip?: number;
         distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
      };

   /**
    * User.ledProjects
    */
   export type User$ledProjectsArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Project
       */
      select?: ProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Project
       */
      omit?: ProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ProjectInclude<ExtArgs> | null;
      where?: ProjectWhereInput;
      orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[];
      cursor?: ProjectWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[];
   };

   /**
    * User without action
    */
   export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the User
          */
         select?: UserSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the User
          */
         omit?: UserOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: UserInclude<ExtArgs> | null;
      };

   /**
    * Model Project
    */

   export type AggregateProject = {
      _count: ProjectCountAggregateOutputType | null;
      _avg: ProjectAvgAggregateOutputType | null;
      _sum: ProjectSumAggregateOutputType | null;
      _min: ProjectMinAggregateOutputType | null;
      _max: ProjectMaxAggregateOutputType | null;
   };

   export type ProjectAvgAggregateOutputType = {
      percentComplete: number | null;
   };

   export type ProjectSumAggregateOutputType = {
      percentComplete: number | null;
   };

   export type ProjectMinAggregateOutputType = {
      id: string | null;
      name: string | null;
      description: string | null;
      color: string | null;
      identifier: string | null;
      icon: string | null;
      percentComplete: number | null;
      startDate: Date | null;
      health: $Enums.ProjectHealth | null;
      leadId: string | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type ProjectMaxAggregateOutputType = {
      id: string | null;
      name: string | null;
      description: string | null;
      color: string | null;
      identifier: string | null;
      icon: string | null;
      percentComplete: number | null;
      startDate: Date | null;
      health: $Enums.ProjectHealth | null;
      leadId: string | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type ProjectCountAggregateOutputType = {
      id: number;
      name: number;
      description: number;
      color: number;
      identifier: number;
      icon: number;
      percentComplete: number;
      startDate: number;
      health: number;
      leadId: number;
      createdAt: number;
      updatedAt: number;
      _all: number;
   };

   export type ProjectAvgAggregateInputType = {
      percentComplete?: true;
   };

   export type ProjectSumAggregateInputType = {
      percentComplete?: true;
   };

   export type ProjectMinAggregateInputType = {
      id?: true;
      name?: true;
      description?: true;
      color?: true;
      identifier?: true;
      icon?: true;
      percentComplete?: true;
      startDate?: true;
      health?: true;
      leadId?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type ProjectMaxAggregateInputType = {
      id?: true;
      name?: true;
      description?: true;
      color?: true;
      identifier?: true;
      icon?: true;
      percentComplete?: true;
      startDate?: true;
      health?: true;
      leadId?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type ProjectCountAggregateInputType = {
      id?: true;
      name?: true;
      description?: true;
      color?: true;
      identifier?: true;
      icon?: true;
      percentComplete?: true;
      startDate?: true;
      health?: true;
      leadId?: true;
      createdAt?: true;
      updatedAt?: true;
      _all?: true;
   };

   export type ProjectAggregateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which Project to aggregate.
       */
      where?: ProjectWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Projects to fetch.
       */
      orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: ProjectWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Projects from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Projects.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned Projects
       **/
      _count?: true | ProjectCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to average
       **/
      _avg?: ProjectAvgAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to sum
       **/
      _sum?: ProjectSumAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: ProjectMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: ProjectMaxAggregateInputType;
   };

   export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
      [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
         ? T[P] extends true
            ? number
            : GetScalarType<T[P], AggregateProject[P]>
         : GetScalarType<T[P], AggregateProject[P]>;
   };

   export type ProjectGroupByArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: ProjectWhereInput;
      orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[];
      by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum;
      having?: ProjectScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: ProjectCountAggregateInputType | true;
      _avg?: ProjectAvgAggregateInputType;
      _sum?: ProjectSumAggregateInputType;
      _min?: ProjectMinAggregateInputType;
      _max?: ProjectMaxAggregateInputType;
   };

   export type ProjectGroupByOutputType = {
      id: string;
      name: string;
      description: string | null;
      color: string | null;
      identifier: string | null;
      icon: string | null;
      percentComplete: number;
      startDate: Date | null;
      health: $Enums.ProjectHealth;
      leadId: string | null;
      createdAt: Date;
      updatedAt: Date;
      _count: ProjectCountAggregateOutputType | null;
      _avg: ProjectAvgAggregateOutputType | null;
      _sum: ProjectSumAggregateOutputType | null;
      _min: ProjectMinAggregateOutputType | null;
      _max: ProjectMaxAggregateOutputType | null;
   };

   type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
      Array<
         PickEnumerable<ProjectGroupByOutputType, T['by']> & {
            [P in keyof T & keyof ProjectGroupByOutputType]: P extends '_count'
               ? T[P] extends boolean
                  ? number
                  : GetScalarType<T[P], ProjectGroupByOutputType[P]>
               : GetScalarType<T[P], ProjectGroupByOutputType[P]>;
         }
      >
   >;

   export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetSelect<
         {
            id?: boolean;
            name?: boolean;
            description?: boolean;
            color?: boolean;
            identifier?: boolean;
            icon?: boolean;
            percentComplete?: boolean;
            startDate?: boolean;
            health?: boolean;
            leadId?: boolean;
            createdAt?: boolean;
            updatedAt?: boolean;
            issues?: boolean | Project$issuesArgs<ExtArgs>;
            lead?: boolean | Project$leadArgs<ExtArgs>;
            teams?: boolean | Project$teamsArgs<ExtArgs>;
            _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>;
         },
         ExtArgs['result']['project']
      >;

   export type ProjectSelectCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         name?: boolean;
         description?: boolean;
         color?: boolean;
         identifier?: boolean;
         icon?: boolean;
         percentComplete?: boolean;
         startDate?: boolean;
         health?: boolean;
         leadId?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
         lead?: boolean | Project$leadArgs<ExtArgs>;
      },
      ExtArgs['result']['project']
   >;

   export type ProjectSelectUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         name?: boolean;
         description?: boolean;
         color?: boolean;
         identifier?: boolean;
         icon?: boolean;
         percentComplete?: boolean;
         startDate?: boolean;
         health?: boolean;
         leadId?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
         lead?: boolean | Project$leadArgs<ExtArgs>;
      },
      ExtArgs['result']['project']
   >;

   export type ProjectSelectScalar = {
      id?: boolean;
      name?: boolean;
      description?: boolean;
      color?: boolean;
      identifier?: boolean;
      icon?: boolean;
      percentComplete?: boolean;
      startDate?: boolean;
      health?: boolean;
      leadId?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
   };

   export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetOmit<
         | 'id'
         | 'name'
         | 'description'
         | 'color'
         | 'identifier'
         | 'icon'
         | 'percentComplete'
         | 'startDate'
         | 'health'
         | 'leadId'
         | 'createdAt'
         | 'updatedAt',
         ExtArgs['result']['project']
      >;
   export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         issues?: boolean | Project$issuesArgs<ExtArgs>;
         lead?: boolean | Project$leadArgs<ExtArgs>;
         teams?: boolean | Project$teamsArgs<ExtArgs>;
         _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>;
      };
   export type ProjectIncludeCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      lead?: boolean | Project$leadArgs<ExtArgs>;
   };
   export type ProjectIncludeUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      lead?: boolean | Project$leadArgs<ExtArgs>;
   };

   export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         name: 'Project';
         objects: {
            issues: Prisma.$IssuePayload<ExtArgs>[];
            lead: Prisma.$UserPayload<ExtArgs> | null;
            teams: Prisma.$TeamProjectPayload<ExtArgs>[];
         };
         scalars: $Extensions.GetPayloadResult<
            {
               id: string;
               name: string;
               description: string | null;
               color: string | null;
               identifier: string | null;
               icon: string | null;
               percentComplete: number;
               startDate: Date | null;
               health: $Enums.ProjectHealth;
               leadId: string | null;
               createdAt: Date;
               updatedAt: Date;
            },
            ExtArgs['result']['project']
         >;
         composites: {};
      };

   type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> =
      $Result.GetResult<Prisma.$ProjectPayload, S>;

   type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
      ProjectFindManyArgs,
      'select' | 'include' | 'distinct' | 'omit'
   > & {
      select?: ProjectCountAggregateInputType | true;
   };

   export interface ProjectDelegate<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > {
      [K: symbol]: {
         types: Prisma.TypeMap<ExtArgs>['model']['Project'];
         meta: { name: 'Project' };
      };
      /**
       * Find zero or one Project that matches the filter.
       * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
       * @example
       * // Get one Project
       * const project = await prisma.project.findUnique({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUnique<T extends ProjectFindUniqueArgs>(
         args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>
      ): Prisma__ProjectClient<
         $Result.GetResult<
            Prisma.$ProjectPayload<ExtArgs>,
            T,
            'findUnique',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find one Project that matches the filter or throw an error with `error.code='P2025'`
       * if no matches were found.
       * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
       * @example
       * // Get one Project
       * const project = await prisma.project.findUniqueOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(
         args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>
      ): Prisma__ProjectClient<
         $Result.GetResult<
            Prisma.$ProjectPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first Project that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {ProjectFindFirstArgs} args - Arguments to find a Project
       * @example
       * // Get one Project
       * const project = await prisma.project.findFirst({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirst<T extends ProjectFindFirstArgs>(
         args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>
      ): Prisma__ProjectClient<
         $Result.GetResult<
            Prisma.$ProjectPayload<ExtArgs>,
            T,
            'findFirst',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first Project that matches the filter or
       * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
       * @example
       * // Get one Project
       * const project = await prisma.project.findFirstOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(
         args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>
      ): Prisma__ProjectClient<
         $Result.GetResult<
            Prisma.$ProjectPayload<ExtArgs>,
            T,
            'findFirstOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find zero or more Projects that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
       * @example
       * // Get all Projects
       * const projects = await prisma.project.findMany()
       *
       * // Get first 10 Projects
       * const projects = await prisma.project.findMany({ take: 10 })
       *
       * // Only select the `id`
       * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
       *
       */
      findMany<T extends ProjectFindManyArgs>(
         args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      >;

      /**
       * Create a Project.
       * @param {ProjectCreateArgs} args - Arguments to create a Project.
       * @example
       * // Create one Project
       * const Project = await prisma.project.create({
       *   data: {
       *     // ... data to create a Project
       *   }
       * })
       *
       */
      create<T extends ProjectCreateArgs>(
         args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>
      ): Prisma__ProjectClient<
         $Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Create many Projects.
       * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
       * @example
       * // Create many Projects
       * const project = await prisma.project.createMany({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       */
      createMany<T extends ProjectCreateManyArgs>(
         args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Create many Projects and returns the data saved in the database.
       * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
       * @example
       * // Create many Projects
       * const project = await prisma.project.createManyAndReturn({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Create many Projects and only return the `id`
       * const projectWithIdOnly = await prisma.project.createManyAndReturn({
       *   select: { id: true },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(
         args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$ProjectPayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Delete a Project.
       * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
       * @example
       * // Delete one Project
       * const Project = await prisma.project.delete({
       *   where: {
       *     // ... filter to delete one Project
       *   }
       * })
       *
       */
      delete<T extends ProjectDeleteArgs>(
         args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>
      ): Prisma__ProjectClient<
         $Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Update one Project.
       * @param {ProjectUpdateArgs} args - Arguments to update one Project.
       * @example
       * // Update one Project
       * const project = await prisma.project.update({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      update<T extends ProjectUpdateArgs>(
         args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>
      ): Prisma__ProjectClient<
         $Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Delete zero or more Projects.
       * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
       * @example
       * // Delete a few Projects
       * const { count } = await prisma.project.deleteMany({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       *
       */
      deleteMany<T extends ProjectDeleteManyArgs>(
         args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more Projects.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
       * @example
       * // Update many Projects
       * const project = await prisma.project.updateMany({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      updateMany<T extends ProjectUpdateManyArgs>(
         args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more Projects and returns the data updated in the database.
       * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
       * @example
       * // Update many Projects
       * const project = await prisma.project.updateManyAndReturn({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Update zero or more Projects and only return the `id`
       * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
       *   select: { id: true },
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(
         args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$ProjectPayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Create or update one Project.
       * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
       * @example
       * // Update or create a Project
       * const project = await prisma.project.upsert({
       *   create: {
       *     // ... data to create a Project
       *   },
       *   update: {
       *     // ... in case it already exists, update
       *   },
       *   where: {
       *     // ... the filter for the Project we want to update
       *   }
       * })
       */
      upsert<T extends ProjectUpsertArgs>(
         args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>
      ): Prisma__ProjectClient<
         $Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Count the number of Projects.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
       * @example
       * // Count the number of Projects
       * const count = await prisma.project.count({
       *   where: {
       *     // ... the filter for the Projects we want to count
       *   }
       * })
       **/
      count<T extends ProjectCountArgs>(
         args?: Subset<T, ProjectCountArgs>
      ): Prisma.PrismaPromise<
         T extends $Utils.Record<'select', any>
            ? T['select'] extends true
               ? number
               : GetScalarType<T['select'], ProjectCountAggregateOutputType>
            : number
      >;

      /**
       * Allows you to perform aggregations operations on a Project.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
       * @example
       * // Ordered by age ascending
       * // Where email contains prisma.io
       * // Limited to the 10 users
       * const aggregations = await prisma.user.aggregate({
       *   _avg: {
       *     age: true,
       *   },
       *   where: {
       *     email: {
       *       contains: "prisma.io",
       *     },
       *   },
       *   orderBy: {
       *     age: "asc",
       *   },
       *   take: 10,
       * })
       **/
      aggregate<T extends ProjectAggregateArgs>(
         args: Subset<T, ProjectAggregateArgs>
      ): Prisma.PrismaPromise<GetProjectAggregateType<T>>;

      /**
       * Group by Project.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {ProjectGroupByArgs} args - Group by arguments.
       * @example
       * // Group by city, order by createdAt, get count
       * const result = await prisma.user.groupBy({
       *   by: ['city', 'createdAt'],
       *   orderBy: {
       *     createdAt: true
       *   },
       *   _count: {
       *     _all: true
       *   },
       * })
       *
       **/
      groupBy<
         T extends ProjectGroupByArgs,
         HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
         OrderByArg extends True extends HasSelectOrTake
            ? { orderBy: ProjectGroupByArgs['orderBy'] }
            : { orderBy?: ProjectGroupByArgs['orderBy'] },
         OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
         ByFields extends MaybeTupleToUnion<T['by']>,
         ByValid extends Has<ByFields, OrderFields>,
         HavingFields extends GetHavingFields<T['having']>,
         HavingValid extends Has<ByFields, HavingFields>,
         ByEmpty extends T['by'] extends never[] ? True : False,
         InputErrors extends ByEmpty extends True
            ? `Error: "by" must not be empty.`
            : HavingValid extends False
              ? {
                   [P in HavingFields]: P extends ByFields
                      ? never
                      : P extends string
                        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                        : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Keys<T>
                ? 'orderBy' extends Keys<T>
                   ? ByValid extends True
                      ? {}
                      : {
                           [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                        }[OrderFields]
                   : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Keys<T>
                  ? 'orderBy' extends Keys<T>
                     ? ByValid extends True
                        ? {}
                        : {
                             [P in OrderFields]: P extends ByFields
                                ? never
                                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                     : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends True
                    ? {}
                    : {
                         [P in OrderFields]: P extends ByFields
                            ? never
                            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
      >(
         args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors
      ): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
      /**
       * Fields of the Project model
       */
      readonly fields: ProjectFieldRefs;
   }

   /**
    * The delegate class that acts as a "Promise-like" for Project.
    * Why is this prefixed with `Prisma__`?
    * Because we want to prevent naming conflicts as mentioned in
    * https://github.com/prisma/prisma-client-js/issues/707
    */
   export interface Prisma__ProjectClient<
      T,
      Null = never,
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > extends Prisma.PrismaPromise<T> {
      readonly [Symbol.toStringTag]: 'PrismaPromise';
      issues<T extends Project$issuesArgs<ExtArgs> = {}>(
         args?: Subset<T, Project$issuesArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
      >;
      lead<T extends Project$leadArgs<ExtArgs> = {}>(
         args?: Subset<T, Project$leadArgs<ExtArgs>>
      ): Prisma__UserClient<
         $Result.GetResult<
            Prisma.$UserPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;
      teams<T extends Project$teamsArgs<ExtArgs> = {}>(
         args?: Subset<T, Project$teamsArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         | $Result.GetResult<Prisma.$TeamProjectPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
         | Null
      >;
      /**
       * Attaches callbacks for the resolution and/or rejection of the Promise.
       * @param onfulfilled The callback to execute when the Promise is resolved.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of which ever callback is executed.
       */
      then<TResult1 = T, TResult2 = never>(
         onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
         onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
      ): $Utils.JsPromise<TResult1 | TResult2>;
      /**
       * Attaches a callback for only the rejection of the Promise.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of the callback.
       */
      catch<TResult = never>(
         onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
      ): $Utils.JsPromise<T | TResult>;
      /**
       * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
       * resolved value cannot be modified from the callback.
       * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
       * @returns A Promise for the completion of the callback.
       */
      finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
   }

   /**
    * Fields of the Project model
    */
   interface ProjectFieldRefs {
      readonly id: FieldRef<'Project', 'String'>;
      readonly name: FieldRef<'Project', 'String'>;
      readonly description: FieldRef<'Project', 'String'>;
      readonly color: FieldRef<'Project', 'String'>;
      readonly identifier: FieldRef<'Project', 'String'>;
      readonly icon: FieldRef<'Project', 'String'>;
      readonly percentComplete: FieldRef<'Project', 'Int'>;
      readonly startDate: FieldRef<'Project', 'DateTime'>;
      readonly health: FieldRef<'Project', 'ProjectHealth'>;
      readonly leadId: FieldRef<'Project', 'String'>;
      readonly createdAt: FieldRef<'Project', 'DateTime'>;
      readonly updatedAt: FieldRef<'Project', 'DateTime'>;
   }

   // Custom InputTypes
   /**
    * Project findUnique
    */
   export type ProjectFindUniqueArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Project
       */
      select?: ProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Project
       */
      omit?: ProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ProjectInclude<ExtArgs> | null;
      /**
       * Filter, which Project to fetch.
       */
      where: ProjectWhereUniqueInput;
   };

   /**
    * Project findUniqueOrThrow
    */
   export type ProjectFindUniqueOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Project
       */
      select?: ProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Project
       */
      omit?: ProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ProjectInclude<ExtArgs> | null;
      /**
       * Filter, which Project to fetch.
       */
      where: ProjectWhereUniqueInput;
   };

   /**
    * Project findFirst
    */
   export type ProjectFindFirstArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Project
       */
      select?: ProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Project
       */
      omit?: ProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ProjectInclude<ExtArgs> | null;
      /**
       * Filter, which Project to fetch.
       */
      where?: ProjectWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Projects to fetch.
       */
      orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for Projects.
       */
      cursor?: ProjectWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Projects from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Projects.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of Projects.
       */
      distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[];
   };

   /**
    * Project findFirstOrThrow
    */
   export type ProjectFindFirstOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Project
       */
      select?: ProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Project
       */
      omit?: ProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ProjectInclude<ExtArgs> | null;
      /**
       * Filter, which Project to fetch.
       */
      where?: ProjectWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Projects to fetch.
       */
      orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for Projects.
       */
      cursor?: ProjectWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Projects from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Projects.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of Projects.
       */
      distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[];
   };

   /**
    * Project findMany
    */
   export type ProjectFindManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Project
       */
      select?: ProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Project
       */
      omit?: ProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ProjectInclude<ExtArgs> | null;
      /**
       * Filter, which Projects to fetch.
       */
      where?: ProjectWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Projects to fetch.
       */
      orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Projects.
       */
      cursor?: ProjectWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Projects from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Projects.
       */
      skip?: number;
      distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[];
   };

   /**
    * Project create
    */
   export type ProjectCreateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Project
       */
      select?: ProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Project
       */
      omit?: ProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ProjectInclude<ExtArgs> | null;
      /**
       * The data needed to create a Project.
       */
      data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>;
   };

   /**
    * Project createMany
    */
   export type ProjectCreateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to create many Projects.
       */
      data: ProjectCreateManyInput | ProjectCreateManyInput[];
   };

   /**
    * Project createManyAndReturn
    */
   export type ProjectCreateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Project
       */
      select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the Project
       */
      omit?: ProjectOmit<ExtArgs> | null;
      /**
       * The data used to create many Projects.
       */
      data: ProjectCreateManyInput | ProjectCreateManyInput[];
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null;
   };

   /**
    * Project update
    */
   export type ProjectUpdateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Project
       */
      select?: ProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Project
       */
      omit?: ProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ProjectInclude<ExtArgs> | null;
      /**
       * The data needed to update a Project.
       */
      data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>;
      /**
       * Choose, which Project to update.
       */
      where: ProjectWhereUniqueInput;
   };

   /**
    * Project updateMany
    */
   export type ProjectUpdateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to update Projects.
       */
      data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>;
      /**
       * Filter which Projects to update
       */
      where?: ProjectWhereInput;
      /**
       * Limit how many Projects to update.
       */
      limit?: number;
   };

   /**
    * Project updateManyAndReturn
    */
   export type ProjectUpdateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Project
       */
      select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the Project
       */
      omit?: ProjectOmit<ExtArgs> | null;
      /**
       * The data used to update Projects.
       */
      data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>;
      /**
       * Filter which Projects to update
       */
      where?: ProjectWhereInput;
      /**
       * Limit how many Projects to update.
       */
      limit?: number;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null;
   };

   /**
    * Project upsert
    */
   export type ProjectUpsertArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Project
       */
      select?: ProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Project
       */
      omit?: ProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ProjectInclude<ExtArgs> | null;
      /**
       * The filter to search for the Project to update in case it exists.
       */
      where: ProjectWhereUniqueInput;
      /**
       * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
       */
      create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>;
      /**
       * In case the Project was found with the provided `where` argument, update it with this data.
       */
      update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>;
   };

   /**
    * Project delete
    */
   export type ProjectDeleteArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Project
       */
      select?: ProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Project
       */
      omit?: ProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ProjectInclude<ExtArgs> | null;
      /**
       * Filter which Project to delete.
       */
      where: ProjectWhereUniqueInput;
   };

   /**
    * Project deleteMany
    */
   export type ProjectDeleteManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which Projects to delete
       */
      where?: ProjectWhereInput;
      /**
       * Limit how many Projects to delete.
       */
      limit?: number;
   };

   /**
    * Project.issues
    */
   export type Project$issuesArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Issue
       */
      select?: IssueSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Issue
       */
      omit?: IssueOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueInclude<ExtArgs> | null;
      where?: IssueWhereInput;
      orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[];
      cursor?: IssueWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[];
   };

   /**
    * Project.lead
    */
   export type Project$leadArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
      where?: UserWhereInput;
   };

   /**
    * Project.teams
    */
   export type Project$teamsArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamProject
       */
      select?: TeamProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamProject
       */
      omit?: TeamProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamProjectInclude<ExtArgs> | null;
      where?: TeamProjectWhereInput;
      orderBy?: TeamProjectOrderByWithRelationInput | TeamProjectOrderByWithRelationInput[];
      cursor?: TeamProjectWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: TeamProjectScalarFieldEnum | TeamProjectScalarFieldEnum[];
   };

   /**
    * Project without action
    */
   export type ProjectDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Project
       */
      select?: ProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Project
       */
      omit?: ProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ProjectInclude<ExtArgs> | null;
   };

   /**
    * Model Label
    */

   export type AggregateLabel = {
      _count: LabelCountAggregateOutputType | null;
      _min: LabelMinAggregateOutputType | null;
      _max: LabelMaxAggregateOutputType | null;
   };

   export type LabelMinAggregateOutputType = {
      id: string | null;
      name: string | null;
      color: string | null;
      description: string | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type LabelMaxAggregateOutputType = {
      id: string | null;
      name: string | null;
      color: string | null;
      description: string | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type LabelCountAggregateOutputType = {
      id: number;
      name: number;
      color: number;
      description: number;
      createdAt: number;
      updatedAt: number;
      _all: number;
   };

   export type LabelMinAggregateInputType = {
      id?: true;
      name?: true;
      color?: true;
      description?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type LabelMaxAggregateInputType = {
      id?: true;
      name?: true;
      color?: true;
      description?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type LabelCountAggregateInputType = {
      id?: true;
      name?: true;
      color?: true;
      description?: true;
      createdAt?: true;
      updatedAt?: true;
      _all?: true;
   };

   export type LabelAggregateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which Label to aggregate.
       */
      where?: LabelWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Labels to fetch.
       */
      orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: LabelWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Labels from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Labels.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned Labels
       **/
      _count?: true | LabelCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: LabelMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: LabelMaxAggregateInputType;
   };

   export type GetLabelAggregateType<T extends LabelAggregateArgs> = {
      [P in keyof T & keyof AggregateLabel]: P extends '_count' | 'count'
         ? T[P] extends true
            ? number
            : GetScalarType<T[P], AggregateLabel[P]>
         : GetScalarType<T[P], AggregateLabel[P]>;
   };

   export type LabelGroupByArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: LabelWhereInput;
      orderBy?: LabelOrderByWithAggregationInput | LabelOrderByWithAggregationInput[];
      by: LabelScalarFieldEnum[] | LabelScalarFieldEnum;
      having?: LabelScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: LabelCountAggregateInputType | true;
      _min?: LabelMinAggregateInputType;
      _max?: LabelMaxAggregateInputType;
   };

   export type LabelGroupByOutputType = {
      id: string;
      name: string;
      color: string;
      description: string | null;
      createdAt: Date;
      updatedAt: Date;
      _count: LabelCountAggregateOutputType | null;
      _min: LabelMinAggregateOutputType | null;
      _max: LabelMaxAggregateOutputType | null;
   };

   type GetLabelGroupByPayload<T extends LabelGroupByArgs> = Prisma.PrismaPromise<
      Array<
         PickEnumerable<LabelGroupByOutputType, T['by']> & {
            [P in keyof T & keyof LabelGroupByOutputType]: P extends '_count'
               ? T[P] extends boolean
                  ? number
                  : GetScalarType<T[P], LabelGroupByOutputType[P]>
               : GetScalarType<T[P], LabelGroupByOutputType[P]>;
         }
      >
   >;

   export type LabelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetSelect<
         {
            id?: boolean;
            name?: boolean;
            color?: boolean;
            description?: boolean;
            createdAt?: boolean;
            updatedAt?: boolean;
            issues?: boolean | Label$issuesArgs<ExtArgs>;
            _count?: boolean | LabelCountOutputTypeDefaultArgs<ExtArgs>;
         },
         ExtArgs['result']['label']
      >;

   export type LabelSelectCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         name?: boolean;
         color?: boolean;
         description?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
      },
      ExtArgs['result']['label']
   >;

   export type LabelSelectUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         name?: boolean;
         color?: boolean;
         description?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
      },
      ExtArgs['result']['label']
   >;

   export type LabelSelectScalar = {
      id?: boolean;
      name?: boolean;
      color?: boolean;
      description?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
   };

   export type LabelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetOmit<
         'id' | 'name' | 'color' | 'description' | 'createdAt' | 'updatedAt',
         ExtArgs['result']['label']
      >;
   export type LabelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
      issues?: boolean | Label$issuesArgs<ExtArgs>;
      _count?: boolean | LabelCountOutputTypeDefaultArgs<ExtArgs>;
   };
   export type LabelIncludeCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {};
   export type LabelIncludeUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {};

   export type $LabelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
      name: 'Label';
      objects: {
         issues: Prisma.$IssueLabelPayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
         {
            id: string;
            name: string;
            color: string;
            description: string | null;
            createdAt: Date;
            updatedAt: Date;
         },
         ExtArgs['result']['label']
      >;
      composites: {};
   };

   type LabelGetPayload<S extends boolean | null | undefined | LabelDefaultArgs> =
      $Result.GetResult<Prisma.$LabelPayload, S>;

   type LabelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
      LabelFindManyArgs,
      'select' | 'include' | 'distinct' | 'omit'
   > & {
      select?: LabelCountAggregateInputType | true;
   };

   export interface LabelDelegate<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > {
      [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Label']; meta: { name: 'Label' } };
      /**
       * Find zero or one Label that matches the filter.
       * @param {LabelFindUniqueArgs} args - Arguments to find a Label
       * @example
       * // Get one Label
       * const label = await prisma.label.findUnique({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUnique<T extends LabelFindUniqueArgs>(
         args: SelectSubset<T, LabelFindUniqueArgs<ExtArgs>>
      ): Prisma__LabelClient<
         $Result.GetResult<
            Prisma.$LabelPayload<ExtArgs>,
            T,
            'findUnique',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find one Label that matches the filter or throw an error with `error.code='P2025'`
       * if no matches were found.
       * @param {LabelFindUniqueOrThrowArgs} args - Arguments to find a Label
       * @example
       * // Get one Label
       * const label = await prisma.label.findUniqueOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUniqueOrThrow<T extends LabelFindUniqueOrThrowArgs>(
         args: SelectSubset<T, LabelFindUniqueOrThrowArgs<ExtArgs>>
      ): Prisma__LabelClient<
         $Result.GetResult<
            Prisma.$LabelPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first Label that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {LabelFindFirstArgs} args - Arguments to find a Label
       * @example
       * // Get one Label
       * const label = await prisma.label.findFirst({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirst<T extends LabelFindFirstArgs>(
         args?: SelectSubset<T, LabelFindFirstArgs<ExtArgs>>
      ): Prisma__LabelClient<
         $Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first Label that matches the filter or
       * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {LabelFindFirstOrThrowArgs} args - Arguments to find a Label
       * @example
       * // Get one Label
       * const label = await prisma.label.findFirstOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirstOrThrow<T extends LabelFindFirstOrThrowArgs>(
         args?: SelectSubset<T, LabelFindFirstOrThrowArgs<ExtArgs>>
      ): Prisma__LabelClient<
         $Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find zero or more Labels that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {LabelFindManyArgs} args - Arguments to filter and select certain fields only.
       * @example
       * // Get all Labels
       * const labels = await prisma.label.findMany()
       *
       * // Get first 10 Labels
       * const labels = await prisma.label.findMany({ take: 10 })
       *
       * // Only select the `id`
       * const labelWithIdOnly = await prisma.label.findMany({ select: { id: true } })
       *
       */
      findMany<T extends LabelFindManyArgs>(
         args?: SelectSubset<T, LabelFindManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      >;

      /**
       * Create a Label.
       * @param {LabelCreateArgs} args - Arguments to create a Label.
       * @example
       * // Create one Label
       * const Label = await prisma.label.create({
       *   data: {
       *     // ... data to create a Label
       *   }
       * })
       *
       */
      create<T extends LabelCreateArgs>(
         args: SelectSubset<T, LabelCreateArgs<ExtArgs>>
      ): Prisma__LabelClient<
         $Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Create many Labels.
       * @param {LabelCreateManyArgs} args - Arguments to create many Labels.
       * @example
       * // Create many Labels
       * const label = await prisma.label.createMany({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       */
      createMany<T extends LabelCreateManyArgs>(
         args?: SelectSubset<T, LabelCreateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Create many Labels and returns the data saved in the database.
       * @param {LabelCreateManyAndReturnArgs} args - Arguments to create many Labels.
       * @example
       * // Create many Labels
       * const label = await prisma.label.createManyAndReturn({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Create many Labels and only return the `id`
       * const labelWithIdOnly = await prisma.label.createManyAndReturn({
       *   select: { id: true },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      createManyAndReturn<T extends LabelCreateManyAndReturnArgs>(
         args?: SelectSubset<T, LabelCreateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$LabelPayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Delete a Label.
       * @param {LabelDeleteArgs} args - Arguments to delete one Label.
       * @example
       * // Delete one Label
       * const Label = await prisma.label.delete({
       *   where: {
       *     // ... filter to delete one Label
       *   }
       * })
       *
       */
      delete<T extends LabelDeleteArgs>(
         args: SelectSubset<T, LabelDeleteArgs<ExtArgs>>
      ): Prisma__LabelClient<
         $Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Update one Label.
       * @param {LabelUpdateArgs} args - Arguments to update one Label.
       * @example
       * // Update one Label
       * const label = await prisma.label.update({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      update<T extends LabelUpdateArgs>(
         args: SelectSubset<T, LabelUpdateArgs<ExtArgs>>
      ): Prisma__LabelClient<
         $Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Delete zero or more Labels.
       * @param {LabelDeleteManyArgs} args - Arguments to filter Labels to delete.
       * @example
       * // Delete a few Labels
       * const { count } = await prisma.label.deleteMany({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       *
       */
      deleteMany<T extends LabelDeleteManyArgs>(
         args?: SelectSubset<T, LabelDeleteManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more Labels.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {LabelUpdateManyArgs} args - Arguments to update one or more rows.
       * @example
       * // Update many Labels
       * const label = await prisma.label.updateMany({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      updateMany<T extends LabelUpdateManyArgs>(
         args: SelectSubset<T, LabelUpdateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more Labels and returns the data updated in the database.
       * @param {LabelUpdateManyAndReturnArgs} args - Arguments to update many Labels.
       * @example
       * // Update many Labels
       * const label = await prisma.label.updateManyAndReturn({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Update zero or more Labels and only return the `id`
       * const labelWithIdOnly = await prisma.label.updateManyAndReturn({
       *   select: { id: true },
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      updateManyAndReturn<T extends LabelUpdateManyAndReturnArgs>(
         args: SelectSubset<T, LabelUpdateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$LabelPayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Create or update one Label.
       * @param {LabelUpsertArgs} args - Arguments to update or create a Label.
       * @example
       * // Update or create a Label
       * const label = await prisma.label.upsert({
       *   create: {
       *     // ... data to create a Label
       *   },
       *   update: {
       *     // ... in case it already exists, update
       *   },
       *   where: {
       *     // ... the filter for the Label we want to update
       *   }
       * })
       */
      upsert<T extends LabelUpsertArgs>(
         args: SelectSubset<T, LabelUpsertArgs<ExtArgs>>
      ): Prisma__LabelClient<
         $Result.GetResult<Prisma.$LabelPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Count the number of Labels.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {LabelCountArgs} args - Arguments to filter Labels to count.
       * @example
       * // Count the number of Labels
       * const count = await prisma.label.count({
       *   where: {
       *     // ... the filter for the Labels we want to count
       *   }
       * })
       **/
      count<T extends LabelCountArgs>(
         args?: Subset<T, LabelCountArgs>
      ): Prisma.PrismaPromise<
         T extends $Utils.Record<'select', any>
            ? T['select'] extends true
               ? number
               : GetScalarType<T['select'], LabelCountAggregateOutputType>
            : number
      >;

      /**
       * Allows you to perform aggregations operations on a Label.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {LabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
       * @example
       * // Ordered by age ascending
       * // Where email contains prisma.io
       * // Limited to the 10 users
       * const aggregations = await prisma.user.aggregate({
       *   _avg: {
       *     age: true,
       *   },
       *   where: {
       *     email: {
       *       contains: "prisma.io",
       *     },
       *   },
       *   orderBy: {
       *     age: "asc",
       *   },
       *   take: 10,
       * })
       **/
      aggregate<T extends LabelAggregateArgs>(
         args: Subset<T, LabelAggregateArgs>
      ): Prisma.PrismaPromise<GetLabelAggregateType<T>>;

      /**
       * Group by Label.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {LabelGroupByArgs} args - Group by arguments.
       * @example
       * // Group by city, order by createdAt, get count
       * const result = await prisma.user.groupBy({
       *   by: ['city', 'createdAt'],
       *   orderBy: {
       *     createdAt: true
       *   },
       *   _count: {
       *     _all: true
       *   },
       * })
       *
       **/
      groupBy<
         T extends LabelGroupByArgs,
         HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
         OrderByArg extends True extends HasSelectOrTake
            ? { orderBy: LabelGroupByArgs['orderBy'] }
            : { orderBy?: LabelGroupByArgs['orderBy'] },
         OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
         ByFields extends MaybeTupleToUnion<T['by']>,
         ByValid extends Has<ByFields, OrderFields>,
         HavingFields extends GetHavingFields<T['having']>,
         HavingValid extends Has<ByFields, HavingFields>,
         ByEmpty extends T['by'] extends never[] ? True : False,
         InputErrors extends ByEmpty extends True
            ? `Error: "by" must not be empty.`
            : HavingValid extends False
              ? {
                   [P in HavingFields]: P extends ByFields
                      ? never
                      : P extends string
                        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                        : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Keys<T>
                ? 'orderBy' extends Keys<T>
                   ? ByValid extends True
                      ? {}
                      : {
                           [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                        }[OrderFields]
                   : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Keys<T>
                  ? 'orderBy' extends Keys<T>
                     ? ByValid extends True
                        ? {}
                        : {
                             [P in OrderFields]: P extends ByFields
                                ? never
                                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                     : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends True
                    ? {}
                    : {
                         [P in OrderFields]: P extends ByFields
                            ? never
                            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
      >(
         args: SubsetIntersection<T, LabelGroupByArgs, OrderByArg> & InputErrors
      ): {} extends InputErrors ? GetLabelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
      /**
       * Fields of the Label model
       */
      readonly fields: LabelFieldRefs;
   }

   /**
    * The delegate class that acts as a "Promise-like" for Label.
    * Why is this prefixed with `Prisma__`?
    * Because we want to prevent naming conflicts as mentioned in
    * https://github.com/prisma/prisma-client-js/issues/707
    */
   export interface Prisma__LabelClient<
      T,
      Null = never,
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > extends Prisma.PrismaPromise<T> {
      readonly [Symbol.toStringTag]: 'PrismaPromise';
      issues<T extends Label$issuesArgs<ExtArgs> = {}>(
         args?: Subset<T, Label$issuesArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         | $Result.GetResult<Prisma.$IssueLabelPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
         | Null
      >;
      /**
       * Attaches callbacks for the resolution and/or rejection of the Promise.
       * @param onfulfilled The callback to execute when the Promise is resolved.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of which ever callback is executed.
       */
      then<TResult1 = T, TResult2 = never>(
         onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
         onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
      ): $Utils.JsPromise<TResult1 | TResult2>;
      /**
       * Attaches a callback for only the rejection of the Promise.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of the callback.
       */
      catch<TResult = never>(
         onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
      ): $Utils.JsPromise<T | TResult>;
      /**
       * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
       * resolved value cannot be modified from the callback.
       * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
       * @returns A Promise for the completion of the callback.
       */
      finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
   }

   /**
    * Fields of the Label model
    */
   interface LabelFieldRefs {
      readonly id: FieldRef<'Label', 'String'>;
      readonly name: FieldRef<'Label', 'String'>;
      readonly color: FieldRef<'Label', 'String'>;
      readonly description: FieldRef<'Label', 'String'>;
      readonly createdAt: FieldRef<'Label', 'DateTime'>;
      readonly updatedAt: FieldRef<'Label', 'DateTime'>;
   }

   // Custom InputTypes
   /**
    * Label findUnique
    */
   export type LabelFindUniqueArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Label
       */
      select?: LabelSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Label
       */
      omit?: LabelOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: LabelInclude<ExtArgs> | null;
      /**
       * Filter, which Label to fetch.
       */
      where: LabelWhereUniqueInput;
   };

   /**
    * Label findUniqueOrThrow
    */
   export type LabelFindUniqueOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Label
       */
      select?: LabelSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Label
       */
      omit?: LabelOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: LabelInclude<ExtArgs> | null;
      /**
       * Filter, which Label to fetch.
       */
      where: LabelWhereUniqueInput;
   };

   /**
    * Label findFirst
    */
   export type LabelFindFirstArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Label
       */
      select?: LabelSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Label
       */
      omit?: LabelOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: LabelInclude<ExtArgs> | null;
      /**
       * Filter, which Label to fetch.
       */
      where?: LabelWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Labels to fetch.
       */
      orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for Labels.
       */
      cursor?: LabelWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Labels from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Labels.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of Labels.
       */
      distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[];
   };

   /**
    * Label findFirstOrThrow
    */
   export type LabelFindFirstOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Label
       */
      select?: LabelSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Label
       */
      omit?: LabelOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: LabelInclude<ExtArgs> | null;
      /**
       * Filter, which Label to fetch.
       */
      where?: LabelWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Labels to fetch.
       */
      orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for Labels.
       */
      cursor?: LabelWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Labels from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Labels.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of Labels.
       */
      distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[];
   };

   /**
    * Label findMany
    */
   export type LabelFindManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Label
       */
      select?: LabelSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Label
       */
      omit?: LabelOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: LabelInclude<ExtArgs> | null;
      /**
       * Filter, which Labels to fetch.
       */
      where?: LabelWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Labels to fetch.
       */
      orderBy?: LabelOrderByWithRelationInput | LabelOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Labels.
       */
      cursor?: LabelWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Labels from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Labels.
       */
      skip?: number;
      distinct?: LabelScalarFieldEnum | LabelScalarFieldEnum[];
   };

   /**
    * Label create
    */
   export type LabelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Label
          */
         select?: LabelSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Label
          */
         omit?: LabelOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: LabelInclude<ExtArgs> | null;
         /**
          * The data needed to create a Label.
          */
         data: XOR<LabelCreateInput, LabelUncheckedCreateInput>;
      };

   /**
    * Label createMany
    */
   export type LabelCreateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to create many Labels.
       */
      data: LabelCreateManyInput | LabelCreateManyInput[];
   };

   /**
    * Label createManyAndReturn
    */
   export type LabelCreateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Label
       */
      select?: LabelSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the Label
       */
      omit?: LabelOmit<ExtArgs> | null;
      /**
       * The data used to create many Labels.
       */
      data: LabelCreateManyInput | LabelCreateManyInput[];
   };

   /**
    * Label update
    */
   export type LabelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Label
          */
         select?: LabelSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Label
          */
         omit?: LabelOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: LabelInclude<ExtArgs> | null;
         /**
          * The data needed to update a Label.
          */
         data: XOR<LabelUpdateInput, LabelUncheckedUpdateInput>;
         /**
          * Choose, which Label to update.
          */
         where: LabelWhereUniqueInput;
      };

   /**
    * Label updateMany
    */
   export type LabelUpdateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to update Labels.
       */
      data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyInput>;
      /**
       * Filter which Labels to update
       */
      where?: LabelWhereInput;
      /**
       * Limit how many Labels to update.
       */
      limit?: number;
   };

   /**
    * Label updateManyAndReturn
    */
   export type LabelUpdateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Label
       */
      select?: LabelSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the Label
       */
      omit?: LabelOmit<ExtArgs> | null;
      /**
       * The data used to update Labels.
       */
      data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyInput>;
      /**
       * Filter which Labels to update
       */
      where?: LabelWhereInput;
      /**
       * Limit how many Labels to update.
       */
      limit?: number;
   };

   /**
    * Label upsert
    */
   export type LabelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Label
          */
         select?: LabelSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Label
          */
         omit?: LabelOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: LabelInclude<ExtArgs> | null;
         /**
          * The filter to search for the Label to update in case it exists.
          */
         where: LabelWhereUniqueInput;
         /**
          * In case the Label found by the `where` argument doesn't exist, create a new Label with this data.
          */
         create: XOR<LabelCreateInput, LabelUncheckedCreateInput>;
         /**
          * In case the Label was found with the provided `where` argument, update it with this data.
          */
         update: XOR<LabelUpdateInput, LabelUncheckedUpdateInput>;
      };

   /**
    * Label delete
    */
   export type LabelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Label
          */
         select?: LabelSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Label
          */
         omit?: LabelOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: LabelInclude<ExtArgs> | null;
         /**
          * Filter which Label to delete.
          */
         where: LabelWhereUniqueInput;
      };

   /**
    * Label deleteMany
    */
   export type LabelDeleteManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which Labels to delete
       */
      where?: LabelWhereInput;
      /**
       * Limit how many Labels to delete.
       */
      limit?: number;
   };

   /**
    * Label.issues
    */
   export type Label$issuesArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueLabel
       */
      select?: IssueLabelSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueLabel
       */
      omit?: IssueLabelOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueLabelInclude<ExtArgs> | null;
      where?: IssueLabelWhereInput;
      orderBy?: IssueLabelOrderByWithRelationInput | IssueLabelOrderByWithRelationInput[];
      cursor?: IssueLabelWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: IssueLabelScalarFieldEnum | IssueLabelScalarFieldEnum[];
   };

   /**
    * Label without action
    */
   export type LabelDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Label
       */
      select?: LabelSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Label
       */
      omit?: LabelOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: LabelInclude<ExtArgs> | null;
   };

   /**
    * Model IssueStatus
    */

   export type AggregateIssueStatus = {
      _count: IssueStatusCountAggregateOutputType | null;
      _min: IssueStatusMinAggregateOutputType | null;
      _max: IssueStatusMaxAggregateOutputType | null;
   };

   export type IssueStatusMinAggregateOutputType = {
      id: string | null;
      name: string | null;
      color: string | null;
      iconName: string | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type IssueStatusMaxAggregateOutputType = {
      id: string | null;
      name: string | null;
      color: string | null;
      iconName: string | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type IssueStatusCountAggregateOutputType = {
      id: number;
      name: number;
      color: number;
      iconName: number;
      createdAt: number;
      updatedAt: number;
      _all: number;
   };

   export type IssueStatusMinAggregateInputType = {
      id?: true;
      name?: true;
      color?: true;
      iconName?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type IssueStatusMaxAggregateInputType = {
      id?: true;
      name?: true;
      color?: true;
      iconName?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type IssueStatusCountAggregateInputType = {
      id?: true;
      name?: true;
      color?: true;
      iconName?: true;
      createdAt?: true;
      updatedAt?: true;
      _all?: true;
   };

   export type IssueStatusAggregateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which IssueStatus to aggregate.
       */
      where?: IssueStatusWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of IssueStatuses to fetch.
       */
      orderBy?: IssueStatusOrderByWithRelationInput | IssueStatusOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: IssueStatusWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` IssueStatuses from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` IssueStatuses.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned IssueStatuses
       **/
      _count?: true | IssueStatusCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: IssueStatusMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: IssueStatusMaxAggregateInputType;
   };

   export type GetIssueStatusAggregateType<T extends IssueStatusAggregateArgs> = {
      [P in keyof T & keyof AggregateIssueStatus]: P extends '_count' | 'count'
         ? T[P] extends true
            ? number
            : GetScalarType<T[P], AggregateIssueStatus[P]>
         : GetScalarType<T[P], AggregateIssueStatus[P]>;
   };

   export type IssueStatusGroupByArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: IssueStatusWhereInput;
      orderBy?: IssueStatusOrderByWithAggregationInput | IssueStatusOrderByWithAggregationInput[];
      by: IssueStatusScalarFieldEnum[] | IssueStatusScalarFieldEnum;
      having?: IssueStatusScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: IssueStatusCountAggregateInputType | true;
      _min?: IssueStatusMinAggregateInputType;
      _max?: IssueStatusMaxAggregateInputType;
   };

   export type IssueStatusGroupByOutputType = {
      id: string;
      name: string;
      color: string;
      iconName: string;
      createdAt: Date;
      updatedAt: Date;
      _count: IssueStatusCountAggregateOutputType | null;
      _min: IssueStatusMinAggregateOutputType | null;
      _max: IssueStatusMaxAggregateOutputType | null;
   };

   type GetIssueStatusGroupByPayload<T extends IssueStatusGroupByArgs> = Prisma.PrismaPromise<
      Array<
         PickEnumerable<IssueStatusGroupByOutputType, T['by']> & {
            [P in keyof T & keyof IssueStatusGroupByOutputType]: P extends '_count'
               ? T[P] extends boolean
                  ? number
                  : GetScalarType<T[P], IssueStatusGroupByOutputType[P]>
               : GetScalarType<T[P], IssueStatusGroupByOutputType[P]>;
         }
      >
   >;

   export type IssueStatusSelect<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         name?: boolean;
         color?: boolean;
         iconName?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
         issues?: boolean | IssueStatus$issuesArgs<ExtArgs>;
         _count?: boolean | IssueStatusCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['issueStatus']
   >;

   export type IssueStatusSelectCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         name?: boolean;
         color?: boolean;
         iconName?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
      },
      ExtArgs['result']['issueStatus']
   >;

   export type IssueStatusSelectUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         name?: boolean;
         color?: boolean;
         iconName?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
      },
      ExtArgs['result']['issueStatus']
   >;

   export type IssueStatusSelectScalar = {
      id?: boolean;
      name?: boolean;
      color?: boolean;
      iconName?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
   };

   export type IssueStatusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetOmit<
         'id' | 'name' | 'color' | 'iconName' | 'createdAt' | 'updatedAt',
         ExtArgs['result']['issueStatus']
      >;
   export type IssueStatusInclude<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      issues?: boolean | IssueStatus$issuesArgs<ExtArgs>;
      _count?: boolean | IssueStatusCountOutputTypeDefaultArgs<ExtArgs>;
   };
   export type IssueStatusIncludeCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {};
   export type IssueStatusIncludeUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {};

   export type $IssueStatusPayload<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      name: 'IssueStatus';
      objects: {
         issues: Prisma.$IssuePayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
         {
            id: string;
            name: string;
            color: string;
            iconName: string;
            createdAt: Date;
            updatedAt: Date;
         },
         ExtArgs['result']['issueStatus']
      >;
      composites: {};
   };

   type IssueStatusGetPayload<S extends boolean | null | undefined | IssueStatusDefaultArgs> =
      $Result.GetResult<Prisma.$IssueStatusPayload, S>;

   type IssueStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      Omit<IssueStatusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
         select?: IssueStatusCountAggregateInputType | true;
      };

   export interface IssueStatusDelegate<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > {
      [K: symbol]: {
         types: Prisma.TypeMap<ExtArgs>['model']['IssueStatus'];
         meta: { name: 'IssueStatus' };
      };
      /**
       * Find zero or one IssueStatus that matches the filter.
       * @param {IssueStatusFindUniqueArgs} args - Arguments to find a IssueStatus
       * @example
       * // Get one IssueStatus
       * const issueStatus = await prisma.issueStatus.findUnique({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUnique<T extends IssueStatusFindUniqueArgs>(
         args: SelectSubset<T, IssueStatusFindUniqueArgs<ExtArgs>>
      ): Prisma__IssueStatusClient<
         $Result.GetResult<
            Prisma.$IssueStatusPayload<ExtArgs>,
            T,
            'findUnique',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find one IssueStatus that matches the filter or throw an error with `error.code='P2025'`
       * if no matches were found.
       * @param {IssueStatusFindUniqueOrThrowArgs} args - Arguments to find a IssueStatus
       * @example
       * // Get one IssueStatus
       * const issueStatus = await prisma.issueStatus.findUniqueOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUniqueOrThrow<T extends IssueStatusFindUniqueOrThrowArgs>(
         args: SelectSubset<T, IssueStatusFindUniqueOrThrowArgs<ExtArgs>>
      ): Prisma__IssueStatusClient<
         $Result.GetResult<
            Prisma.$IssueStatusPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first IssueStatus that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueStatusFindFirstArgs} args - Arguments to find a IssueStatus
       * @example
       * // Get one IssueStatus
       * const issueStatus = await prisma.issueStatus.findFirst({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirst<T extends IssueStatusFindFirstArgs>(
         args?: SelectSubset<T, IssueStatusFindFirstArgs<ExtArgs>>
      ): Prisma__IssueStatusClient<
         $Result.GetResult<
            Prisma.$IssueStatusPayload<ExtArgs>,
            T,
            'findFirst',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first IssueStatus that matches the filter or
       * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueStatusFindFirstOrThrowArgs} args - Arguments to find a IssueStatus
       * @example
       * // Get one IssueStatus
       * const issueStatus = await prisma.issueStatus.findFirstOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirstOrThrow<T extends IssueStatusFindFirstOrThrowArgs>(
         args?: SelectSubset<T, IssueStatusFindFirstOrThrowArgs<ExtArgs>>
      ): Prisma__IssueStatusClient<
         $Result.GetResult<
            Prisma.$IssueStatusPayload<ExtArgs>,
            T,
            'findFirstOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find zero or more IssueStatuses that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueStatusFindManyArgs} args - Arguments to filter and select certain fields only.
       * @example
       * // Get all IssueStatuses
       * const issueStatuses = await prisma.issueStatus.findMany()
       *
       * // Get first 10 IssueStatuses
       * const issueStatuses = await prisma.issueStatus.findMany({ take: 10 })
       *
       * // Only select the `id`
       * const issueStatusWithIdOnly = await prisma.issueStatus.findMany({ select: { id: true } })
       *
       */
      findMany<T extends IssueStatusFindManyArgs>(
         args?: SelectSubset<T, IssueStatusFindManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$IssueStatusPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      >;

      /**
       * Create a IssueStatus.
       * @param {IssueStatusCreateArgs} args - Arguments to create a IssueStatus.
       * @example
       * // Create one IssueStatus
       * const IssueStatus = await prisma.issueStatus.create({
       *   data: {
       *     // ... data to create a IssueStatus
       *   }
       * })
       *
       */
      create<T extends IssueStatusCreateArgs>(
         args: SelectSubset<T, IssueStatusCreateArgs<ExtArgs>>
      ): Prisma__IssueStatusClient<
         $Result.GetResult<Prisma.$IssueStatusPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Create many IssueStatuses.
       * @param {IssueStatusCreateManyArgs} args - Arguments to create many IssueStatuses.
       * @example
       * // Create many IssueStatuses
       * const issueStatus = await prisma.issueStatus.createMany({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       */
      createMany<T extends IssueStatusCreateManyArgs>(
         args?: SelectSubset<T, IssueStatusCreateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Create many IssueStatuses and returns the data saved in the database.
       * @param {IssueStatusCreateManyAndReturnArgs} args - Arguments to create many IssueStatuses.
       * @example
       * // Create many IssueStatuses
       * const issueStatus = await prisma.issueStatus.createManyAndReturn({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Create many IssueStatuses and only return the `id`
       * const issueStatusWithIdOnly = await prisma.issueStatus.createManyAndReturn({
       *   select: { id: true },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      createManyAndReturn<T extends IssueStatusCreateManyAndReturnArgs>(
         args?: SelectSubset<T, IssueStatusCreateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$IssueStatusPayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Delete a IssueStatus.
       * @param {IssueStatusDeleteArgs} args - Arguments to delete one IssueStatus.
       * @example
       * // Delete one IssueStatus
       * const IssueStatus = await prisma.issueStatus.delete({
       *   where: {
       *     // ... filter to delete one IssueStatus
       *   }
       * })
       *
       */
      delete<T extends IssueStatusDeleteArgs>(
         args: SelectSubset<T, IssueStatusDeleteArgs<ExtArgs>>
      ): Prisma__IssueStatusClient<
         $Result.GetResult<Prisma.$IssueStatusPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Update one IssueStatus.
       * @param {IssueStatusUpdateArgs} args - Arguments to update one IssueStatus.
       * @example
       * // Update one IssueStatus
       * const issueStatus = await prisma.issueStatus.update({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      update<T extends IssueStatusUpdateArgs>(
         args: SelectSubset<T, IssueStatusUpdateArgs<ExtArgs>>
      ): Prisma__IssueStatusClient<
         $Result.GetResult<Prisma.$IssueStatusPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Delete zero or more IssueStatuses.
       * @param {IssueStatusDeleteManyArgs} args - Arguments to filter IssueStatuses to delete.
       * @example
       * // Delete a few IssueStatuses
       * const { count } = await prisma.issueStatus.deleteMany({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       *
       */
      deleteMany<T extends IssueStatusDeleteManyArgs>(
         args?: SelectSubset<T, IssueStatusDeleteManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more IssueStatuses.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueStatusUpdateManyArgs} args - Arguments to update one or more rows.
       * @example
       * // Update many IssueStatuses
       * const issueStatus = await prisma.issueStatus.updateMany({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      updateMany<T extends IssueStatusUpdateManyArgs>(
         args: SelectSubset<T, IssueStatusUpdateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more IssueStatuses and returns the data updated in the database.
       * @param {IssueStatusUpdateManyAndReturnArgs} args - Arguments to update many IssueStatuses.
       * @example
       * // Update many IssueStatuses
       * const issueStatus = await prisma.issueStatus.updateManyAndReturn({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Update zero or more IssueStatuses and only return the `id`
       * const issueStatusWithIdOnly = await prisma.issueStatus.updateManyAndReturn({
       *   select: { id: true },
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      updateManyAndReturn<T extends IssueStatusUpdateManyAndReturnArgs>(
         args: SelectSubset<T, IssueStatusUpdateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$IssueStatusPayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Create or update one IssueStatus.
       * @param {IssueStatusUpsertArgs} args - Arguments to update or create a IssueStatus.
       * @example
       * // Update or create a IssueStatus
       * const issueStatus = await prisma.issueStatus.upsert({
       *   create: {
       *     // ... data to create a IssueStatus
       *   },
       *   update: {
       *     // ... in case it already exists, update
       *   },
       *   where: {
       *     // ... the filter for the IssueStatus we want to update
       *   }
       * })
       */
      upsert<T extends IssueStatusUpsertArgs>(
         args: SelectSubset<T, IssueStatusUpsertArgs<ExtArgs>>
      ): Prisma__IssueStatusClient<
         $Result.GetResult<Prisma.$IssueStatusPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Count the number of IssueStatuses.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueStatusCountArgs} args - Arguments to filter IssueStatuses to count.
       * @example
       * // Count the number of IssueStatuses
       * const count = await prisma.issueStatus.count({
       *   where: {
       *     // ... the filter for the IssueStatuses we want to count
       *   }
       * })
       **/
      count<T extends IssueStatusCountArgs>(
         args?: Subset<T, IssueStatusCountArgs>
      ): Prisma.PrismaPromise<
         T extends $Utils.Record<'select', any>
            ? T['select'] extends true
               ? number
               : GetScalarType<T['select'], IssueStatusCountAggregateOutputType>
            : number
      >;

      /**
       * Allows you to perform aggregations operations on a IssueStatus.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
       * @example
       * // Ordered by age ascending
       * // Where email contains prisma.io
       * // Limited to the 10 users
       * const aggregations = await prisma.user.aggregate({
       *   _avg: {
       *     age: true,
       *   },
       *   where: {
       *     email: {
       *       contains: "prisma.io",
       *     },
       *   },
       *   orderBy: {
       *     age: "asc",
       *   },
       *   take: 10,
       * })
       **/
      aggregate<T extends IssueStatusAggregateArgs>(
         args: Subset<T, IssueStatusAggregateArgs>
      ): Prisma.PrismaPromise<GetIssueStatusAggregateType<T>>;

      /**
       * Group by IssueStatus.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueStatusGroupByArgs} args - Group by arguments.
       * @example
       * // Group by city, order by createdAt, get count
       * const result = await prisma.user.groupBy({
       *   by: ['city', 'createdAt'],
       *   orderBy: {
       *     createdAt: true
       *   },
       *   _count: {
       *     _all: true
       *   },
       * })
       *
       **/
      groupBy<
         T extends IssueStatusGroupByArgs,
         HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
         OrderByArg extends True extends HasSelectOrTake
            ? { orderBy: IssueStatusGroupByArgs['orderBy'] }
            : { orderBy?: IssueStatusGroupByArgs['orderBy'] },
         OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
         ByFields extends MaybeTupleToUnion<T['by']>,
         ByValid extends Has<ByFields, OrderFields>,
         HavingFields extends GetHavingFields<T['having']>,
         HavingValid extends Has<ByFields, HavingFields>,
         ByEmpty extends T['by'] extends never[] ? True : False,
         InputErrors extends ByEmpty extends True
            ? `Error: "by" must not be empty.`
            : HavingValid extends False
              ? {
                   [P in HavingFields]: P extends ByFields
                      ? never
                      : P extends string
                        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                        : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Keys<T>
                ? 'orderBy' extends Keys<T>
                   ? ByValid extends True
                      ? {}
                      : {
                           [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                        }[OrderFields]
                   : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Keys<T>
                  ? 'orderBy' extends Keys<T>
                     ? ByValid extends True
                        ? {}
                        : {
                             [P in OrderFields]: P extends ByFields
                                ? never
                                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                     : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends True
                    ? {}
                    : {
                         [P in OrderFields]: P extends ByFields
                            ? never
                            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
      >(
         args: SubsetIntersection<T, IssueStatusGroupByArgs, OrderByArg> & InputErrors
      ): {} extends InputErrors
         ? GetIssueStatusGroupByPayload<T>
         : Prisma.PrismaPromise<InputErrors>;
      /**
       * Fields of the IssueStatus model
       */
      readonly fields: IssueStatusFieldRefs;
   }

   /**
    * The delegate class that acts as a "Promise-like" for IssueStatus.
    * Why is this prefixed with `Prisma__`?
    * Because we want to prevent naming conflicts as mentioned in
    * https://github.com/prisma/prisma-client-js/issues/707
    */
   export interface Prisma__IssueStatusClient<
      T,
      Null = never,
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > extends Prisma.PrismaPromise<T> {
      readonly [Symbol.toStringTag]: 'PrismaPromise';
      issues<T extends IssueStatus$issuesArgs<ExtArgs> = {}>(
         args?: Subset<T, IssueStatus$issuesArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
      >;
      /**
       * Attaches callbacks for the resolution and/or rejection of the Promise.
       * @param onfulfilled The callback to execute when the Promise is resolved.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of which ever callback is executed.
       */
      then<TResult1 = T, TResult2 = never>(
         onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
         onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
      ): $Utils.JsPromise<TResult1 | TResult2>;
      /**
       * Attaches a callback for only the rejection of the Promise.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of the callback.
       */
      catch<TResult = never>(
         onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
      ): $Utils.JsPromise<T | TResult>;
      /**
       * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
       * resolved value cannot be modified from the callback.
       * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
       * @returns A Promise for the completion of the callback.
       */
      finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
   }

   /**
    * Fields of the IssueStatus model
    */
   interface IssueStatusFieldRefs {
      readonly id: FieldRef<'IssueStatus', 'String'>;
      readonly name: FieldRef<'IssueStatus', 'String'>;
      readonly color: FieldRef<'IssueStatus', 'String'>;
      readonly iconName: FieldRef<'IssueStatus', 'String'>;
      readonly createdAt: FieldRef<'IssueStatus', 'DateTime'>;
      readonly updatedAt: FieldRef<'IssueStatus', 'DateTime'>;
   }

   // Custom InputTypes
   /**
    * IssueStatus findUnique
    */
   export type IssueStatusFindUniqueArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueStatus
       */
      select?: IssueStatusSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueStatus
       */
      omit?: IssueStatusOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueStatusInclude<ExtArgs> | null;
      /**
       * Filter, which IssueStatus to fetch.
       */
      where: IssueStatusWhereUniqueInput;
   };

   /**
    * IssueStatus findUniqueOrThrow
    */
   export type IssueStatusFindUniqueOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueStatus
       */
      select?: IssueStatusSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueStatus
       */
      omit?: IssueStatusOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueStatusInclude<ExtArgs> | null;
      /**
       * Filter, which IssueStatus to fetch.
       */
      where: IssueStatusWhereUniqueInput;
   };

   /**
    * IssueStatus findFirst
    */
   export type IssueStatusFindFirstArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueStatus
       */
      select?: IssueStatusSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueStatus
       */
      omit?: IssueStatusOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueStatusInclude<ExtArgs> | null;
      /**
       * Filter, which IssueStatus to fetch.
       */
      where?: IssueStatusWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of IssueStatuses to fetch.
       */
      orderBy?: IssueStatusOrderByWithRelationInput | IssueStatusOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for IssueStatuses.
       */
      cursor?: IssueStatusWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` IssueStatuses from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` IssueStatuses.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of IssueStatuses.
       */
      distinct?: IssueStatusScalarFieldEnum | IssueStatusScalarFieldEnum[];
   };

   /**
    * IssueStatus findFirstOrThrow
    */
   export type IssueStatusFindFirstOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueStatus
       */
      select?: IssueStatusSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueStatus
       */
      omit?: IssueStatusOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueStatusInclude<ExtArgs> | null;
      /**
       * Filter, which IssueStatus to fetch.
       */
      where?: IssueStatusWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of IssueStatuses to fetch.
       */
      orderBy?: IssueStatusOrderByWithRelationInput | IssueStatusOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for IssueStatuses.
       */
      cursor?: IssueStatusWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` IssueStatuses from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` IssueStatuses.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of IssueStatuses.
       */
      distinct?: IssueStatusScalarFieldEnum | IssueStatusScalarFieldEnum[];
   };

   /**
    * IssueStatus findMany
    */
   export type IssueStatusFindManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueStatus
       */
      select?: IssueStatusSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueStatus
       */
      omit?: IssueStatusOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueStatusInclude<ExtArgs> | null;
      /**
       * Filter, which IssueStatuses to fetch.
       */
      where?: IssueStatusWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of IssueStatuses to fetch.
       */
      orderBy?: IssueStatusOrderByWithRelationInput | IssueStatusOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing IssueStatuses.
       */
      cursor?: IssueStatusWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` IssueStatuses from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` IssueStatuses.
       */
      skip?: number;
      distinct?: IssueStatusScalarFieldEnum | IssueStatusScalarFieldEnum[];
   };

   /**
    * IssueStatus create
    */
   export type IssueStatusCreateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueStatus
       */
      select?: IssueStatusSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueStatus
       */
      omit?: IssueStatusOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueStatusInclude<ExtArgs> | null;
      /**
       * The data needed to create a IssueStatus.
       */
      data: XOR<IssueStatusCreateInput, IssueStatusUncheckedCreateInput>;
   };

   /**
    * IssueStatus createMany
    */
   export type IssueStatusCreateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to create many IssueStatuses.
       */
      data: IssueStatusCreateManyInput | IssueStatusCreateManyInput[];
   };

   /**
    * IssueStatus createManyAndReturn
    */
   export type IssueStatusCreateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueStatus
       */
      select?: IssueStatusSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueStatus
       */
      omit?: IssueStatusOmit<ExtArgs> | null;
      /**
       * The data used to create many IssueStatuses.
       */
      data: IssueStatusCreateManyInput | IssueStatusCreateManyInput[];
   };

   /**
    * IssueStatus update
    */
   export type IssueStatusUpdateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueStatus
       */
      select?: IssueStatusSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueStatus
       */
      omit?: IssueStatusOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueStatusInclude<ExtArgs> | null;
      /**
       * The data needed to update a IssueStatus.
       */
      data: XOR<IssueStatusUpdateInput, IssueStatusUncheckedUpdateInput>;
      /**
       * Choose, which IssueStatus to update.
       */
      where: IssueStatusWhereUniqueInput;
   };

   /**
    * IssueStatus updateMany
    */
   export type IssueStatusUpdateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to update IssueStatuses.
       */
      data: XOR<IssueStatusUpdateManyMutationInput, IssueStatusUncheckedUpdateManyInput>;
      /**
       * Filter which IssueStatuses to update
       */
      where?: IssueStatusWhereInput;
      /**
       * Limit how many IssueStatuses to update.
       */
      limit?: number;
   };

   /**
    * IssueStatus updateManyAndReturn
    */
   export type IssueStatusUpdateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueStatus
       */
      select?: IssueStatusSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueStatus
       */
      omit?: IssueStatusOmit<ExtArgs> | null;
      /**
       * The data used to update IssueStatuses.
       */
      data: XOR<IssueStatusUpdateManyMutationInput, IssueStatusUncheckedUpdateManyInput>;
      /**
       * Filter which IssueStatuses to update
       */
      where?: IssueStatusWhereInput;
      /**
       * Limit how many IssueStatuses to update.
       */
      limit?: number;
   };

   /**
    * IssueStatus upsert
    */
   export type IssueStatusUpsertArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueStatus
       */
      select?: IssueStatusSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueStatus
       */
      omit?: IssueStatusOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueStatusInclude<ExtArgs> | null;
      /**
       * The filter to search for the IssueStatus to update in case it exists.
       */
      where: IssueStatusWhereUniqueInput;
      /**
       * In case the IssueStatus found by the `where` argument doesn't exist, create a new IssueStatus with this data.
       */
      create: XOR<IssueStatusCreateInput, IssueStatusUncheckedCreateInput>;
      /**
       * In case the IssueStatus was found with the provided `where` argument, update it with this data.
       */
      update: XOR<IssueStatusUpdateInput, IssueStatusUncheckedUpdateInput>;
   };

   /**
    * IssueStatus delete
    */
   export type IssueStatusDeleteArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueStatus
       */
      select?: IssueStatusSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueStatus
       */
      omit?: IssueStatusOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueStatusInclude<ExtArgs> | null;
      /**
       * Filter which IssueStatus to delete.
       */
      where: IssueStatusWhereUniqueInput;
   };

   /**
    * IssueStatus deleteMany
    */
   export type IssueStatusDeleteManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which IssueStatuses to delete
       */
      where?: IssueStatusWhereInput;
      /**
       * Limit how many IssueStatuses to delete.
       */
      limit?: number;
   };

   /**
    * IssueStatus.issues
    */
   export type IssueStatus$issuesArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Issue
       */
      select?: IssueSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Issue
       */
      omit?: IssueOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueInclude<ExtArgs> | null;
      where?: IssueWhereInput;
      orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[];
      cursor?: IssueWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[];
   };

   /**
    * IssueStatus without action
    */
   export type IssueStatusDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueStatus
       */
      select?: IssueStatusSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueStatus
       */
      omit?: IssueStatusOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueStatusInclude<ExtArgs> | null;
   };

   /**
    * Model IssuePriority
    */

   export type AggregateIssuePriority = {
      _count: IssuePriorityCountAggregateOutputType | null;
      _avg: IssuePriorityAvgAggregateOutputType | null;
      _sum: IssuePrioritySumAggregateOutputType | null;
      _min: IssuePriorityMinAggregateOutputType | null;
      _max: IssuePriorityMaxAggregateOutputType | null;
   };

   export type IssuePriorityAvgAggregateOutputType = {
      order: number | null;
   };

   export type IssuePrioritySumAggregateOutputType = {
      order: number | null;
   };

   export type IssuePriorityMinAggregateOutputType = {
      id: string | null;
      name: string | null;
      iconName: string | null;
      order: number | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type IssuePriorityMaxAggregateOutputType = {
      id: string | null;
      name: string | null;
      iconName: string | null;
      order: number | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type IssuePriorityCountAggregateOutputType = {
      id: number;
      name: number;
      iconName: number;
      order: number;
      createdAt: number;
      updatedAt: number;
      _all: number;
   };

   export type IssuePriorityAvgAggregateInputType = {
      order?: true;
   };

   export type IssuePrioritySumAggregateInputType = {
      order?: true;
   };

   export type IssuePriorityMinAggregateInputType = {
      id?: true;
      name?: true;
      iconName?: true;
      order?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type IssuePriorityMaxAggregateInputType = {
      id?: true;
      name?: true;
      iconName?: true;
      order?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type IssuePriorityCountAggregateInputType = {
      id?: true;
      name?: true;
      iconName?: true;
      order?: true;
      createdAt?: true;
      updatedAt?: true;
      _all?: true;
   };

   export type IssuePriorityAggregateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which IssuePriority to aggregate.
       */
      where?: IssuePriorityWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of IssuePriorities to fetch.
       */
      orderBy?: IssuePriorityOrderByWithRelationInput | IssuePriorityOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: IssuePriorityWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` IssuePriorities from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` IssuePriorities.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned IssuePriorities
       **/
      _count?: true | IssuePriorityCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to average
       **/
      _avg?: IssuePriorityAvgAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to sum
       **/
      _sum?: IssuePrioritySumAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: IssuePriorityMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: IssuePriorityMaxAggregateInputType;
   };

   export type GetIssuePriorityAggregateType<T extends IssuePriorityAggregateArgs> = {
      [P in keyof T & keyof AggregateIssuePriority]: P extends '_count' | 'count'
         ? T[P] extends true
            ? number
            : GetScalarType<T[P], AggregateIssuePriority[P]>
         : GetScalarType<T[P], AggregateIssuePriority[P]>;
   };

   export type IssuePriorityGroupByArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: IssuePriorityWhereInput;
      orderBy?:
         | IssuePriorityOrderByWithAggregationInput
         | IssuePriorityOrderByWithAggregationInput[];
      by: IssuePriorityScalarFieldEnum[] | IssuePriorityScalarFieldEnum;
      having?: IssuePriorityScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: IssuePriorityCountAggregateInputType | true;
      _avg?: IssuePriorityAvgAggregateInputType;
      _sum?: IssuePrioritySumAggregateInputType;
      _min?: IssuePriorityMinAggregateInputType;
      _max?: IssuePriorityMaxAggregateInputType;
   };

   export type IssuePriorityGroupByOutputType = {
      id: string;
      name: string;
      iconName: string;
      order: number;
      createdAt: Date;
      updatedAt: Date;
      _count: IssuePriorityCountAggregateOutputType | null;
      _avg: IssuePriorityAvgAggregateOutputType | null;
      _sum: IssuePrioritySumAggregateOutputType | null;
      _min: IssuePriorityMinAggregateOutputType | null;
      _max: IssuePriorityMaxAggregateOutputType | null;
   };

   type GetIssuePriorityGroupByPayload<T extends IssuePriorityGroupByArgs> = Prisma.PrismaPromise<
      Array<
         PickEnumerable<IssuePriorityGroupByOutputType, T['by']> & {
            [P in keyof T & keyof IssuePriorityGroupByOutputType]: P extends '_count'
               ? T[P] extends boolean
                  ? number
                  : GetScalarType<T[P], IssuePriorityGroupByOutputType[P]>
               : GetScalarType<T[P], IssuePriorityGroupByOutputType[P]>;
         }
      >
   >;

   export type IssuePrioritySelect<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         name?: boolean;
         iconName?: boolean;
         order?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
         issues?: boolean | IssuePriority$issuesArgs<ExtArgs>;
         _count?: boolean | IssuePriorityCountOutputTypeDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['issuePriority']
   >;

   export type IssuePrioritySelectCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         name?: boolean;
         iconName?: boolean;
         order?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
      },
      ExtArgs['result']['issuePriority']
   >;

   export type IssuePrioritySelectUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         name?: boolean;
         iconName?: boolean;
         order?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
      },
      ExtArgs['result']['issuePriority']
   >;

   export type IssuePrioritySelectScalar = {
      id?: boolean;
      name?: boolean;
      iconName?: boolean;
      order?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
   };

   export type IssuePriorityOmit<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetOmit<
      'id' | 'name' | 'iconName' | 'order' | 'createdAt' | 'updatedAt',
      ExtArgs['result']['issuePriority']
   >;
   export type IssuePriorityInclude<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      issues?: boolean | IssuePriority$issuesArgs<ExtArgs>;
      _count?: boolean | IssuePriorityCountOutputTypeDefaultArgs<ExtArgs>;
   };
   export type IssuePriorityIncludeCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {};
   export type IssuePriorityIncludeUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {};

   export type $IssuePriorityPayload<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      name: 'IssuePriority';
      objects: {
         issues: Prisma.$IssuePayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
         {
            id: string;
            name: string;
            iconName: string;
            order: number;
            createdAt: Date;
            updatedAt: Date;
         },
         ExtArgs['result']['issuePriority']
      >;
      composites: {};
   };

   type IssuePriorityGetPayload<S extends boolean | null | undefined | IssuePriorityDefaultArgs> =
      $Result.GetResult<Prisma.$IssuePriorityPayload, S>;

   type IssuePriorityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      Omit<IssuePriorityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
         select?: IssuePriorityCountAggregateInputType | true;
      };

   export interface IssuePriorityDelegate<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > {
      [K: symbol]: {
         types: Prisma.TypeMap<ExtArgs>['model']['IssuePriority'];
         meta: { name: 'IssuePriority' };
      };
      /**
       * Find zero or one IssuePriority that matches the filter.
       * @param {IssuePriorityFindUniqueArgs} args - Arguments to find a IssuePriority
       * @example
       * // Get one IssuePriority
       * const issuePriority = await prisma.issuePriority.findUnique({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUnique<T extends IssuePriorityFindUniqueArgs>(
         args: SelectSubset<T, IssuePriorityFindUniqueArgs<ExtArgs>>
      ): Prisma__IssuePriorityClient<
         $Result.GetResult<
            Prisma.$IssuePriorityPayload<ExtArgs>,
            T,
            'findUnique',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find one IssuePriority that matches the filter or throw an error with `error.code='P2025'`
       * if no matches were found.
       * @param {IssuePriorityFindUniqueOrThrowArgs} args - Arguments to find a IssuePriority
       * @example
       * // Get one IssuePriority
       * const issuePriority = await prisma.issuePriority.findUniqueOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUniqueOrThrow<T extends IssuePriorityFindUniqueOrThrowArgs>(
         args: SelectSubset<T, IssuePriorityFindUniqueOrThrowArgs<ExtArgs>>
      ): Prisma__IssuePriorityClient<
         $Result.GetResult<
            Prisma.$IssuePriorityPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first IssuePriority that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssuePriorityFindFirstArgs} args - Arguments to find a IssuePriority
       * @example
       * // Get one IssuePriority
       * const issuePriority = await prisma.issuePriority.findFirst({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirst<T extends IssuePriorityFindFirstArgs>(
         args?: SelectSubset<T, IssuePriorityFindFirstArgs<ExtArgs>>
      ): Prisma__IssuePriorityClient<
         $Result.GetResult<
            Prisma.$IssuePriorityPayload<ExtArgs>,
            T,
            'findFirst',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first IssuePriority that matches the filter or
       * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssuePriorityFindFirstOrThrowArgs} args - Arguments to find a IssuePriority
       * @example
       * // Get one IssuePriority
       * const issuePriority = await prisma.issuePriority.findFirstOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirstOrThrow<T extends IssuePriorityFindFirstOrThrowArgs>(
         args?: SelectSubset<T, IssuePriorityFindFirstOrThrowArgs<ExtArgs>>
      ): Prisma__IssuePriorityClient<
         $Result.GetResult<
            Prisma.$IssuePriorityPayload<ExtArgs>,
            T,
            'findFirstOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find zero or more IssuePriorities that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssuePriorityFindManyArgs} args - Arguments to filter and select certain fields only.
       * @example
       * // Get all IssuePriorities
       * const issuePriorities = await prisma.issuePriority.findMany()
       *
       * // Get first 10 IssuePriorities
       * const issuePriorities = await prisma.issuePriority.findMany({ take: 10 })
       *
       * // Only select the `id`
       * const issuePriorityWithIdOnly = await prisma.issuePriority.findMany({ select: { id: true } })
       *
       */
      findMany<T extends IssuePriorityFindManyArgs>(
         args?: SelectSubset<T, IssuePriorityFindManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$IssuePriorityPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      >;

      /**
       * Create a IssuePriority.
       * @param {IssuePriorityCreateArgs} args - Arguments to create a IssuePriority.
       * @example
       * // Create one IssuePriority
       * const IssuePriority = await prisma.issuePriority.create({
       *   data: {
       *     // ... data to create a IssuePriority
       *   }
       * })
       *
       */
      create<T extends IssuePriorityCreateArgs>(
         args: SelectSubset<T, IssuePriorityCreateArgs<ExtArgs>>
      ): Prisma__IssuePriorityClient<
         $Result.GetResult<Prisma.$IssuePriorityPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Create many IssuePriorities.
       * @param {IssuePriorityCreateManyArgs} args - Arguments to create many IssuePriorities.
       * @example
       * // Create many IssuePriorities
       * const issuePriority = await prisma.issuePriority.createMany({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       */
      createMany<T extends IssuePriorityCreateManyArgs>(
         args?: SelectSubset<T, IssuePriorityCreateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Create many IssuePriorities and returns the data saved in the database.
       * @param {IssuePriorityCreateManyAndReturnArgs} args - Arguments to create many IssuePriorities.
       * @example
       * // Create many IssuePriorities
       * const issuePriority = await prisma.issuePriority.createManyAndReturn({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Create many IssuePriorities and only return the `id`
       * const issuePriorityWithIdOnly = await prisma.issuePriority.createManyAndReturn({
       *   select: { id: true },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      createManyAndReturn<T extends IssuePriorityCreateManyAndReturnArgs>(
         args?: SelectSubset<T, IssuePriorityCreateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$IssuePriorityPayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Delete a IssuePriority.
       * @param {IssuePriorityDeleteArgs} args - Arguments to delete one IssuePriority.
       * @example
       * // Delete one IssuePriority
       * const IssuePriority = await prisma.issuePriority.delete({
       *   where: {
       *     // ... filter to delete one IssuePriority
       *   }
       * })
       *
       */
      delete<T extends IssuePriorityDeleteArgs>(
         args: SelectSubset<T, IssuePriorityDeleteArgs<ExtArgs>>
      ): Prisma__IssuePriorityClient<
         $Result.GetResult<Prisma.$IssuePriorityPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Update one IssuePriority.
       * @param {IssuePriorityUpdateArgs} args - Arguments to update one IssuePriority.
       * @example
       * // Update one IssuePriority
       * const issuePriority = await prisma.issuePriority.update({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      update<T extends IssuePriorityUpdateArgs>(
         args: SelectSubset<T, IssuePriorityUpdateArgs<ExtArgs>>
      ): Prisma__IssuePriorityClient<
         $Result.GetResult<Prisma.$IssuePriorityPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Delete zero or more IssuePriorities.
       * @param {IssuePriorityDeleteManyArgs} args - Arguments to filter IssuePriorities to delete.
       * @example
       * // Delete a few IssuePriorities
       * const { count } = await prisma.issuePriority.deleteMany({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       *
       */
      deleteMany<T extends IssuePriorityDeleteManyArgs>(
         args?: SelectSubset<T, IssuePriorityDeleteManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more IssuePriorities.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssuePriorityUpdateManyArgs} args - Arguments to update one or more rows.
       * @example
       * // Update many IssuePriorities
       * const issuePriority = await prisma.issuePriority.updateMany({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      updateMany<T extends IssuePriorityUpdateManyArgs>(
         args: SelectSubset<T, IssuePriorityUpdateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more IssuePriorities and returns the data updated in the database.
       * @param {IssuePriorityUpdateManyAndReturnArgs} args - Arguments to update many IssuePriorities.
       * @example
       * // Update many IssuePriorities
       * const issuePriority = await prisma.issuePriority.updateManyAndReturn({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Update zero or more IssuePriorities and only return the `id`
       * const issuePriorityWithIdOnly = await prisma.issuePriority.updateManyAndReturn({
       *   select: { id: true },
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      updateManyAndReturn<T extends IssuePriorityUpdateManyAndReturnArgs>(
         args: SelectSubset<T, IssuePriorityUpdateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$IssuePriorityPayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Create or update one IssuePriority.
       * @param {IssuePriorityUpsertArgs} args - Arguments to update or create a IssuePriority.
       * @example
       * // Update or create a IssuePriority
       * const issuePriority = await prisma.issuePriority.upsert({
       *   create: {
       *     // ... data to create a IssuePriority
       *   },
       *   update: {
       *     // ... in case it already exists, update
       *   },
       *   where: {
       *     // ... the filter for the IssuePriority we want to update
       *   }
       * })
       */
      upsert<T extends IssuePriorityUpsertArgs>(
         args: SelectSubset<T, IssuePriorityUpsertArgs<ExtArgs>>
      ): Prisma__IssuePriorityClient<
         $Result.GetResult<Prisma.$IssuePriorityPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Count the number of IssuePriorities.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssuePriorityCountArgs} args - Arguments to filter IssuePriorities to count.
       * @example
       * // Count the number of IssuePriorities
       * const count = await prisma.issuePriority.count({
       *   where: {
       *     // ... the filter for the IssuePriorities we want to count
       *   }
       * })
       **/
      count<T extends IssuePriorityCountArgs>(
         args?: Subset<T, IssuePriorityCountArgs>
      ): Prisma.PrismaPromise<
         T extends $Utils.Record<'select', any>
            ? T['select'] extends true
               ? number
               : GetScalarType<T['select'], IssuePriorityCountAggregateOutputType>
            : number
      >;

      /**
       * Allows you to perform aggregations operations on a IssuePriority.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssuePriorityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
       * @example
       * // Ordered by age ascending
       * // Where email contains prisma.io
       * // Limited to the 10 users
       * const aggregations = await prisma.user.aggregate({
       *   _avg: {
       *     age: true,
       *   },
       *   where: {
       *     email: {
       *       contains: "prisma.io",
       *     },
       *   },
       *   orderBy: {
       *     age: "asc",
       *   },
       *   take: 10,
       * })
       **/
      aggregate<T extends IssuePriorityAggregateArgs>(
         args: Subset<T, IssuePriorityAggregateArgs>
      ): Prisma.PrismaPromise<GetIssuePriorityAggregateType<T>>;

      /**
       * Group by IssuePriority.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssuePriorityGroupByArgs} args - Group by arguments.
       * @example
       * // Group by city, order by createdAt, get count
       * const result = await prisma.user.groupBy({
       *   by: ['city', 'createdAt'],
       *   orderBy: {
       *     createdAt: true
       *   },
       *   _count: {
       *     _all: true
       *   },
       * })
       *
       **/
      groupBy<
         T extends IssuePriorityGroupByArgs,
         HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
         OrderByArg extends True extends HasSelectOrTake
            ? { orderBy: IssuePriorityGroupByArgs['orderBy'] }
            : { orderBy?: IssuePriorityGroupByArgs['orderBy'] },
         OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
         ByFields extends MaybeTupleToUnion<T['by']>,
         ByValid extends Has<ByFields, OrderFields>,
         HavingFields extends GetHavingFields<T['having']>,
         HavingValid extends Has<ByFields, HavingFields>,
         ByEmpty extends T['by'] extends never[] ? True : False,
         InputErrors extends ByEmpty extends True
            ? `Error: "by" must not be empty.`
            : HavingValid extends False
              ? {
                   [P in HavingFields]: P extends ByFields
                      ? never
                      : P extends string
                        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                        : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Keys<T>
                ? 'orderBy' extends Keys<T>
                   ? ByValid extends True
                      ? {}
                      : {
                           [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                        }[OrderFields]
                   : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Keys<T>
                  ? 'orderBy' extends Keys<T>
                     ? ByValid extends True
                        ? {}
                        : {
                             [P in OrderFields]: P extends ByFields
                                ? never
                                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                     : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends True
                    ? {}
                    : {
                         [P in OrderFields]: P extends ByFields
                            ? never
                            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
      >(
         args: SubsetIntersection<T, IssuePriorityGroupByArgs, OrderByArg> & InputErrors
      ): {} extends InputErrors
         ? GetIssuePriorityGroupByPayload<T>
         : Prisma.PrismaPromise<InputErrors>;
      /**
       * Fields of the IssuePriority model
       */
      readonly fields: IssuePriorityFieldRefs;
   }

   /**
    * The delegate class that acts as a "Promise-like" for IssuePriority.
    * Why is this prefixed with `Prisma__`?
    * Because we want to prevent naming conflicts as mentioned in
    * https://github.com/prisma/prisma-client-js/issues/707
    */
   export interface Prisma__IssuePriorityClient<
      T,
      Null = never,
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > extends Prisma.PrismaPromise<T> {
      readonly [Symbol.toStringTag]: 'PrismaPromise';
      issues<T extends IssuePriority$issuesArgs<ExtArgs> = {}>(
         args?: Subset<T, IssuePriority$issuesArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
      >;
      /**
       * Attaches callbacks for the resolution and/or rejection of the Promise.
       * @param onfulfilled The callback to execute when the Promise is resolved.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of which ever callback is executed.
       */
      then<TResult1 = T, TResult2 = never>(
         onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
         onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
      ): $Utils.JsPromise<TResult1 | TResult2>;
      /**
       * Attaches a callback for only the rejection of the Promise.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of the callback.
       */
      catch<TResult = never>(
         onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
      ): $Utils.JsPromise<T | TResult>;
      /**
       * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
       * resolved value cannot be modified from the callback.
       * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
       * @returns A Promise for the completion of the callback.
       */
      finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
   }

   /**
    * Fields of the IssuePriority model
    */
   interface IssuePriorityFieldRefs {
      readonly id: FieldRef<'IssuePriority', 'String'>;
      readonly name: FieldRef<'IssuePriority', 'String'>;
      readonly iconName: FieldRef<'IssuePriority', 'String'>;
      readonly order: FieldRef<'IssuePriority', 'Int'>;
      readonly createdAt: FieldRef<'IssuePriority', 'DateTime'>;
      readonly updatedAt: FieldRef<'IssuePriority', 'DateTime'>;
   }

   // Custom InputTypes
   /**
    * IssuePriority findUnique
    */
   export type IssuePriorityFindUniqueArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssuePriority
       */
      select?: IssuePrioritySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssuePriority
       */
      omit?: IssuePriorityOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssuePriorityInclude<ExtArgs> | null;
      /**
       * Filter, which IssuePriority to fetch.
       */
      where: IssuePriorityWhereUniqueInput;
   };

   /**
    * IssuePriority findUniqueOrThrow
    */
   export type IssuePriorityFindUniqueOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssuePriority
       */
      select?: IssuePrioritySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssuePriority
       */
      omit?: IssuePriorityOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssuePriorityInclude<ExtArgs> | null;
      /**
       * Filter, which IssuePriority to fetch.
       */
      where: IssuePriorityWhereUniqueInput;
   };

   /**
    * IssuePriority findFirst
    */
   export type IssuePriorityFindFirstArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssuePriority
       */
      select?: IssuePrioritySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssuePriority
       */
      omit?: IssuePriorityOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssuePriorityInclude<ExtArgs> | null;
      /**
       * Filter, which IssuePriority to fetch.
       */
      where?: IssuePriorityWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of IssuePriorities to fetch.
       */
      orderBy?: IssuePriorityOrderByWithRelationInput | IssuePriorityOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for IssuePriorities.
       */
      cursor?: IssuePriorityWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` IssuePriorities from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` IssuePriorities.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of IssuePriorities.
       */
      distinct?: IssuePriorityScalarFieldEnum | IssuePriorityScalarFieldEnum[];
   };

   /**
    * IssuePriority findFirstOrThrow
    */
   export type IssuePriorityFindFirstOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssuePriority
       */
      select?: IssuePrioritySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssuePriority
       */
      omit?: IssuePriorityOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssuePriorityInclude<ExtArgs> | null;
      /**
       * Filter, which IssuePriority to fetch.
       */
      where?: IssuePriorityWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of IssuePriorities to fetch.
       */
      orderBy?: IssuePriorityOrderByWithRelationInput | IssuePriorityOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for IssuePriorities.
       */
      cursor?: IssuePriorityWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` IssuePriorities from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` IssuePriorities.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of IssuePriorities.
       */
      distinct?: IssuePriorityScalarFieldEnum | IssuePriorityScalarFieldEnum[];
   };

   /**
    * IssuePriority findMany
    */
   export type IssuePriorityFindManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssuePriority
       */
      select?: IssuePrioritySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssuePriority
       */
      omit?: IssuePriorityOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssuePriorityInclude<ExtArgs> | null;
      /**
       * Filter, which IssuePriorities to fetch.
       */
      where?: IssuePriorityWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of IssuePriorities to fetch.
       */
      orderBy?: IssuePriorityOrderByWithRelationInput | IssuePriorityOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing IssuePriorities.
       */
      cursor?: IssuePriorityWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` IssuePriorities from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` IssuePriorities.
       */
      skip?: number;
      distinct?: IssuePriorityScalarFieldEnum | IssuePriorityScalarFieldEnum[];
   };

   /**
    * IssuePriority create
    */
   export type IssuePriorityCreateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssuePriority
       */
      select?: IssuePrioritySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssuePriority
       */
      omit?: IssuePriorityOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssuePriorityInclude<ExtArgs> | null;
      /**
       * The data needed to create a IssuePriority.
       */
      data: XOR<IssuePriorityCreateInput, IssuePriorityUncheckedCreateInput>;
   };

   /**
    * IssuePriority createMany
    */
   export type IssuePriorityCreateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to create many IssuePriorities.
       */
      data: IssuePriorityCreateManyInput | IssuePriorityCreateManyInput[];
   };

   /**
    * IssuePriority createManyAndReturn
    */
   export type IssuePriorityCreateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssuePriority
       */
      select?: IssuePrioritySelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the IssuePriority
       */
      omit?: IssuePriorityOmit<ExtArgs> | null;
      /**
       * The data used to create many IssuePriorities.
       */
      data: IssuePriorityCreateManyInput | IssuePriorityCreateManyInput[];
   };

   /**
    * IssuePriority update
    */
   export type IssuePriorityUpdateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssuePriority
       */
      select?: IssuePrioritySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssuePriority
       */
      omit?: IssuePriorityOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssuePriorityInclude<ExtArgs> | null;
      /**
       * The data needed to update a IssuePriority.
       */
      data: XOR<IssuePriorityUpdateInput, IssuePriorityUncheckedUpdateInput>;
      /**
       * Choose, which IssuePriority to update.
       */
      where: IssuePriorityWhereUniqueInput;
   };

   /**
    * IssuePriority updateMany
    */
   export type IssuePriorityUpdateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to update IssuePriorities.
       */
      data: XOR<IssuePriorityUpdateManyMutationInput, IssuePriorityUncheckedUpdateManyInput>;
      /**
       * Filter which IssuePriorities to update
       */
      where?: IssuePriorityWhereInput;
      /**
       * Limit how many IssuePriorities to update.
       */
      limit?: number;
   };

   /**
    * IssuePriority updateManyAndReturn
    */
   export type IssuePriorityUpdateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssuePriority
       */
      select?: IssuePrioritySelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the IssuePriority
       */
      omit?: IssuePriorityOmit<ExtArgs> | null;
      /**
       * The data used to update IssuePriorities.
       */
      data: XOR<IssuePriorityUpdateManyMutationInput, IssuePriorityUncheckedUpdateManyInput>;
      /**
       * Filter which IssuePriorities to update
       */
      where?: IssuePriorityWhereInput;
      /**
       * Limit how many IssuePriorities to update.
       */
      limit?: number;
   };

   /**
    * IssuePriority upsert
    */
   export type IssuePriorityUpsertArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssuePriority
       */
      select?: IssuePrioritySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssuePriority
       */
      omit?: IssuePriorityOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssuePriorityInclude<ExtArgs> | null;
      /**
       * The filter to search for the IssuePriority to update in case it exists.
       */
      where: IssuePriorityWhereUniqueInput;
      /**
       * In case the IssuePriority found by the `where` argument doesn't exist, create a new IssuePriority with this data.
       */
      create: XOR<IssuePriorityCreateInput, IssuePriorityUncheckedCreateInput>;
      /**
       * In case the IssuePriority was found with the provided `where` argument, update it with this data.
       */
      update: XOR<IssuePriorityUpdateInput, IssuePriorityUncheckedUpdateInput>;
   };

   /**
    * IssuePriority delete
    */
   export type IssuePriorityDeleteArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssuePriority
       */
      select?: IssuePrioritySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssuePriority
       */
      omit?: IssuePriorityOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssuePriorityInclude<ExtArgs> | null;
      /**
       * Filter which IssuePriority to delete.
       */
      where: IssuePriorityWhereUniqueInput;
   };

   /**
    * IssuePriority deleteMany
    */
   export type IssuePriorityDeleteManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which IssuePriorities to delete
       */
      where?: IssuePriorityWhereInput;
      /**
       * Limit how many IssuePriorities to delete.
       */
      limit?: number;
   };

   /**
    * IssuePriority.issues
    */
   export type IssuePriority$issuesArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Issue
       */
      select?: IssueSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Issue
       */
      omit?: IssueOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueInclude<ExtArgs> | null;
      where?: IssueWhereInput;
      orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[];
      cursor?: IssueWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[];
   };

   /**
    * IssuePriority without action
    */
   export type IssuePriorityDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssuePriority
       */
      select?: IssuePrioritySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssuePriority
       */
      omit?: IssuePriorityOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssuePriorityInclude<ExtArgs> | null;
   };

   /**
    * Model Issue
    */

   export type AggregateIssue = {
      _count: IssueCountAggregateOutputType | null;
      _avg: IssueAvgAggregateOutputType | null;
      _sum: IssueSumAggregateOutputType | null;
      _min: IssueMinAggregateOutputType | null;
      _max: IssueMaxAggregateOutputType | null;
   };

   export type IssueAvgAggregateOutputType = {
      taskId: number | null;
   };

   export type IssueSumAggregateOutputType = {
      taskId: number | null;
   };

   export type IssueMinAggregateOutputType = {
      id: string | null;
      identifier: string | null;
      title: string | null;
      description: string | null;
      statusId: string | null;
      priorityId: string | null;
      status: string | null;
      priority: string | null;
      rank: string | null;
      cycleId: string | null;
      dueDate: Date | null;
      taskId: number | null;
      subtaskId: string | null;
      issueType: $Enums.IssueType | null;
      assigneeId: string | null;
      projectId: string | null;
      subissues: string | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type IssueMaxAggregateOutputType = {
      id: string | null;
      identifier: string | null;
      title: string | null;
      description: string | null;
      statusId: string | null;
      priorityId: string | null;
      status: string | null;
      priority: string | null;
      rank: string | null;
      cycleId: string | null;
      dueDate: Date | null;
      taskId: number | null;
      subtaskId: string | null;
      issueType: $Enums.IssueType | null;
      assigneeId: string | null;
      projectId: string | null;
      subissues: string | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type IssueCountAggregateOutputType = {
      id: number;
      identifier: number;
      title: number;
      description: number;
      statusId: number;
      priorityId: number;
      status: number;
      priority: number;
      rank: number;
      cycleId: number;
      dueDate: number;
      taskId: number;
      subtaskId: number;
      issueType: number;
      assigneeId: number;
      projectId: number;
      subissues: number;
      createdAt: number;
      updatedAt: number;
      _all: number;
   };

   export type IssueAvgAggregateInputType = {
      taskId?: true;
   };

   export type IssueSumAggregateInputType = {
      taskId?: true;
   };

   export type IssueMinAggregateInputType = {
      id?: true;
      identifier?: true;
      title?: true;
      description?: true;
      statusId?: true;
      priorityId?: true;
      status?: true;
      priority?: true;
      rank?: true;
      cycleId?: true;
      dueDate?: true;
      taskId?: true;
      subtaskId?: true;
      issueType?: true;
      assigneeId?: true;
      projectId?: true;
      subissues?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type IssueMaxAggregateInputType = {
      id?: true;
      identifier?: true;
      title?: true;
      description?: true;
      statusId?: true;
      priorityId?: true;
      status?: true;
      priority?: true;
      rank?: true;
      cycleId?: true;
      dueDate?: true;
      taskId?: true;
      subtaskId?: true;
      issueType?: true;
      assigneeId?: true;
      projectId?: true;
      subissues?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type IssueCountAggregateInputType = {
      id?: true;
      identifier?: true;
      title?: true;
      description?: true;
      statusId?: true;
      priorityId?: true;
      status?: true;
      priority?: true;
      rank?: true;
      cycleId?: true;
      dueDate?: true;
      taskId?: true;
      subtaskId?: true;
      issueType?: true;
      assigneeId?: true;
      projectId?: true;
      subissues?: true;
      createdAt?: true;
      updatedAt?: true;
      _all?: true;
   };

   export type IssueAggregateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which Issue to aggregate.
       */
      where?: IssueWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Issues to fetch.
       */
      orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: IssueWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Issues from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Issues.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned Issues
       **/
      _count?: true | IssueCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to average
       **/
      _avg?: IssueAvgAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to sum
       **/
      _sum?: IssueSumAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: IssueMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: IssueMaxAggregateInputType;
   };

   export type GetIssueAggregateType<T extends IssueAggregateArgs> = {
      [P in keyof T & keyof AggregateIssue]: P extends '_count' | 'count'
         ? T[P] extends true
            ? number
            : GetScalarType<T[P], AggregateIssue[P]>
         : GetScalarType<T[P], AggregateIssue[P]>;
   };

   export type IssueGroupByArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: IssueWhereInput;
      orderBy?: IssueOrderByWithAggregationInput | IssueOrderByWithAggregationInput[];
      by: IssueScalarFieldEnum[] | IssueScalarFieldEnum;
      having?: IssueScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: IssueCountAggregateInputType | true;
      _avg?: IssueAvgAggregateInputType;
      _sum?: IssueSumAggregateInputType;
      _min?: IssueMinAggregateInputType;
      _max?: IssueMaxAggregateInputType;
   };

   export type IssueGroupByOutputType = {
      id: string;
      identifier: string;
      title: string;
      description: string;
      statusId: string | null;
      priorityId: string | null;
      status: string | null;
      priority: string | null;
      rank: string;
      cycleId: string | null;
      dueDate: Date | null;
      taskId: number | null;
      subtaskId: string | null;
      issueType: $Enums.IssueType;
      assigneeId: string | null;
      projectId: string | null;
      subissues: string;
      createdAt: Date;
      updatedAt: Date;
      _count: IssueCountAggregateOutputType | null;
      _avg: IssueAvgAggregateOutputType | null;
      _sum: IssueSumAggregateOutputType | null;
      _min: IssueMinAggregateOutputType | null;
      _max: IssueMaxAggregateOutputType | null;
   };

   type GetIssueGroupByPayload<T extends IssueGroupByArgs> = Prisma.PrismaPromise<
      Array<
         PickEnumerable<IssueGroupByOutputType, T['by']> & {
            [P in keyof T & keyof IssueGroupByOutputType]: P extends '_count'
               ? T[P] extends boolean
                  ? number
                  : GetScalarType<T[P], IssueGroupByOutputType[P]>
               : GetScalarType<T[P], IssueGroupByOutputType[P]>;
         }
      >
   >;

   export type IssueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetSelect<
         {
            id?: boolean;
            identifier?: boolean;
            title?: boolean;
            description?: boolean;
            statusId?: boolean;
            priorityId?: boolean;
            status?: boolean;
            priority?: boolean;
            rank?: boolean;
            cycleId?: boolean;
            dueDate?: boolean;
            taskId?: boolean;
            subtaskId?: boolean;
            issueType?: boolean;
            assigneeId?: boolean;
            projectId?: boolean;
            subissues?: boolean;
            createdAt?: boolean;
            updatedAt?: boolean;
            assignee?: boolean | Issue$assigneeArgs<ExtArgs>;
            project?: boolean | Issue$projectArgs<ExtArgs>;
            cycle?: boolean | Issue$cycleArgs<ExtArgs>;
            task?: boolean | Issue$taskArgs<ExtArgs>;
            issueStatus?: boolean | Issue$issueStatusArgs<ExtArgs>;
            issuePriority?: boolean | Issue$issuePriorityArgs<ExtArgs>;
            labels?: boolean | Issue$labelsArgs<ExtArgs>;
            _count?: boolean | IssueCountOutputTypeDefaultArgs<ExtArgs>;
         },
         ExtArgs['result']['issue']
      >;

   export type IssueSelectCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         identifier?: boolean;
         title?: boolean;
         description?: boolean;
         statusId?: boolean;
         priorityId?: boolean;
         status?: boolean;
         priority?: boolean;
         rank?: boolean;
         cycleId?: boolean;
         dueDate?: boolean;
         taskId?: boolean;
         subtaskId?: boolean;
         issueType?: boolean;
         assigneeId?: boolean;
         projectId?: boolean;
         subissues?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
         assignee?: boolean | Issue$assigneeArgs<ExtArgs>;
         project?: boolean | Issue$projectArgs<ExtArgs>;
         cycle?: boolean | Issue$cycleArgs<ExtArgs>;
         task?: boolean | Issue$taskArgs<ExtArgs>;
         issueStatus?: boolean | Issue$issueStatusArgs<ExtArgs>;
         issuePriority?: boolean | Issue$issuePriorityArgs<ExtArgs>;
      },
      ExtArgs['result']['issue']
   >;

   export type IssueSelectUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         identifier?: boolean;
         title?: boolean;
         description?: boolean;
         statusId?: boolean;
         priorityId?: boolean;
         status?: boolean;
         priority?: boolean;
         rank?: boolean;
         cycleId?: boolean;
         dueDate?: boolean;
         taskId?: boolean;
         subtaskId?: boolean;
         issueType?: boolean;
         assigneeId?: boolean;
         projectId?: boolean;
         subissues?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
         assignee?: boolean | Issue$assigneeArgs<ExtArgs>;
         project?: boolean | Issue$projectArgs<ExtArgs>;
         cycle?: boolean | Issue$cycleArgs<ExtArgs>;
         task?: boolean | Issue$taskArgs<ExtArgs>;
         issueStatus?: boolean | Issue$issueStatusArgs<ExtArgs>;
         issuePriority?: boolean | Issue$issuePriorityArgs<ExtArgs>;
      },
      ExtArgs['result']['issue']
   >;

   export type IssueSelectScalar = {
      id?: boolean;
      identifier?: boolean;
      title?: boolean;
      description?: boolean;
      statusId?: boolean;
      priorityId?: boolean;
      status?: boolean;
      priority?: boolean;
      rank?: boolean;
      cycleId?: boolean;
      dueDate?: boolean;
      taskId?: boolean;
      subtaskId?: boolean;
      issueType?: boolean;
      assigneeId?: boolean;
      projectId?: boolean;
      subissues?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
   };

   export type IssueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetOmit<
         | 'id'
         | 'identifier'
         | 'title'
         | 'description'
         | 'statusId'
         | 'priorityId'
         | 'status'
         | 'priority'
         | 'rank'
         | 'cycleId'
         | 'dueDate'
         | 'taskId'
         | 'subtaskId'
         | 'issueType'
         | 'assigneeId'
         | 'projectId'
         | 'subissues'
         | 'createdAt'
         | 'updatedAt',
         ExtArgs['result']['issue']
      >;
   export type IssueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
      assignee?: boolean | Issue$assigneeArgs<ExtArgs>;
      project?: boolean | Issue$projectArgs<ExtArgs>;
      cycle?: boolean | Issue$cycleArgs<ExtArgs>;
      task?: boolean | Issue$taskArgs<ExtArgs>;
      issueStatus?: boolean | Issue$issueStatusArgs<ExtArgs>;
      issuePriority?: boolean | Issue$issuePriorityArgs<ExtArgs>;
      labels?: boolean | Issue$labelsArgs<ExtArgs>;
      _count?: boolean | IssueCountOutputTypeDefaultArgs<ExtArgs>;
   };
   export type IssueIncludeCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      assignee?: boolean | Issue$assigneeArgs<ExtArgs>;
      project?: boolean | Issue$projectArgs<ExtArgs>;
      cycle?: boolean | Issue$cycleArgs<ExtArgs>;
      task?: boolean | Issue$taskArgs<ExtArgs>;
      issueStatus?: boolean | Issue$issueStatusArgs<ExtArgs>;
      issuePriority?: boolean | Issue$issuePriorityArgs<ExtArgs>;
   };
   export type IssueIncludeUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      assignee?: boolean | Issue$assigneeArgs<ExtArgs>;
      project?: boolean | Issue$projectArgs<ExtArgs>;
      cycle?: boolean | Issue$cycleArgs<ExtArgs>;
      task?: boolean | Issue$taskArgs<ExtArgs>;
      issueStatus?: boolean | Issue$issueStatusArgs<ExtArgs>;
      issuePriority?: boolean | Issue$issuePriorityArgs<ExtArgs>;
   };

   export type $IssuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
      name: 'Issue';
      objects: {
         assignee: Prisma.$UserPayload<ExtArgs> | null;
         project: Prisma.$ProjectPayload<ExtArgs> | null;
         cycle: Prisma.$CyclePayload<ExtArgs> | null;
         task: Prisma.$TaskPayload<ExtArgs> | null;
         issueStatus: Prisma.$IssueStatusPayload<ExtArgs> | null;
         issuePriority: Prisma.$IssuePriorityPayload<ExtArgs> | null;
         labels: Prisma.$IssueLabelPayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
         {
            id: string;
            identifier: string;
            title: string;
            description: string;
            statusId: string | null;
            priorityId: string | null;
            status: string | null;
            priority: string | null;
            rank: string;
            cycleId: string | null;
            dueDate: Date | null;
            taskId: number | null;
            subtaskId: string | null;
            issueType: $Enums.IssueType;
            assigneeId: string | null;
            projectId: string | null;
            subissues: string;
            createdAt: Date;
            updatedAt: Date;
         },
         ExtArgs['result']['issue']
      >;
      composites: {};
   };

   type IssueGetPayload<S extends boolean | null | undefined | IssueDefaultArgs> =
      $Result.GetResult<Prisma.$IssuePayload, S>;

   type IssueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
      IssueFindManyArgs,
      'select' | 'include' | 'distinct' | 'omit'
   > & {
      select?: IssueCountAggregateInputType | true;
   };

   export interface IssueDelegate<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > {
      [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Issue']; meta: { name: 'Issue' } };
      /**
       * Find zero or one Issue that matches the filter.
       * @param {IssueFindUniqueArgs} args - Arguments to find a Issue
       * @example
       * // Get one Issue
       * const issue = await prisma.issue.findUnique({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUnique<T extends IssueFindUniqueArgs>(
         args: SelectSubset<T, IssueFindUniqueArgs<ExtArgs>>
      ): Prisma__IssueClient<
         $Result.GetResult<
            Prisma.$IssuePayload<ExtArgs>,
            T,
            'findUnique',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find one Issue that matches the filter or throw an error with `error.code='P2025'`
       * if no matches were found.
       * @param {IssueFindUniqueOrThrowArgs} args - Arguments to find a Issue
       * @example
       * // Get one Issue
       * const issue = await prisma.issue.findUniqueOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUniqueOrThrow<T extends IssueFindUniqueOrThrowArgs>(
         args: SelectSubset<T, IssueFindUniqueOrThrowArgs<ExtArgs>>
      ): Prisma__IssueClient<
         $Result.GetResult<
            Prisma.$IssuePayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first Issue that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueFindFirstArgs} args - Arguments to find a Issue
       * @example
       * // Get one Issue
       * const issue = await prisma.issue.findFirst({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirst<T extends IssueFindFirstArgs>(
         args?: SelectSubset<T, IssueFindFirstArgs<ExtArgs>>
      ): Prisma__IssueClient<
         $Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first Issue that matches the filter or
       * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueFindFirstOrThrowArgs} args - Arguments to find a Issue
       * @example
       * // Get one Issue
       * const issue = await prisma.issue.findFirstOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirstOrThrow<T extends IssueFindFirstOrThrowArgs>(
         args?: SelectSubset<T, IssueFindFirstOrThrowArgs<ExtArgs>>
      ): Prisma__IssueClient<
         $Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find zero or more Issues that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueFindManyArgs} args - Arguments to filter and select certain fields only.
       * @example
       * // Get all Issues
       * const issues = await prisma.issue.findMany()
       *
       * // Get first 10 Issues
       * const issues = await prisma.issue.findMany({ take: 10 })
       *
       * // Only select the `id`
       * const issueWithIdOnly = await prisma.issue.findMany({ select: { id: true } })
       *
       */
      findMany<T extends IssueFindManyArgs>(
         args?: SelectSubset<T, IssueFindManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      >;

      /**
       * Create a Issue.
       * @param {IssueCreateArgs} args - Arguments to create a Issue.
       * @example
       * // Create one Issue
       * const Issue = await prisma.issue.create({
       *   data: {
       *     // ... data to create a Issue
       *   }
       * })
       *
       */
      create<T extends IssueCreateArgs>(
         args: SelectSubset<T, IssueCreateArgs<ExtArgs>>
      ): Prisma__IssueClient<
         $Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Create many Issues.
       * @param {IssueCreateManyArgs} args - Arguments to create many Issues.
       * @example
       * // Create many Issues
       * const issue = await prisma.issue.createMany({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       */
      createMany<T extends IssueCreateManyArgs>(
         args?: SelectSubset<T, IssueCreateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Create many Issues and returns the data saved in the database.
       * @param {IssueCreateManyAndReturnArgs} args - Arguments to create many Issues.
       * @example
       * // Create many Issues
       * const issue = await prisma.issue.createManyAndReturn({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Create many Issues and only return the `id`
       * const issueWithIdOnly = await prisma.issue.createManyAndReturn({
       *   select: { id: true },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      createManyAndReturn<T extends IssueCreateManyAndReturnArgs>(
         args?: SelectSubset<T, IssueCreateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$IssuePayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Delete a Issue.
       * @param {IssueDeleteArgs} args - Arguments to delete one Issue.
       * @example
       * // Delete one Issue
       * const Issue = await prisma.issue.delete({
       *   where: {
       *     // ... filter to delete one Issue
       *   }
       * })
       *
       */
      delete<T extends IssueDeleteArgs>(
         args: SelectSubset<T, IssueDeleteArgs<ExtArgs>>
      ): Prisma__IssueClient<
         $Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Update one Issue.
       * @param {IssueUpdateArgs} args - Arguments to update one Issue.
       * @example
       * // Update one Issue
       * const issue = await prisma.issue.update({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      update<T extends IssueUpdateArgs>(
         args: SelectSubset<T, IssueUpdateArgs<ExtArgs>>
      ): Prisma__IssueClient<
         $Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Delete zero or more Issues.
       * @param {IssueDeleteManyArgs} args - Arguments to filter Issues to delete.
       * @example
       * // Delete a few Issues
       * const { count } = await prisma.issue.deleteMany({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       *
       */
      deleteMany<T extends IssueDeleteManyArgs>(
         args?: SelectSubset<T, IssueDeleteManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more Issues.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueUpdateManyArgs} args - Arguments to update one or more rows.
       * @example
       * // Update many Issues
       * const issue = await prisma.issue.updateMany({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      updateMany<T extends IssueUpdateManyArgs>(
         args: SelectSubset<T, IssueUpdateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more Issues and returns the data updated in the database.
       * @param {IssueUpdateManyAndReturnArgs} args - Arguments to update many Issues.
       * @example
       * // Update many Issues
       * const issue = await prisma.issue.updateManyAndReturn({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Update zero or more Issues and only return the `id`
       * const issueWithIdOnly = await prisma.issue.updateManyAndReturn({
       *   select: { id: true },
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      updateManyAndReturn<T extends IssueUpdateManyAndReturnArgs>(
         args: SelectSubset<T, IssueUpdateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$IssuePayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Create or update one Issue.
       * @param {IssueUpsertArgs} args - Arguments to update or create a Issue.
       * @example
       * // Update or create a Issue
       * const issue = await prisma.issue.upsert({
       *   create: {
       *     // ... data to create a Issue
       *   },
       *   update: {
       *     // ... in case it already exists, update
       *   },
       *   where: {
       *     // ... the filter for the Issue we want to update
       *   }
       * })
       */
      upsert<T extends IssueUpsertArgs>(
         args: SelectSubset<T, IssueUpsertArgs<ExtArgs>>
      ): Prisma__IssueClient<
         $Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Count the number of Issues.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueCountArgs} args - Arguments to filter Issues to count.
       * @example
       * // Count the number of Issues
       * const count = await prisma.issue.count({
       *   where: {
       *     // ... the filter for the Issues we want to count
       *   }
       * })
       **/
      count<T extends IssueCountArgs>(
         args?: Subset<T, IssueCountArgs>
      ): Prisma.PrismaPromise<
         T extends $Utils.Record<'select', any>
            ? T['select'] extends true
               ? number
               : GetScalarType<T['select'], IssueCountAggregateOutputType>
            : number
      >;

      /**
       * Allows you to perform aggregations operations on a Issue.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
       * @example
       * // Ordered by age ascending
       * // Where email contains prisma.io
       * // Limited to the 10 users
       * const aggregations = await prisma.user.aggregate({
       *   _avg: {
       *     age: true,
       *   },
       *   where: {
       *     email: {
       *       contains: "prisma.io",
       *     },
       *   },
       *   orderBy: {
       *     age: "asc",
       *   },
       *   take: 10,
       * })
       **/
      aggregate<T extends IssueAggregateArgs>(
         args: Subset<T, IssueAggregateArgs>
      ): Prisma.PrismaPromise<GetIssueAggregateType<T>>;

      /**
       * Group by Issue.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueGroupByArgs} args - Group by arguments.
       * @example
       * // Group by city, order by createdAt, get count
       * const result = await prisma.user.groupBy({
       *   by: ['city', 'createdAt'],
       *   orderBy: {
       *     createdAt: true
       *   },
       *   _count: {
       *     _all: true
       *   },
       * })
       *
       **/
      groupBy<
         T extends IssueGroupByArgs,
         HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
         OrderByArg extends True extends HasSelectOrTake
            ? { orderBy: IssueGroupByArgs['orderBy'] }
            : { orderBy?: IssueGroupByArgs['orderBy'] },
         OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
         ByFields extends MaybeTupleToUnion<T['by']>,
         ByValid extends Has<ByFields, OrderFields>,
         HavingFields extends GetHavingFields<T['having']>,
         HavingValid extends Has<ByFields, HavingFields>,
         ByEmpty extends T['by'] extends never[] ? True : False,
         InputErrors extends ByEmpty extends True
            ? `Error: "by" must not be empty.`
            : HavingValid extends False
              ? {
                   [P in HavingFields]: P extends ByFields
                      ? never
                      : P extends string
                        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                        : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Keys<T>
                ? 'orderBy' extends Keys<T>
                   ? ByValid extends True
                      ? {}
                      : {
                           [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                        }[OrderFields]
                   : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Keys<T>
                  ? 'orderBy' extends Keys<T>
                     ? ByValid extends True
                        ? {}
                        : {
                             [P in OrderFields]: P extends ByFields
                                ? never
                                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                     : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends True
                    ? {}
                    : {
                         [P in OrderFields]: P extends ByFields
                            ? never
                            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
      >(
         args: SubsetIntersection<T, IssueGroupByArgs, OrderByArg> & InputErrors
      ): {} extends InputErrors ? GetIssueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
      /**
       * Fields of the Issue model
       */
      readonly fields: IssueFieldRefs;
   }

   /**
    * The delegate class that acts as a "Promise-like" for Issue.
    * Why is this prefixed with `Prisma__`?
    * Because we want to prevent naming conflicts as mentioned in
    * https://github.com/prisma/prisma-client-js/issues/707
    */
   export interface Prisma__IssueClient<
      T,
      Null = never,
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > extends Prisma.PrismaPromise<T> {
      readonly [Symbol.toStringTag]: 'PrismaPromise';
      assignee<T extends Issue$assigneeArgs<ExtArgs> = {}>(
         args?: Subset<T, Issue$assigneeArgs<ExtArgs>>
      ): Prisma__UserClient<
         $Result.GetResult<
            Prisma.$UserPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;
      project<T extends Issue$projectArgs<ExtArgs> = {}>(
         args?: Subset<T, Issue$projectArgs<ExtArgs>>
      ): Prisma__ProjectClient<
         $Result.GetResult<
            Prisma.$ProjectPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;
      cycle<T extends Issue$cycleArgs<ExtArgs> = {}>(
         args?: Subset<T, Issue$cycleArgs<ExtArgs>>
      ): Prisma__CycleClient<
         $Result.GetResult<
            Prisma.$CyclePayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;
      task<T extends Issue$taskArgs<ExtArgs> = {}>(
         args?: Subset<T, Issue$taskArgs<ExtArgs>>
      ): Prisma__TaskClient<
         $Result.GetResult<
            Prisma.$TaskPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;
      issueStatus<T extends Issue$issueStatusArgs<ExtArgs> = {}>(
         args?: Subset<T, Issue$issueStatusArgs<ExtArgs>>
      ): Prisma__IssueStatusClient<
         $Result.GetResult<
            Prisma.$IssueStatusPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;
      issuePriority<T extends Issue$issuePriorityArgs<ExtArgs> = {}>(
         args?: Subset<T, Issue$issuePriorityArgs<ExtArgs>>
      ): Prisma__IssuePriorityClient<
         $Result.GetResult<
            Prisma.$IssuePriorityPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;
      labels<T extends Issue$labelsArgs<ExtArgs> = {}>(
         args?: Subset<T, Issue$labelsArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         | $Result.GetResult<Prisma.$IssueLabelPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
         | Null
      >;
      /**
       * Attaches callbacks for the resolution and/or rejection of the Promise.
       * @param onfulfilled The callback to execute when the Promise is resolved.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of which ever callback is executed.
       */
      then<TResult1 = T, TResult2 = never>(
         onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
         onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
      ): $Utils.JsPromise<TResult1 | TResult2>;
      /**
       * Attaches a callback for only the rejection of the Promise.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of the callback.
       */
      catch<TResult = never>(
         onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
      ): $Utils.JsPromise<T | TResult>;
      /**
       * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
       * resolved value cannot be modified from the callback.
       * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
       * @returns A Promise for the completion of the callback.
       */
      finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
   }

   /**
    * Fields of the Issue model
    */
   interface IssueFieldRefs {
      readonly id: FieldRef<'Issue', 'String'>;
      readonly identifier: FieldRef<'Issue', 'String'>;
      readonly title: FieldRef<'Issue', 'String'>;
      readonly description: FieldRef<'Issue', 'String'>;
      readonly statusId: FieldRef<'Issue', 'String'>;
      readonly priorityId: FieldRef<'Issue', 'String'>;
      readonly status: FieldRef<'Issue', 'String'>;
      readonly priority: FieldRef<'Issue', 'String'>;
      readonly rank: FieldRef<'Issue', 'String'>;
      readonly cycleId: FieldRef<'Issue', 'String'>;
      readonly dueDate: FieldRef<'Issue', 'DateTime'>;
      readonly taskId: FieldRef<'Issue', 'Int'>;
      readonly subtaskId: FieldRef<'Issue', 'String'>;
      readonly issueType: FieldRef<'Issue', 'IssueType'>;
      readonly assigneeId: FieldRef<'Issue', 'String'>;
      readonly projectId: FieldRef<'Issue', 'String'>;
      readonly subissues: FieldRef<'Issue', 'String'>;
      readonly createdAt: FieldRef<'Issue', 'DateTime'>;
      readonly updatedAt: FieldRef<'Issue', 'DateTime'>;
   }

   // Custom InputTypes
   /**
    * Issue findUnique
    */
   export type IssueFindUniqueArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Issue
       */
      select?: IssueSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Issue
       */
      omit?: IssueOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueInclude<ExtArgs> | null;
      /**
       * Filter, which Issue to fetch.
       */
      where: IssueWhereUniqueInput;
   };

   /**
    * Issue findUniqueOrThrow
    */
   export type IssueFindUniqueOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Issue
       */
      select?: IssueSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Issue
       */
      omit?: IssueOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueInclude<ExtArgs> | null;
      /**
       * Filter, which Issue to fetch.
       */
      where: IssueWhereUniqueInput;
   };

   /**
    * Issue findFirst
    */
   export type IssueFindFirstArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Issue
       */
      select?: IssueSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Issue
       */
      omit?: IssueOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueInclude<ExtArgs> | null;
      /**
       * Filter, which Issue to fetch.
       */
      where?: IssueWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Issues to fetch.
       */
      orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for Issues.
       */
      cursor?: IssueWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Issues from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Issues.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of Issues.
       */
      distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[];
   };

   /**
    * Issue findFirstOrThrow
    */
   export type IssueFindFirstOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Issue
       */
      select?: IssueSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Issue
       */
      omit?: IssueOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueInclude<ExtArgs> | null;
      /**
       * Filter, which Issue to fetch.
       */
      where?: IssueWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Issues to fetch.
       */
      orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for Issues.
       */
      cursor?: IssueWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Issues from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Issues.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of Issues.
       */
      distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[];
   };

   /**
    * Issue findMany
    */
   export type IssueFindManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Issue
       */
      select?: IssueSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Issue
       */
      omit?: IssueOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueInclude<ExtArgs> | null;
      /**
       * Filter, which Issues to fetch.
       */
      where?: IssueWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Issues to fetch.
       */
      orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Issues.
       */
      cursor?: IssueWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Issues from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Issues.
       */
      skip?: number;
      distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[];
   };

   /**
    * Issue create
    */
   export type IssueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Issue
          */
         select?: IssueSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Issue
          */
         omit?: IssueOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: IssueInclude<ExtArgs> | null;
         /**
          * The data needed to create a Issue.
          */
         data: XOR<IssueCreateInput, IssueUncheckedCreateInput>;
      };

   /**
    * Issue createMany
    */
   export type IssueCreateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to create many Issues.
       */
      data: IssueCreateManyInput | IssueCreateManyInput[];
   };

   /**
    * Issue createManyAndReturn
    */
   export type IssueCreateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Issue
       */
      select?: IssueSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the Issue
       */
      omit?: IssueOmit<ExtArgs> | null;
      /**
       * The data used to create many Issues.
       */
      data: IssueCreateManyInput | IssueCreateManyInput[];
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueIncludeCreateManyAndReturn<ExtArgs> | null;
   };

   /**
    * Issue update
    */
   export type IssueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Issue
          */
         select?: IssueSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Issue
          */
         omit?: IssueOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: IssueInclude<ExtArgs> | null;
         /**
          * The data needed to update a Issue.
          */
         data: XOR<IssueUpdateInput, IssueUncheckedUpdateInput>;
         /**
          * Choose, which Issue to update.
          */
         where: IssueWhereUniqueInput;
      };

   /**
    * Issue updateMany
    */
   export type IssueUpdateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to update Issues.
       */
      data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyInput>;
      /**
       * Filter which Issues to update
       */
      where?: IssueWhereInput;
      /**
       * Limit how many Issues to update.
       */
      limit?: number;
   };

   /**
    * Issue updateManyAndReturn
    */
   export type IssueUpdateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Issue
       */
      select?: IssueSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the Issue
       */
      omit?: IssueOmit<ExtArgs> | null;
      /**
       * The data used to update Issues.
       */
      data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyInput>;
      /**
       * Filter which Issues to update
       */
      where?: IssueWhereInput;
      /**
       * Limit how many Issues to update.
       */
      limit?: number;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueIncludeUpdateManyAndReturn<ExtArgs> | null;
   };

   /**
    * Issue upsert
    */
   export type IssueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Issue
          */
         select?: IssueSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Issue
          */
         omit?: IssueOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: IssueInclude<ExtArgs> | null;
         /**
          * The filter to search for the Issue to update in case it exists.
          */
         where: IssueWhereUniqueInput;
         /**
          * In case the Issue found by the `where` argument doesn't exist, create a new Issue with this data.
          */
         create: XOR<IssueCreateInput, IssueUncheckedCreateInput>;
         /**
          * In case the Issue was found with the provided `where` argument, update it with this data.
          */
         update: XOR<IssueUpdateInput, IssueUncheckedUpdateInput>;
      };

   /**
    * Issue delete
    */
   export type IssueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Issue
          */
         select?: IssueSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Issue
          */
         omit?: IssueOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: IssueInclude<ExtArgs> | null;
         /**
          * Filter which Issue to delete.
          */
         where: IssueWhereUniqueInput;
      };

   /**
    * Issue deleteMany
    */
   export type IssueDeleteManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which Issues to delete
       */
      where?: IssueWhereInput;
      /**
       * Limit how many Issues to delete.
       */
      limit?: number;
   };

   /**
    * Issue.assignee
    */
   export type Issue$assigneeArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the User
       */
      select?: UserSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the User
       */
      omit?: UserOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: UserInclude<ExtArgs> | null;
      where?: UserWhereInput;
   };

   /**
    * Issue.project
    */
   export type Issue$projectArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Project
       */
      select?: ProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Project
       */
      omit?: ProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: ProjectInclude<ExtArgs> | null;
      where?: ProjectWhereInput;
   };

   /**
    * Issue.cycle
    */
   export type Issue$cycleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Cycle
          */
         select?: CycleSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Cycle
          */
         omit?: CycleOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: CycleInclude<ExtArgs> | null;
         where?: CycleWhereInput;
      };

   /**
    * Issue.task
    */
   export type Issue$taskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Task
          */
         select?: TaskSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Task
          */
         omit?: TaskOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: TaskInclude<ExtArgs> | null;
         where?: TaskWhereInput;
      };

   /**
    * Issue.issueStatus
    */
   export type Issue$issueStatusArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueStatus
       */
      select?: IssueStatusSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueStatus
       */
      omit?: IssueStatusOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueStatusInclude<ExtArgs> | null;
      where?: IssueStatusWhereInput;
   };

   /**
    * Issue.issuePriority
    */
   export type Issue$issuePriorityArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssuePriority
       */
      select?: IssuePrioritySelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssuePriority
       */
      omit?: IssuePriorityOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssuePriorityInclude<ExtArgs> | null;
      where?: IssuePriorityWhereInput;
   };

   /**
    * Issue.labels
    */
   export type Issue$labelsArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueLabel
       */
      select?: IssueLabelSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueLabel
       */
      omit?: IssueLabelOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueLabelInclude<ExtArgs> | null;
      where?: IssueLabelWhereInput;
      orderBy?: IssueLabelOrderByWithRelationInput | IssueLabelOrderByWithRelationInput[];
      cursor?: IssueLabelWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: IssueLabelScalarFieldEnum | IssueLabelScalarFieldEnum[];
   };

   /**
    * Issue without action
    */
   export type IssueDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Issue
       */
      select?: IssueSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Issue
       */
      omit?: IssueOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueInclude<ExtArgs> | null;
   };

   /**
    * Model IssueLabel
    */

   export type AggregateIssueLabel = {
      _count: IssueLabelCountAggregateOutputType | null;
      _min: IssueLabelMinAggregateOutputType | null;
      _max: IssueLabelMaxAggregateOutputType | null;
   };

   export type IssueLabelMinAggregateOutputType = {
      id: string | null;
      issueId: string | null;
      labelId: string | null;
   };

   export type IssueLabelMaxAggregateOutputType = {
      id: string | null;
      issueId: string | null;
      labelId: string | null;
   };

   export type IssueLabelCountAggregateOutputType = {
      id: number;
      issueId: number;
      labelId: number;
      _all: number;
   };

   export type IssueLabelMinAggregateInputType = {
      id?: true;
      issueId?: true;
      labelId?: true;
   };

   export type IssueLabelMaxAggregateInputType = {
      id?: true;
      issueId?: true;
      labelId?: true;
   };

   export type IssueLabelCountAggregateInputType = {
      id?: true;
      issueId?: true;
      labelId?: true;
      _all?: true;
   };

   export type IssueLabelAggregateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which IssueLabel to aggregate.
       */
      where?: IssueLabelWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of IssueLabels to fetch.
       */
      orderBy?: IssueLabelOrderByWithRelationInput | IssueLabelOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: IssueLabelWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` IssueLabels from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` IssueLabels.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned IssueLabels
       **/
      _count?: true | IssueLabelCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: IssueLabelMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: IssueLabelMaxAggregateInputType;
   };

   export type GetIssueLabelAggregateType<T extends IssueLabelAggregateArgs> = {
      [P in keyof T & keyof AggregateIssueLabel]: P extends '_count' | 'count'
         ? T[P] extends true
            ? number
            : GetScalarType<T[P], AggregateIssueLabel[P]>
         : GetScalarType<T[P], AggregateIssueLabel[P]>;
   };

   export type IssueLabelGroupByArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: IssueLabelWhereInput;
      orderBy?: IssueLabelOrderByWithAggregationInput | IssueLabelOrderByWithAggregationInput[];
      by: IssueLabelScalarFieldEnum[] | IssueLabelScalarFieldEnum;
      having?: IssueLabelScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: IssueLabelCountAggregateInputType | true;
      _min?: IssueLabelMinAggregateInputType;
      _max?: IssueLabelMaxAggregateInputType;
   };

   export type IssueLabelGroupByOutputType = {
      id: string;
      issueId: string;
      labelId: string;
      _count: IssueLabelCountAggregateOutputType | null;
      _min: IssueLabelMinAggregateOutputType | null;
      _max: IssueLabelMaxAggregateOutputType | null;
   };

   type GetIssueLabelGroupByPayload<T extends IssueLabelGroupByArgs> = Prisma.PrismaPromise<
      Array<
         PickEnumerable<IssueLabelGroupByOutputType, T['by']> & {
            [P in keyof T & keyof IssueLabelGroupByOutputType]: P extends '_count'
               ? T[P] extends boolean
                  ? number
                  : GetScalarType<T[P], IssueLabelGroupByOutputType[P]>
               : GetScalarType<T[P], IssueLabelGroupByOutputType[P]>;
         }
      >
   >;

   export type IssueLabelSelect<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         issueId?: boolean;
         labelId?: boolean;
         issue?: boolean | IssueDefaultArgs<ExtArgs>;
         label?: boolean | LabelDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['issueLabel']
   >;

   export type IssueLabelSelectCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         issueId?: boolean;
         labelId?: boolean;
         issue?: boolean | IssueDefaultArgs<ExtArgs>;
         label?: boolean | LabelDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['issueLabel']
   >;

   export type IssueLabelSelectUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         issueId?: boolean;
         labelId?: boolean;
         issue?: boolean | IssueDefaultArgs<ExtArgs>;
         label?: boolean | LabelDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['issueLabel']
   >;

   export type IssueLabelSelectScalar = {
      id?: boolean;
      issueId?: boolean;
      labelId?: boolean;
   };

   export type IssueLabelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetOmit<'id' | 'issueId' | 'labelId', ExtArgs['result']['issueLabel']>;
   export type IssueLabelInclude<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      issue?: boolean | IssueDefaultArgs<ExtArgs>;
      label?: boolean | LabelDefaultArgs<ExtArgs>;
   };
   export type IssueLabelIncludeCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      issue?: boolean | IssueDefaultArgs<ExtArgs>;
      label?: boolean | LabelDefaultArgs<ExtArgs>;
   };
   export type IssueLabelIncludeUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      issue?: boolean | IssueDefaultArgs<ExtArgs>;
      label?: boolean | LabelDefaultArgs<ExtArgs>;
   };

   export type $IssueLabelPayload<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      name: 'IssueLabel';
      objects: {
         issue: Prisma.$IssuePayload<ExtArgs>;
         label: Prisma.$LabelPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
         {
            id: string;
            issueId: string;
            labelId: string;
         },
         ExtArgs['result']['issueLabel']
      >;
      composites: {};
   };

   type IssueLabelGetPayload<S extends boolean | null | undefined | IssueLabelDefaultArgs> =
      $Result.GetResult<Prisma.$IssueLabelPayload, S>;

   type IssueLabelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      Omit<IssueLabelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
         select?: IssueLabelCountAggregateInputType | true;
      };

   export interface IssueLabelDelegate<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > {
      [K: symbol]: {
         types: Prisma.TypeMap<ExtArgs>['model']['IssueLabel'];
         meta: { name: 'IssueLabel' };
      };
      /**
       * Find zero or one IssueLabel that matches the filter.
       * @param {IssueLabelFindUniqueArgs} args - Arguments to find a IssueLabel
       * @example
       * // Get one IssueLabel
       * const issueLabel = await prisma.issueLabel.findUnique({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUnique<T extends IssueLabelFindUniqueArgs>(
         args: SelectSubset<T, IssueLabelFindUniqueArgs<ExtArgs>>
      ): Prisma__IssueLabelClient<
         $Result.GetResult<
            Prisma.$IssueLabelPayload<ExtArgs>,
            T,
            'findUnique',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find one IssueLabel that matches the filter or throw an error with `error.code='P2025'`
       * if no matches were found.
       * @param {IssueLabelFindUniqueOrThrowArgs} args - Arguments to find a IssueLabel
       * @example
       * // Get one IssueLabel
       * const issueLabel = await prisma.issueLabel.findUniqueOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUniqueOrThrow<T extends IssueLabelFindUniqueOrThrowArgs>(
         args: SelectSubset<T, IssueLabelFindUniqueOrThrowArgs<ExtArgs>>
      ): Prisma__IssueLabelClient<
         $Result.GetResult<
            Prisma.$IssueLabelPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first IssueLabel that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueLabelFindFirstArgs} args - Arguments to find a IssueLabel
       * @example
       * // Get one IssueLabel
       * const issueLabel = await prisma.issueLabel.findFirst({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirst<T extends IssueLabelFindFirstArgs>(
         args?: SelectSubset<T, IssueLabelFindFirstArgs<ExtArgs>>
      ): Prisma__IssueLabelClient<
         $Result.GetResult<
            Prisma.$IssueLabelPayload<ExtArgs>,
            T,
            'findFirst',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first IssueLabel that matches the filter or
       * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueLabelFindFirstOrThrowArgs} args - Arguments to find a IssueLabel
       * @example
       * // Get one IssueLabel
       * const issueLabel = await prisma.issueLabel.findFirstOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirstOrThrow<T extends IssueLabelFindFirstOrThrowArgs>(
         args?: SelectSubset<T, IssueLabelFindFirstOrThrowArgs<ExtArgs>>
      ): Prisma__IssueLabelClient<
         $Result.GetResult<
            Prisma.$IssueLabelPayload<ExtArgs>,
            T,
            'findFirstOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find zero or more IssueLabels that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueLabelFindManyArgs} args - Arguments to filter and select certain fields only.
       * @example
       * // Get all IssueLabels
       * const issueLabels = await prisma.issueLabel.findMany()
       *
       * // Get first 10 IssueLabels
       * const issueLabels = await prisma.issueLabel.findMany({ take: 10 })
       *
       * // Only select the `id`
       * const issueLabelWithIdOnly = await prisma.issueLabel.findMany({ select: { id: true } })
       *
       */
      findMany<T extends IssueLabelFindManyArgs>(
         args?: SelectSubset<T, IssueLabelFindManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$IssueLabelPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      >;

      /**
       * Create a IssueLabel.
       * @param {IssueLabelCreateArgs} args - Arguments to create a IssueLabel.
       * @example
       * // Create one IssueLabel
       * const IssueLabel = await prisma.issueLabel.create({
       *   data: {
       *     // ... data to create a IssueLabel
       *   }
       * })
       *
       */
      create<T extends IssueLabelCreateArgs>(
         args: SelectSubset<T, IssueLabelCreateArgs<ExtArgs>>
      ): Prisma__IssueLabelClient<
         $Result.GetResult<Prisma.$IssueLabelPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Create many IssueLabels.
       * @param {IssueLabelCreateManyArgs} args - Arguments to create many IssueLabels.
       * @example
       * // Create many IssueLabels
       * const issueLabel = await prisma.issueLabel.createMany({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       */
      createMany<T extends IssueLabelCreateManyArgs>(
         args?: SelectSubset<T, IssueLabelCreateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Create many IssueLabels and returns the data saved in the database.
       * @param {IssueLabelCreateManyAndReturnArgs} args - Arguments to create many IssueLabels.
       * @example
       * // Create many IssueLabels
       * const issueLabel = await prisma.issueLabel.createManyAndReturn({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Create many IssueLabels and only return the `id`
       * const issueLabelWithIdOnly = await prisma.issueLabel.createManyAndReturn({
       *   select: { id: true },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      createManyAndReturn<T extends IssueLabelCreateManyAndReturnArgs>(
         args?: SelectSubset<T, IssueLabelCreateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$IssueLabelPayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Delete a IssueLabel.
       * @param {IssueLabelDeleteArgs} args - Arguments to delete one IssueLabel.
       * @example
       * // Delete one IssueLabel
       * const IssueLabel = await prisma.issueLabel.delete({
       *   where: {
       *     // ... filter to delete one IssueLabel
       *   }
       * })
       *
       */
      delete<T extends IssueLabelDeleteArgs>(
         args: SelectSubset<T, IssueLabelDeleteArgs<ExtArgs>>
      ): Prisma__IssueLabelClient<
         $Result.GetResult<Prisma.$IssueLabelPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Update one IssueLabel.
       * @param {IssueLabelUpdateArgs} args - Arguments to update one IssueLabel.
       * @example
       * // Update one IssueLabel
       * const issueLabel = await prisma.issueLabel.update({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      update<T extends IssueLabelUpdateArgs>(
         args: SelectSubset<T, IssueLabelUpdateArgs<ExtArgs>>
      ): Prisma__IssueLabelClient<
         $Result.GetResult<Prisma.$IssueLabelPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Delete zero or more IssueLabels.
       * @param {IssueLabelDeleteManyArgs} args - Arguments to filter IssueLabels to delete.
       * @example
       * // Delete a few IssueLabels
       * const { count } = await prisma.issueLabel.deleteMany({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       *
       */
      deleteMany<T extends IssueLabelDeleteManyArgs>(
         args?: SelectSubset<T, IssueLabelDeleteManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more IssueLabels.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueLabelUpdateManyArgs} args - Arguments to update one or more rows.
       * @example
       * // Update many IssueLabels
       * const issueLabel = await prisma.issueLabel.updateMany({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      updateMany<T extends IssueLabelUpdateManyArgs>(
         args: SelectSubset<T, IssueLabelUpdateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more IssueLabels and returns the data updated in the database.
       * @param {IssueLabelUpdateManyAndReturnArgs} args - Arguments to update many IssueLabels.
       * @example
       * // Update many IssueLabels
       * const issueLabel = await prisma.issueLabel.updateManyAndReturn({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Update zero or more IssueLabels and only return the `id`
       * const issueLabelWithIdOnly = await prisma.issueLabel.updateManyAndReturn({
       *   select: { id: true },
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      updateManyAndReturn<T extends IssueLabelUpdateManyAndReturnArgs>(
         args: SelectSubset<T, IssueLabelUpdateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$IssueLabelPayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Create or update one IssueLabel.
       * @param {IssueLabelUpsertArgs} args - Arguments to update or create a IssueLabel.
       * @example
       * // Update or create a IssueLabel
       * const issueLabel = await prisma.issueLabel.upsert({
       *   create: {
       *     // ... data to create a IssueLabel
       *   },
       *   update: {
       *     // ... in case it already exists, update
       *   },
       *   where: {
       *     // ... the filter for the IssueLabel we want to update
       *   }
       * })
       */
      upsert<T extends IssueLabelUpsertArgs>(
         args: SelectSubset<T, IssueLabelUpsertArgs<ExtArgs>>
      ): Prisma__IssueLabelClient<
         $Result.GetResult<Prisma.$IssueLabelPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Count the number of IssueLabels.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueLabelCountArgs} args - Arguments to filter IssueLabels to count.
       * @example
       * // Count the number of IssueLabels
       * const count = await prisma.issueLabel.count({
       *   where: {
       *     // ... the filter for the IssueLabels we want to count
       *   }
       * })
       **/
      count<T extends IssueLabelCountArgs>(
         args?: Subset<T, IssueLabelCountArgs>
      ): Prisma.PrismaPromise<
         T extends $Utils.Record<'select', any>
            ? T['select'] extends true
               ? number
               : GetScalarType<T['select'], IssueLabelCountAggregateOutputType>
            : number
      >;

      /**
       * Allows you to perform aggregations operations on a IssueLabel.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueLabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
       * @example
       * // Ordered by age ascending
       * // Where email contains prisma.io
       * // Limited to the 10 users
       * const aggregations = await prisma.user.aggregate({
       *   _avg: {
       *     age: true,
       *   },
       *   where: {
       *     email: {
       *       contains: "prisma.io",
       *     },
       *   },
       *   orderBy: {
       *     age: "asc",
       *   },
       *   take: 10,
       * })
       **/
      aggregate<T extends IssueLabelAggregateArgs>(
         args: Subset<T, IssueLabelAggregateArgs>
      ): Prisma.PrismaPromise<GetIssueLabelAggregateType<T>>;

      /**
       * Group by IssueLabel.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {IssueLabelGroupByArgs} args - Group by arguments.
       * @example
       * // Group by city, order by createdAt, get count
       * const result = await prisma.user.groupBy({
       *   by: ['city', 'createdAt'],
       *   orderBy: {
       *     createdAt: true
       *   },
       *   _count: {
       *     _all: true
       *   },
       * })
       *
       **/
      groupBy<
         T extends IssueLabelGroupByArgs,
         HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
         OrderByArg extends True extends HasSelectOrTake
            ? { orderBy: IssueLabelGroupByArgs['orderBy'] }
            : { orderBy?: IssueLabelGroupByArgs['orderBy'] },
         OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
         ByFields extends MaybeTupleToUnion<T['by']>,
         ByValid extends Has<ByFields, OrderFields>,
         HavingFields extends GetHavingFields<T['having']>,
         HavingValid extends Has<ByFields, HavingFields>,
         ByEmpty extends T['by'] extends never[] ? True : False,
         InputErrors extends ByEmpty extends True
            ? `Error: "by" must not be empty.`
            : HavingValid extends False
              ? {
                   [P in HavingFields]: P extends ByFields
                      ? never
                      : P extends string
                        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                        : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Keys<T>
                ? 'orderBy' extends Keys<T>
                   ? ByValid extends True
                      ? {}
                      : {
                           [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                        }[OrderFields]
                   : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Keys<T>
                  ? 'orderBy' extends Keys<T>
                     ? ByValid extends True
                        ? {}
                        : {
                             [P in OrderFields]: P extends ByFields
                                ? never
                                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                     : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends True
                    ? {}
                    : {
                         [P in OrderFields]: P extends ByFields
                            ? never
                            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
      >(
         args: SubsetIntersection<T, IssueLabelGroupByArgs, OrderByArg> & InputErrors
      ): {} extends InputErrors
         ? GetIssueLabelGroupByPayload<T>
         : Prisma.PrismaPromise<InputErrors>;
      /**
       * Fields of the IssueLabel model
       */
      readonly fields: IssueLabelFieldRefs;
   }

   /**
    * The delegate class that acts as a "Promise-like" for IssueLabel.
    * Why is this prefixed with `Prisma__`?
    * Because we want to prevent naming conflicts as mentioned in
    * https://github.com/prisma/prisma-client-js/issues/707
    */
   export interface Prisma__IssueLabelClient<
      T,
      Null = never,
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > extends Prisma.PrismaPromise<T> {
      readonly [Symbol.toStringTag]: 'PrismaPromise';
      issue<T extends IssueDefaultArgs<ExtArgs> = {}>(
         args?: Subset<T, IssueDefaultArgs<ExtArgs>>
      ): Prisma__IssueClient<
         | $Result.GetResult<
              Prisma.$IssuePayload<ExtArgs>,
              T,
              'findUniqueOrThrow',
              GlobalOmitOptions
           >
         | Null,
         Null,
         ExtArgs,
         GlobalOmitOptions
      >;
      label<T extends LabelDefaultArgs<ExtArgs> = {}>(
         args?: Subset<T, LabelDefaultArgs<ExtArgs>>
      ): Prisma__LabelClient<
         | $Result.GetResult<
              Prisma.$LabelPayload<ExtArgs>,
              T,
              'findUniqueOrThrow',
              GlobalOmitOptions
           >
         | Null,
         Null,
         ExtArgs,
         GlobalOmitOptions
      >;
      /**
       * Attaches callbacks for the resolution and/or rejection of the Promise.
       * @param onfulfilled The callback to execute when the Promise is resolved.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of which ever callback is executed.
       */
      then<TResult1 = T, TResult2 = never>(
         onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
         onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
      ): $Utils.JsPromise<TResult1 | TResult2>;
      /**
       * Attaches a callback for only the rejection of the Promise.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of the callback.
       */
      catch<TResult = never>(
         onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
      ): $Utils.JsPromise<T | TResult>;
      /**
       * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
       * resolved value cannot be modified from the callback.
       * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
       * @returns A Promise for the completion of the callback.
       */
      finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
   }

   /**
    * Fields of the IssueLabel model
    */
   interface IssueLabelFieldRefs {
      readonly id: FieldRef<'IssueLabel', 'String'>;
      readonly issueId: FieldRef<'IssueLabel', 'String'>;
      readonly labelId: FieldRef<'IssueLabel', 'String'>;
   }

   // Custom InputTypes
   /**
    * IssueLabel findUnique
    */
   export type IssueLabelFindUniqueArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueLabel
       */
      select?: IssueLabelSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueLabel
       */
      omit?: IssueLabelOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueLabelInclude<ExtArgs> | null;
      /**
       * Filter, which IssueLabel to fetch.
       */
      where: IssueLabelWhereUniqueInput;
   };

   /**
    * IssueLabel findUniqueOrThrow
    */
   export type IssueLabelFindUniqueOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueLabel
       */
      select?: IssueLabelSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueLabel
       */
      omit?: IssueLabelOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueLabelInclude<ExtArgs> | null;
      /**
       * Filter, which IssueLabel to fetch.
       */
      where: IssueLabelWhereUniqueInput;
   };

   /**
    * IssueLabel findFirst
    */
   export type IssueLabelFindFirstArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueLabel
       */
      select?: IssueLabelSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueLabel
       */
      omit?: IssueLabelOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueLabelInclude<ExtArgs> | null;
      /**
       * Filter, which IssueLabel to fetch.
       */
      where?: IssueLabelWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of IssueLabels to fetch.
       */
      orderBy?: IssueLabelOrderByWithRelationInput | IssueLabelOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for IssueLabels.
       */
      cursor?: IssueLabelWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` IssueLabels from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` IssueLabels.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of IssueLabels.
       */
      distinct?: IssueLabelScalarFieldEnum | IssueLabelScalarFieldEnum[];
   };

   /**
    * IssueLabel findFirstOrThrow
    */
   export type IssueLabelFindFirstOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueLabel
       */
      select?: IssueLabelSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueLabel
       */
      omit?: IssueLabelOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueLabelInclude<ExtArgs> | null;
      /**
       * Filter, which IssueLabel to fetch.
       */
      where?: IssueLabelWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of IssueLabels to fetch.
       */
      orderBy?: IssueLabelOrderByWithRelationInput | IssueLabelOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for IssueLabels.
       */
      cursor?: IssueLabelWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` IssueLabels from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` IssueLabels.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of IssueLabels.
       */
      distinct?: IssueLabelScalarFieldEnum | IssueLabelScalarFieldEnum[];
   };

   /**
    * IssueLabel findMany
    */
   export type IssueLabelFindManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueLabel
       */
      select?: IssueLabelSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueLabel
       */
      omit?: IssueLabelOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueLabelInclude<ExtArgs> | null;
      /**
       * Filter, which IssueLabels to fetch.
       */
      where?: IssueLabelWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of IssueLabels to fetch.
       */
      orderBy?: IssueLabelOrderByWithRelationInput | IssueLabelOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing IssueLabels.
       */
      cursor?: IssueLabelWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` IssueLabels from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` IssueLabels.
       */
      skip?: number;
      distinct?: IssueLabelScalarFieldEnum | IssueLabelScalarFieldEnum[];
   };

   /**
    * IssueLabel create
    */
   export type IssueLabelCreateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueLabel
       */
      select?: IssueLabelSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueLabel
       */
      omit?: IssueLabelOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueLabelInclude<ExtArgs> | null;
      /**
       * The data needed to create a IssueLabel.
       */
      data: XOR<IssueLabelCreateInput, IssueLabelUncheckedCreateInput>;
   };

   /**
    * IssueLabel createMany
    */
   export type IssueLabelCreateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to create many IssueLabels.
       */
      data: IssueLabelCreateManyInput | IssueLabelCreateManyInput[];
   };

   /**
    * IssueLabel createManyAndReturn
    */
   export type IssueLabelCreateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueLabel
       */
      select?: IssueLabelSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueLabel
       */
      omit?: IssueLabelOmit<ExtArgs> | null;
      /**
       * The data used to create many IssueLabels.
       */
      data: IssueLabelCreateManyInput | IssueLabelCreateManyInput[];
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueLabelIncludeCreateManyAndReturn<ExtArgs> | null;
   };

   /**
    * IssueLabel update
    */
   export type IssueLabelUpdateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueLabel
       */
      select?: IssueLabelSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueLabel
       */
      omit?: IssueLabelOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueLabelInclude<ExtArgs> | null;
      /**
       * The data needed to update a IssueLabel.
       */
      data: XOR<IssueLabelUpdateInput, IssueLabelUncheckedUpdateInput>;
      /**
       * Choose, which IssueLabel to update.
       */
      where: IssueLabelWhereUniqueInput;
   };

   /**
    * IssueLabel updateMany
    */
   export type IssueLabelUpdateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to update IssueLabels.
       */
      data: XOR<IssueLabelUpdateManyMutationInput, IssueLabelUncheckedUpdateManyInput>;
      /**
       * Filter which IssueLabels to update
       */
      where?: IssueLabelWhereInput;
      /**
       * Limit how many IssueLabels to update.
       */
      limit?: number;
   };

   /**
    * IssueLabel updateManyAndReturn
    */
   export type IssueLabelUpdateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueLabel
       */
      select?: IssueLabelSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueLabel
       */
      omit?: IssueLabelOmit<ExtArgs> | null;
      /**
       * The data used to update IssueLabels.
       */
      data: XOR<IssueLabelUpdateManyMutationInput, IssueLabelUncheckedUpdateManyInput>;
      /**
       * Filter which IssueLabels to update
       */
      where?: IssueLabelWhereInput;
      /**
       * Limit how many IssueLabels to update.
       */
      limit?: number;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueLabelIncludeUpdateManyAndReturn<ExtArgs> | null;
   };

   /**
    * IssueLabel upsert
    */
   export type IssueLabelUpsertArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueLabel
       */
      select?: IssueLabelSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueLabel
       */
      omit?: IssueLabelOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueLabelInclude<ExtArgs> | null;
      /**
       * The filter to search for the IssueLabel to update in case it exists.
       */
      where: IssueLabelWhereUniqueInput;
      /**
       * In case the IssueLabel found by the `where` argument doesn't exist, create a new IssueLabel with this data.
       */
      create: XOR<IssueLabelCreateInput, IssueLabelUncheckedCreateInput>;
      /**
       * In case the IssueLabel was found with the provided `where` argument, update it with this data.
       */
      update: XOR<IssueLabelUpdateInput, IssueLabelUncheckedUpdateInput>;
   };

   /**
    * IssueLabel delete
    */
   export type IssueLabelDeleteArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueLabel
       */
      select?: IssueLabelSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueLabel
       */
      omit?: IssueLabelOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueLabelInclude<ExtArgs> | null;
      /**
       * Filter which IssueLabel to delete.
       */
      where: IssueLabelWhereUniqueInput;
   };

   /**
    * IssueLabel deleteMany
    */
   export type IssueLabelDeleteManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which IssueLabels to delete
       */
      where?: IssueLabelWhereInput;
      /**
       * Limit how many IssueLabels to delete.
       */
      limit?: number;
   };

   /**
    * IssueLabel without action
    */
   export type IssueLabelDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the IssueLabel
       */
      select?: IssueLabelSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the IssueLabel
       */
      omit?: IssueLabelOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueLabelInclude<ExtArgs> | null;
   };

   /**
    * Model Cycle
    */

   export type AggregateCycle = {
      _count: CycleCountAggregateOutputType | null;
      _avg: CycleAvgAggregateOutputType | null;
      _sum: CycleSumAggregateOutputType | null;
      _min: CycleMinAggregateOutputType | null;
      _max: CycleMaxAggregateOutputType | null;
   };

   export type CycleAvgAggregateOutputType = {
      number: number | null;
      progress: number | null;
   };

   export type CycleSumAggregateOutputType = {
      number: number | null;
      progress: number | null;
   };

   export type CycleMinAggregateOutputType = {
      id: string | null;
      number: number | null;
      name: string | null;
      teamId: string | null;
      startDate: Date | null;
      endDate: Date | null;
      progress: number | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type CycleMaxAggregateOutputType = {
      id: string | null;
      number: number | null;
      name: string | null;
      teamId: string | null;
      startDate: Date | null;
      endDate: Date | null;
      progress: number | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type CycleCountAggregateOutputType = {
      id: number;
      number: number;
      name: number;
      teamId: number;
      startDate: number;
      endDate: number;
      progress: number;
      createdAt: number;
      updatedAt: number;
      _all: number;
   };

   export type CycleAvgAggregateInputType = {
      number?: true;
      progress?: true;
   };

   export type CycleSumAggregateInputType = {
      number?: true;
      progress?: true;
   };

   export type CycleMinAggregateInputType = {
      id?: true;
      number?: true;
      name?: true;
      teamId?: true;
      startDate?: true;
      endDate?: true;
      progress?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type CycleMaxAggregateInputType = {
      id?: true;
      number?: true;
      name?: true;
      teamId?: true;
      startDate?: true;
      endDate?: true;
      progress?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type CycleCountAggregateInputType = {
      id?: true;
      number?: true;
      name?: true;
      teamId?: true;
      startDate?: true;
      endDate?: true;
      progress?: true;
      createdAt?: true;
      updatedAt?: true;
      _all?: true;
   };

   export type CycleAggregateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which Cycle to aggregate.
       */
      where?: CycleWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Cycles to fetch.
       */
      orderBy?: CycleOrderByWithRelationInput | CycleOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: CycleWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Cycles from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Cycles.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned Cycles
       **/
      _count?: true | CycleCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to average
       **/
      _avg?: CycleAvgAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to sum
       **/
      _sum?: CycleSumAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: CycleMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: CycleMaxAggregateInputType;
   };

   export type GetCycleAggregateType<T extends CycleAggregateArgs> = {
      [P in keyof T & keyof AggregateCycle]: P extends '_count' | 'count'
         ? T[P] extends true
            ? number
            : GetScalarType<T[P], AggregateCycle[P]>
         : GetScalarType<T[P], AggregateCycle[P]>;
   };

   export type CycleGroupByArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: CycleWhereInput;
      orderBy?: CycleOrderByWithAggregationInput | CycleOrderByWithAggregationInput[];
      by: CycleScalarFieldEnum[] | CycleScalarFieldEnum;
      having?: CycleScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: CycleCountAggregateInputType | true;
      _avg?: CycleAvgAggregateInputType;
      _sum?: CycleSumAggregateInputType;
      _min?: CycleMinAggregateInputType;
      _max?: CycleMaxAggregateInputType;
   };

   export type CycleGroupByOutputType = {
      id: string;
      number: number;
      name: string;
      teamId: string;
      startDate: Date;
      endDate: Date;
      progress: number;
      createdAt: Date;
      updatedAt: Date;
      _count: CycleCountAggregateOutputType | null;
      _avg: CycleAvgAggregateOutputType | null;
      _sum: CycleSumAggregateOutputType | null;
      _min: CycleMinAggregateOutputType | null;
      _max: CycleMaxAggregateOutputType | null;
   };

   type GetCycleGroupByPayload<T extends CycleGroupByArgs> = Prisma.PrismaPromise<
      Array<
         PickEnumerable<CycleGroupByOutputType, T['by']> & {
            [P in keyof T & keyof CycleGroupByOutputType]: P extends '_count'
               ? T[P] extends boolean
                  ? number
                  : GetScalarType<T[P], CycleGroupByOutputType[P]>
               : GetScalarType<T[P], CycleGroupByOutputType[P]>;
         }
      >
   >;

   export type CycleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetSelect<
         {
            id?: boolean;
            number?: boolean;
            name?: boolean;
            teamId?: boolean;
            startDate?: boolean;
            endDate?: boolean;
            progress?: boolean;
            createdAt?: boolean;
            updatedAt?: boolean;
            team?: boolean | TeamDefaultArgs<ExtArgs>;
            issues?: boolean | Cycle$issuesArgs<ExtArgs>;
            _count?: boolean | CycleCountOutputTypeDefaultArgs<ExtArgs>;
         },
         ExtArgs['result']['cycle']
      >;

   export type CycleSelectCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         number?: boolean;
         name?: boolean;
         teamId?: boolean;
         startDate?: boolean;
         endDate?: boolean;
         progress?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
         team?: boolean | TeamDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['cycle']
   >;

   export type CycleSelectUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         number?: boolean;
         name?: boolean;
         teamId?: boolean;
         startDate?: boolean;
         endDate?: boolean;
         progress?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
         team?: boolean | TeamDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['cycle']
   >;

   export type CycleSelectScalar = {
      id?: boolean;
      number?: boolean;
      name?: boolean;
      teamId?: boolean;
      startDate?: boolean;
      endDate?: boolean;
      progress?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
   };

   export type CycleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetOmit<
         | 'id'
         | 'number'
         | 'name'
         | 'teamId'
         | 'startDate'
         | 'endDate'
         | 'progress'
         | 'createdAt'
         | 'updatedAt',
         ExtArgs['result']['cycle']
      >;
   export type CycleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
      team?: boolean | TeamDefaultArgs<ExtArgs>;
      issues?: boolean | Cycle$issuesArgs<ExtArgs>;
      _count?: boolean | CycleCountOutputTypeDefaultArgs<ExtArgs>;
   };
   export type CycleIncludeCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      team?: boolean | TeamDefaultArgs<ExtArgs>;
   };
   export type CycleIncludeUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      team?: boolean | TeamDefaultArgs<ExtArgs>;
   };

   export type $CyclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
      name: 'Cycle';
      objects: {
         team: Prisma.$TeamPayload<ExtArgs>;
         issues: Prisma.$IssuePayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
         {
            id: string;
            number: number;
            name: string;
            teamId: string;
            startDate: Date;
            endDate: Date;
            progress: number;
            createdAt: Date;
            updatedAt: Date;
         },
         ExtArgs['result']['cycle']
      >;
      composites: {};
   };

   type CycleGetPayload<S extends boolean | null | undefined | CycleDefaultArgs> =
      $Result.GetResult<Prisma.$CyclePayload, S>;

   type CycleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
      CycleFindManyArgs,
      'select' | 'include' | 'distinct' | 'omit'
   > & {
      select?: CycleCountAggregateInputType | true;
   };

   export interface CycleDelegate<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > {
      [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Cycle']; meta: { name: 'Cycle' } };
      /**
       * Find zero or one Cycle that matches the filter.
       * @param {CycleFindUniqueArgs} args - Arguments to find a Cycle
       * @example
       * // Get one Cycle
       * const cycle = await prisma.cycle.findUnique({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUnique<T extends CycleFindUniqueArgs>(
         args: SelectSubset<T, CycleFindUniqueArgs<ExtArgs>>
      ): Prisma__CycleClient<
         $Result.GetResult<
            Prisma.$CyclePayload<ExtArgs>,
            T,
            'findUnique',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find one Cycle that matches the filter or throw an error with `error.code='P2025'`
       * if no matches were found.
       * @param {CycleFindUniqueOrThrowArgs} args - Arguments to find a Cycle
       * @example
       * // Get one Cycle
       * const cycle = await prisma.cycle.findUniqueOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUniqueOrThrow<T extends CycleFindUniqueOrThrowArgs>(
         args: SelectSubset<T, CycleFindUniqueOrThrowArgs<ExtArgs>>
      ): Prisma__CycleClient<
         $Result.GetResult<
            Prisma.$CyclePayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first Cycle that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {CycleFindFirstArgs} args - Arguments to find a Cycle
       * @example
       * // Get one Cycle
       * const cycle = await prisma.cycle.findFirst({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirst<T extends CycleFindFirstArgs>(
         args?: SelectSubset<T, CycleFindFirstArgs<ExtArgs>>
      ): Prisma__CycleClient<
         $Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first Cycle that matches the filter or
       * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {CycleFindFirstOrThrowArgs} args - Arguments to find a Cycle
       * @example
       * // Get one Cycle
       * const cycle = await prisma.cycle.findFirstOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirstOrThrow<T extends CycleFindFirstOrThrowArgs>(
         args?: SelectSubset<T, CycleFindFirstOrThrowArgs<ExtArgs>>
      ): Prisma__CycleClient<
         $Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find zero or more Cycles that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {CycleFindManyArgs} args - Arguments to filter and select certain fields only.
       * @example
       * // Get all Cycles
       * const cycles = await prisma.cycle.findMany()
       *
       * // Get first 10 Cycles
       * const cycles = await prisma.cycle.findMany({ take: 10 })
       *
       * // Only select the `id`
       * const cycleWithIdOnly = await prisma.cycle.findMany({ select: { id: true } })
       *
       */
      findMany<T extends CycleFindManyArgs>(
         args?: SelectSubset<T, CycleFindManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      >;

      /**
       * Create a Cycle.
       * @param {CycleCreateArgs} args - Arguments to create a Cycle.
       * @example
       * // Create one Cycle
       * const Cycle = await prisma.cycle.create({
       *   data: {
       *     // ... data to create a Cycle
       *   }
       * })
       *
       */
      create<T extends CycleCreateArgs>(
         args: SelectSubset<T, CycleCreateArgs<ExtArgs>>
      ): Prisma__CycleClient<
         $Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Create many Cycles.
       * @param {CycleCreateManyArgs} args - Arguments to create many Cycles.
       * @example
       * // Create many Cycles
       * const cycle = await prisma.cycle.createMany({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       */
      createMany<T extends CycleCreateManyArgs>(
         args?: SelectSubset<T, CycleCreateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Create many Cycles and returns the data saved in the database.
       * @param {CycleCreateManyAndReturnArgs} args - Arguments to create many Cycles.
       * @example
       * // Create many Cycles
       * const cycle = await prisma.cycle.createManyAndReturn({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Create many Cycles and only return the `id`
       * const cycleWithIdOnly = await prisma.cycle.createManyAndReturn({
       *   select: { id: true },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      createManyAndReturn<T extends CycleCreateManyAndReturnArgs>(
         args?: SelectSubset<T, CycleCreateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$CyclePayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Delete a Cycle.
       * @param {CycleDeleteArgs} args - Arguments to delete one Cycle.
       * @example
       * // Delete one Cycle
       * const Cycle = await prisma.cycle.delete({
       *   where: {
       *     // ... filter to delete one Cycle
       *   }
       * })
       *
       */
      delete<T extends CycleDeleteArgs>(
         args: SelectSubset<T, CycleDeleteArgs<ExtArgs>>
      ): Prisma__CycleClient<
         $Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Update one Cycle.
       * @param {CycleUpdateArgs} args - Arguments to update one Cycle.
       * @example
       * // Update one Cycle
       * const cycle = await prisma.cycle.update({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      update<T extends CycleUpdateArgs>(
         args: SelectSubset<T, CycleUpdateArgs<ExtArgs>>
      ): Prisma__CycleClient<
         $Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Delete zero or more Cycles.
       * @param {CycleDeleteManyArgs} args - Arguments to filter Cycles to delete.
       * @example
       * // Delete a few Cycles
       * const { count } = await prisma.cycle.deleteMany({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       *
       */
      deleteMany<T extends CycleDeleteManyArgs>(
         args?: SelectSubset<T, CycleDeleteManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more Cycles.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {CycleUpdateManyArgs} args - Arguments to update one or more rows.
       * @example
       * // Update many Cycles
       * const cycle = await prisma.cycle.updateMany({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      updateMany<T extends CycleUpdateManyArgs>(
         args: SelectSubset<T, CycleUpdateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more Cycles and returns the data updated in the database.
       * @param {CycleUpdateManyAndReturnArgs} args - Arguments to update many Cycles.
       * @example
       * // Update many Cycles
       * const cycle = await prisma.cycle.updateManyAndReturn({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Update zero or more Cycles and only return the `id`
       * const cycleWithIdOnly = await prisma.cycle.updateManyAndReturn({
       *   select: { id: true },
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      updateManyAndReturn<T extends CycleUpdateManyAndReturnArgs>(
         args: SelectSubset<T, CycleUpdateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$CyclePayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Create or update one Cycle.
       * @param {CycleUpsertArgs} args - Arguments to update or create a Cycle.
       * @example
       * // Update or create a Cycle
       * const cycle = await prisma.cycle.upsert({
       *   create: {
       *     // ... data to create a Cycle
       *   },
       *   update: {
       *     // ... in case it already exists, update
       *   },
       *   where: {
       *     // ... the filter for the Cycle we want to update
       *   }
       * })
       */
      upsert<T extends CycleUpsertArgs>(
         args: SelectSubset<T, CycleUpsertArgs<ExtArgs>>
      ): Prisma__CycleClient<
         $Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Count the number of Cycles.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {CycleCountArgs} args - Arguments to filter Cycles to count.
       * @example
       * // Count the number of Cycles
       * const count = await prisma.cycle.count({
       *   where: {
       *     // ... the filter for the Cycles we want to count
       *   }
       * })
       **/
      count<T extends CycleCountArgs>(
         args?: Subset<T, CycleCountArgs>
      ): Prisma.PrismaPromise<
         T extends $Utils.Record<'select', any>
            ? T['select'] extends true
               ? number
               : GetScalarType<T['select'], CycleCountAggregateOutputType>
            : number
      >;

      /**
       * Allows you to perform aggregations operations on a Cycle.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {CycleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
       * @example
       * // Ordered by age ascending
       * // Where email contains prisma.io
       * // Limited to the 10 users
       * const aggregations = await prisma.user.aggregate({
       *   _avg: {
       *     age: true,
       *   },
       *   where: {
       *     email: {
       *       contains: "prisma.io",
       *     },
       *   },
       *   orderBy: {
       *     age: "asc",
       *   },
       *   take: 10,
       * })
       **/
      aggregate<T extends CycleAggregateArgs>(
         args: Subset<T, CycleAggregateArgs>
      ): Prisma.PrismaPromise<GetCycleAggregateType<T>>;

      /**
       * Group by Cycle.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {CycleGroupByArgs} args - Group by arguments.
       * @example
       * // Group by city, order by createdAt, get count
       * const result = await prisma.user.groupBy({
       *   by: ['city', 'createdAt'],
       *   orderBy: {
       *     createdAt: true
       *   },
       *   _count: {
       *     _all: true
       *   },
       * })
       *
       **/
      groupBy<
         T extends CycleGroupByArgs,
         HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
         OrderByArg extends True extends HasSelectOrTake
            ? { orderBy: CycleGroupByArgs['orderBy'] }
            : { orderBy?: CycleGroupByArgs['orderBy'] },
         OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
         ByFields extends MaybeTupleToUnion<T['by']>,
         ByValid extends Has<ByFields, OrderFields>,
         HavingFields extends GetHavingFields<T['having']>,
         HavingValid extends Has<ByFields, HavingFields>,
         ByEmpty extends T['by'] extends never[] ? True : False,
         InputErrors extends ByEmpty extends True
            ? `Error: "by" must not be empty.`
            : HavingValid extends False
              ? {
                   [P in HavingFields]: P extends ByFields
                      ? never
                      : P extends string
                        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                        : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Keys<T>
                ? 'orderBy' extends Keys<T>
                   ? ByValid extends True
                      ? {}
                      : {
                           [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                        }[OrderFields]
                   : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Keys<T>
                  ? 'orderBy' extends Keys<T>
                     ? ByValid extends True
                        ? {}
                        : {
                             [P in OrderFields]: P extends ByFields
                                ? never
                                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                     : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends True
                    ? {}
                    : {
                         [P in OrderFields]: P extends ByFields
                            ? never
                            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
      >(
         args: SubsetIntersection<T, CycleGroupByArgs, OrderByArg> & InputErrors
      ): {} extends InputErrors ? GetCycleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
      /**
       * Fields of the Cycle model
       */
      readonly fields: CycleFieldRefs;
   }

   /**
    * The delegate class that acts as a "Promise-like" for Cycle.
    * Why is this prefixed with `Prisma__`?
    * Because we want to prevent naming conflicts as mentioned in
    * https://github.com/prisma/prisma-client-js/issues/707
    */
   export interface Prisma__CycleClient<
      T,
      Null = never,
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > extends Prisma.PrismaPromise<T> {
      readonly [Symbol.toStringTag]: 'PrismaPromise';
      team<T extends TeamDefaultArgs<ExtArgs> = {}>(
         args?: Subset<T, TeamDefaultArgs<ExtArgs>>
      ): Prisma__TeamClient<
         | $Result.GetResult<
              Prisma.$TeamPayload<ExtArgs>,
              T,
              'findUniqueOrThrow',
              GlobalOmitOptions
           >
         | Null,
         Null,
         ExtArgs,
         GlobalOmitOptions
      >;
      issues<T extends Cycle$issuesArgs<ExtArgs> = {}>(
         args?: Subset<T, Cycle$issuesArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$IssuePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
      >;
      /**
       * Attaches callbacks for the resolution and/or rejection of the Promise.
       * @param onfulfilled The callback to execute when the Promise is resolved.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of which ever callback is executed.
       */
      then<TResult1 = T, TResult2 = never>(
         onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
         onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
      ): $Utils.JsPromise<TResult1 | TResult2>;
      /**
       * Attaches a callback for only the rejection of the Promise.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of the callback.
       */
      catch<TResult = never>(
         onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
      ): $Utils.JsPromise<T | TResult>;
      /**
       * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
       * resolved value cannot be modified from the callback.
       * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
       * @returns A Promise for the completion of the callback.
       */
      finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
   }

   /**
    * Fields of the Cycle model
    */
   interface CycleFieldRefs {
      readonly id: FieldRef<'Cycle', 'String'>;
      readonly number: FieldRef<'Cycle', 'Int'>;
      readonly name: FieldRef<'Cycle', 'String'>;
      readonly teamId: FieldRef<'Cycle', 'String'>;
      readonly startDate: FieldRef<'Cycle', 'DateTime'>;
      readonly endDate: FieldRef<'Cycle', 'DateTime'>;
      readonly progress: FieldRef<'Cycle', 'Int'>;
      readonly createdAt: FieldRef<'Cycle', 'DateTime'>;
      readonly updatedAt: FieldRef<'Cycle', 'DateTime'>;
   }

   // Custom InputTypes
   /**
    * Cycle findUnique
    */
   export type CycleFindUniqueArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Cycle
       */
      select?: CycleSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Cycle
       */
      omit?: CycleOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: CycleInclude<ExtArgs> | null;
      /**
       * Filter, which Cycle to fetch.
       */
      where: CycleWhereUniqueInput;
   };

   /**
    * Cycle findUniqueOrThrow
    */
   export type CycleFindUniqueOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Cycle
       */
      select?: CycleSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Cycle
       */
      omit?: CycleOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: CycleInclude<ExtArgs> | null;
      /**
       * Filter, which Cycle to fetch.
       */
      where: CycleWhereUniqueInput;
   };

   /**
    * Cycle findFirst
    */
   export type CycleFindFirstArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Cycle
       */
      select?: CycleSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Cycle
       */
      omit?: CycleOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: CycleInclude<ExtArgs> | null;
      /**
       * Filter, which Cycle to fetch.
       */
      where?: CycleWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Cycles to fetch.
       */
      orderBy?: CycleOrderByWithRelationInput | CycleOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for Cycles.
       */
      cursor?: CycleWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Cycles from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Cycles.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of Cycles.
       */
      distinct?: CycleScalarFieldEnum | CycleScalarFieldEnum[];
   };

   /**
    * Cycle findFirstOrThrow
    */
   export type CycleFindFirstOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Cycle
       */
      select?: CycleSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Cycle
       */
      omit?: CycleOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: CycleInclude<ExtArgs> | null;
      /**
       * Filter, which Cycle to fetch.
       */
      where?: CycleWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Cycles to fetch.
       */
      orderBy?: CycleOrderByWithRelationInput | CycleOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for Cycles.
       */
      cursor?: CycleWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Cycles from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Cycles.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of Cycles.
       */
      distinct?: CycleScalarFieldEnum | CycleScalarFieldEnum[];
   };

   /**
    * Cycle findMany
    */
   export type CycleFindManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Cycle
       */
      select?: CycleSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Cycle
       */
      omit?: CycleOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: CycleInclude<ExtArgs> | null;
      /**
       * Filter, which Cycles to fetch.
       */
      where?: CycleWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Cycles to fetch.
       */
      orderBy?: CycleOrderByWithRelationInput | CycleOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Cycles.
       */
      cursor?: CycleWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Cycles from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Cycles.
       */
      skip?: number;
      distinct?: CycleScalarFieldEnum | CycleScalarFieldEnum[];
   };

   /**
    * Cycle create
    */
   export type CycleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Cycle
          */
         select?: CycleSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Cycle
          */
         omit?: CycleOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: CycleInclude<ExtArgs> | null;
         /**
          * The data needed to create a Cycle.
          */
         data: XOR<CycleCreateInput, CycleUncheckedCreateInput>;
      };

   /**
    * Cycle createMany
    */
   export type CycleCreateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to create many Cycles.
       */
      data: CycleCreateManyInput | CycleCreateManyInput[];
   };

   /**
    * Cycle createManyAndReturn
    */
   export type CycleCreateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Cycle
       */
      select?: CycleSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the Cycle
       */
      omit?: CycleOmit<ExtArgs> | null;
      /**
       * The data used to create many Cycles.
       */
      data: CycleCreateManyInput | CycleCreateManyInput[];
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: CycleIncludeCreateManyAndReturn<ExtArgs> | null;
   };

   /**
    * Cycle update
    */
   export type CycleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Cycle
          */
         select?: CycleSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Cycle
          */
         omit?: CycleOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: CycleInclude<ExtArgs> | null;
         /**
          * The data needed to update a Cycle.
          */
         data: XOR<CycleUpdateInput, CycleUncheckedUpdateInput>;
         /**
          * Choose, which Cycle to update.
          */
         where: CycleWhereUniqueInput;
      };

   /**
    * Cycle updateMany
    */
   export type CycleUpdateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to update Cycles.
       */
      data: XOR<CycleUpdateManyMutationInput, CycleUncheckedUpdateManyInput>;
      /**
       * Filter which Cycles to update
       */
      where?: CycleWhereInput;
      /**
       * Limit how many Cycles to update.
       */
      limit?: number;
   };

   /**
    * Cycle updateManyAndReturn
    */
   export type CycleUpdateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Cycle
       */
      select?: CycleSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the Cycle
       */
      omit?: CycleOmit<ExtArgs> | null;
      /**
       * The data used to update Cycles.
       */
      data: XOR<CycleUpdateManyMutationInput, CycleUncheckedUpdateManyInput>;
      /**
       * Filter which Cycles to update
       */
      where?: CycleWhereInput;
      /**
       * Limit how many Cycles to update.
       */
      limit?: number;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: CycleIncludeUpdateManyAndReturn<ExtArgs> | null;
   };

   /**
    * Cycle upsert
    */
   export type CycleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Cycle
          */
         select?: CycleSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Cycle
          */
         omit?: CycleOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: CycleInclude<ExtArgs> | null;
         /**
          * The filter to search for the Cycle to update in case it exists.
          */
         where: CycleWhereUniqueInput;
         /**
          * In case the Cycle found by the `where` argument doesn't exist, create a new Cycle with this data.
          */
         create: XOR<CycleCreateInput, CycleUncheckedCreateInput>;
         /**
          * In case the Cycle was found with the provided `where` argument, update it with this data.
          */
         update: XOR<CycleUpdateInput, CycleUncheckedUpdateInput>;
      };

   /**
    * Cycle delete
    */
   export type CycleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Cycle
          */
         select?: CycleSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Cycle
          */
         omit?: CycleOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: CycleInclude<ExtArgs> | null;
         /**
          * Filter which Cycle to delete.
          */
         where: CycleWhereUniqueInput;
      };

   /**
    * Cycle deleteMany
    */
   export type CycleDeleteManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which Cycles to delete
       */
      where?: CycleWhereInput;
      /**
       * Limit how many Cycles to delete.
       */
      limit?: number;
   };

   /**
    * Cycle.issues
    */
   export type Cycle$issuesArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Issue
       */
      select?: IssueSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Issue
       */
      omit?: IssueOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: IssueInclude<ExtArgs> | null;
      where?: IssueWhereInput;
      orderBy?: IssueOrderByWithRelationInput | IssueOrderByWithRelationInput[];
      cursor?: IssueWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: IssueScalarFieldEnum | IssueScalarFieldEnum[];
   };

   /**
    * Cycle without action
    */
   export type CycleDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Cycle
       */
      select?: CycleSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Cycle
       */
      omit?: CycleOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: CycleInclude<ExtArgs> | null;
   };

   /**
    * Model Team
    */

   export type AggregateTeam = {
      _count: TeamCountAggregateOutputType | null;
      _min: TeamMinAggregateOutputType | null;
      _max: TeamMaxAggregateOutputType | null;
   };

   export type TeamMinAggregateOutputType = {
      id: string | null;
      name: string | null;
      icon: string | null;
      joined: boolean | null;
      color: string | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type TeamMaxAggregateOutputType = {
      id: string | null;
      name: string | null;
      icon: string | null;
      joined: boolean | null;
      color: string | null;
      createdAt: Date | null;
      updatedAt: Date | null;
   };

   export type TeamCountAggregateOutputType = {
      id: number;
      name: number;
      icon: number;
      joined: number;
      color: number;
      createdAt: number;
      updatedAt: number;
      _all: number;
   };

   export type TeamMinAggregateInputType = {
      id?: true;
      name?: true;
      icon?: true;
      joined?: true;
      color?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type TeamMaxAggregateInputType = {
      id?: true;
      name?: true;
      icon?: true;
      joined?: true;
      color?: true;
      createdAt?: true;
      updatedAt?: true;
   };

   export type TeamCountAggregateInputType = {
      id?: true;
      name?: true;
      icon?: true;
      joined?: true;
      color?: true;
      createdAt?: true;
      updatedAt?: true;
      _all?: true;
   };

   export type TeamAggregateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which Team to aggregate.
       */
      where?: TeamWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Teams to fetch.
       */
      orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: TeamWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Teams from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Teams.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned Teams
       **/
      _count?: true | TeamCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: TeamMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: TeamMaxAggregateInputType;
   };

   export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
      [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
         ? T[P] extends true
            ? number
            : GetScalarType<T[P], AggregateTeam[P]>
         : GetScalarType<T[P], AggregateTeam[P]>;
   };

   export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         where?: TeamWhereInput;
         orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[];
         by: TeamScalarFieldEnum[] | TeamScalarFieldEnum;
         having?: TeamScalarWhereWithAggregatesInput;
         take?: number;
         skip?: number;
         _count?: TeamCountAggregateInputType | true;
         _min?: TeamMinAggregateInputType;
         _max?: TeamMaxAggregateInputType;
      };

   export type TeamGroupByOutputType = {
      id: string;
      name: string;
      icon: string;
      joined: boolean;
      color: string;
      createdAt: Date;
      updatedAt: Date;
      _count: TeamCountAggregateOutputType | null;
      _min: TeamMinAggregateOutputType | null;
      _max: TeamMaxAggregateOutputType | null;
   };

   type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
      Array<
         PickEnumerable<TeamGroupByOutputType, T['by']> & {
            [P in keyof T & keyof TeamGroupByOutputType]: P extends '_count'
               ? T[P] extends boolean
                  ? number
                  : GetScalarType<T[P], TeamGroupByOutputType[P]>
               : GetScalarType<T[P], TeamGroupByOutputType[P]>;
         }
      >
   >;

   export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetSelect<
         {
            id?: boolean;
            name?: boolean;
            icon?: boolean;
            joined?: boolean;
            color?: boolean;
            createdAt?: boolean;
            updatedAt?: boolean;
            members?: boolean | Team$membersArgs<ExtArgs>;
            projects?: boolean | Team$projectsArgs<ExtArgs>;
            cycles?: boolean | Team$cyclesArgs<ExtArgs>;
            _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>;
         },
         ExtArgs['result']['team']
      >;

   export type TeamSelectCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         name?: boolean;
         icon?: boolean;
         joined?: boolean;
         color?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
      },
      ExtArgs['result']['team']
   >;

   export type TeamSelectUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         name?: boolean;
         icon?: boolean;
         joined?: boolean;
         color?: boolean;
         createdAt?: boolean;
         updatedAt?: boolean;
      },
      ExtArgs['result']['team']
   >;

   export type TeamSelectScalar = {
      id?: boolean;
      name?: boolean;
      icon?: boolean;
      joined?: boolean;
      color?: boolean;
      createdAt?: boolean;
      updatedAt?: boolean;
   };

   export type TeamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetOmit<
         'id' | 'name' | 'icon' | 'joined' | 'color' | 'createdAt' | 'updatedAt',
         ExtArgs['result']['team']
      >;
   export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
      members?: boolean | Team$membersArgs<ExtArgs>;
      projects?: boolean | Team$projectsArgs<ExtArgs>;
      cycles?: boolean | Team$cyclesArgs<ExtArgs>;
      _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>;
   };
   export type TeamIncludeCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {};
   export type TeamIncludeUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {};

   export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
      name: 'Team';
      objects: {
         members: Prisma.$TeamMemberPayload<ExtArgs>[];
         projects: Prisma.$TeamProjectPayload<ExtArgs>[];
         cycles: Prisma.$CyclePayload<ExtArgs>[];
      };
      scalars: $Extensions.GetPayloadResult<
         {
            id: string;
            name: string;
            icon: string;
            joined: boolean;
            color: string;
            createdAt: Date;
            updatedAt: Date;
         },
         ExtArgs['result']['team']
      >;
      composites: {};
   };

   type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<
      Prisma.$TeamPayload,
      S
   >;

   type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = Omit<
      TeamFindManyArgs,
      'select' | 'include' | 'distinct' | 'omit'
   > & {
      select?: TeamCountAggregateInputType | true;
   };

   export interface TeamDelegate<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > {
      [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team']; meta: { name: 'Team' } };
      /**
       * Find zero or one Team that matches the filter.
       * @param {TeamFindUniqueArgs} args - Arguments to find a Team
       * @example
       * // Get one Team
       * const team = await prisma.team.findUnique({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUnique<T extends TeamFindUniqueArgs>(
         args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>
      ): Prisma__TeamClient<
         $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'findUnique', GlobalOmitOptions> | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find one Team that matches the filter or throw an error with `error.code='P2025'`
       * if no matches were found.
       * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
       * @example
       * // Get one Team
       * const team = await prisma.team.findUniqueOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(
         args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>
      ): Prisma__TeamClient<
         $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'findUniqueOrThrow', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first Team that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamFindFirstArgs} args - Arguments to find a Team
       * @example
       * // Get one Team
       * const team = await prisma.team.findFirst({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirst<T extends TeamFindFirstArgs>(
         args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>
      ): Prisma__TeamClient<
         $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'findFirst', GlobalOmitOptions> | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first Team that matches the filter or
       * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
       * @example
       * // Get one Team
       * const team = await prisma.team.findFirstOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(
         args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>
      ): Prisma__TeamClient<
         $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'findFirstOrThrow', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find zero or more Teams that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
       * @example
       * // Get all Teams
       * const teams = await prisma.team.findMany()
       *
       * // Get first 10 Teams
       * const teams = await prisma.team.findMany({ take: 10 })
       *
       * // Only select the `id`
       * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
       *
       */
      findMany<T extends TeamFindManyArgs>(
         args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      >;

      /**
       * Create a Team.
       * @param {TeamCreateArgs} args - Arguments to create a Team.
       * @example
       * // Create one Team
       * const Team = await prisma.team.create({
       *   data: {
       *     // ... data to create a Team
       *   }
       * })
       *
       */
      create<T extends TeamCreateArgs>(
         args: SelectSubset<T, TeamCreateArgs<ExtArgs>>
      ): Prisma__TeamClient<
         $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Create many Teams.
       * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
       * @example
       * // Create many Teams
       * const team = await prisma.team.createMany({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       */
      createMany<T extends TeamCreateManyArgs>(
         args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Create many Teams and returns the data saved in the database.
       * @param {TeamCreateManyAndReturnArgs} args - Arguments to create many Teams.
       * @example
       * // Create many Teams
       * const team = await prisma.team.createManyAndReturn({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Create many Teams and only return the `id`
       * const teamWithIdOnly = await prisma.team.createManyAndReturn({
       *   select: { id: true },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      createManyAndReturn<T extends TeamCreateManyAndReturnArgs>(
         args?: SelectSubset<T, TeamCreateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$TeamPayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Delete a Team.
       * @param {TeamDeleteArgs} args - Arguments to delete one Team.
       * @example
       * // Delete one Team
       * const Team = await prisma.team.delete({
       *   where: {
       *     // ... filter to delete one Team
       *   }
       * })
       *
       */
      delete<T extends TeamDeleteArgs>(
         args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>
      ): Prisma__TeamClient<
         $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Update one Team.
       * @param {TeamUpdateArgs} args - Arguments to update one Team.
       * @example
       * // Update one Team
       * const team = await prisma.team.update({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      update<T extends TeamUpdateArgs>(
         args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>
      ): Prisma__TeamClient<
         $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Delete zero or more Teams.
       * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
       * @example
       * // Delete a few Teams
       * const { count } = await prisma.team.deleteMany({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       *
       */
      deleteMany<T extends TeamDeleteManyArgs>(
         args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more Teams.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
       * @example
       * // Update many Teams
       * const team = await prisma.team.updateMany({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      updateMany<T extends TeamUpdateManyArgs>(
         args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more Teams and returns the data updated in the database.
       * @param {TeamUpdateManyAndReturnArgs} args - Arguments to update many Teams.
       * @example
       * // Update many Teams
       * const team = await prisma.team.updateManyAndReturn({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Update zero or more Teams and only return the `id`
       * const teamWithIdOnly = await prisma.team.updateManyAndReturn({
       *   select: { id: true },
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      updateManyAndReturn<T extends TeamUpdateManyAndReturnArgs>(
         args: SelectSubset<T, TeamUpdateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$TeamPayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Create or update one Team.
       * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
       * @example
       * // Update or create a Team
       * const team = await prisma.team.upsert({
       *   create: {
       *     // ... data to create a Team
       *   },
       *   update: {
       *     // ... in case it already exists, update
       *   },
       *   where: {
       *     // ... the filter for the Team we want to update
       *   }
       * })
       */
      upsert<T extends TeamUpsertArgs>(
         args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>
      ): Prisma__TeamClient<
         $Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Count the number of Teams.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamCountArgs} args - Arguments to filter Teams to count.
       * @example
       * // Count the number of Teams
       * const count = await prisma.team.count({
       *   where: {
       *     // ... the filter for the Teams we want to count
       *   }
       * })
       **/
      count<T extends TeamCountArgs>(
         args?: Subset<T, TeamCountArgs>
      ): Prisma.PrismaPromise<
         T extends $Utils.Record<'select', any>
            ? T['select'] extends true
               ? number
               : GetScalarType<T['select'], TeamCountAggregateOutputType>
            : number
      >;

      /**
       * Allows you to perform aggregations operations on a Team.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
       * @example
       * // Ordered by age ascending
       * // Where email contains prisma.io
       * // Limited to the 10 users
       * const aggregations = await prisma.user.aggregate({
       *   _avg: {
       *     age: true,
       *   },
       *   where: {
       *     email: {
       *       contains: "prisma.io",
       *     },
       *   },
       *   orderBy: {
       *     age: "asc",
       *   },
       *   take: 10,
       * })
       **/
      aggregate<T extends TeamAggregateArgs>(
         args: Subset<T, TeamAggregateArgs>
      ): Prisma.PrismaPromise<GetTeamAggregateType<T>>;

      /**
       * Group by Team.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamGroupByArgs} args - Group by arguments.
       * @example
       * // Group by city, order by createdAt, get count
       * const result = await prisma.user.groupBy({
       *   by: ['city', 'createdAt'],
       *   orderBy: {
       *     createdAt: true
       *   },
       *   _count: {
       *     _all: true
       *   },
       * })
       *
       **/
      groupBy<
         T extends TeamGroupByArgs,
         HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
         OrderByArg extends True extends HasSelectOrTake
            ? { orderBy: TeamGroupByArgs['orderBy'] }
            : { orderBy?: TeamGroupByArgs['orderBy'] },
         OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
         ByFields extends MaybeTupleToUnion<T['by']>,
         ByValid extends Has<ByFields, OrderFields>,
         HavingFields extends GetHavingFields<T['having']>,
         HavingValid extends Has<ByFields, HavingFields>,
         ByEmpty extends T['by'] extends never[] ? True : False,
         InputErrors extends ByEmpty extends True
            ? `Error: "by" must not be empty.`
            : HavingValid extends False
              ? {
                   [P in HavingFields]: P extends ByFields
                      ? never
                      : P extends string
                        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                        : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Keys<T>
                ? 'orderBy' extends Keys<T>
                   ? ByValid extends True
                      ? {}
                      : {
                           [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                        }[OrderFields]
                   : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Keys<T>
                  ? 'orderBy' extends Keys<T>
                     ? ByValid extends True
                        ? {}
                        : {
                             [P in OrderFields]: P extends ByFields
                                ? never
                                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                     : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends True
                    ? {}
                    : {
                         [P in OrderFields]: P extends ByFields
                            ? never
                            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
      >(
         args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors
      ): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>;
      /**
       * Fields of the Team model
       */
      readonly fields: TeamFieldRefs;
   }

   /**
    * The delegate class that acts as a "Promise-like" for Team.
    * Why is this prefixed with `Prisma__`?
    * Because we want to prevent naming conflicts as mentioned in
    * https://github.com/prisma/prisma-client-js/issues/707
    */
   export interface Prisma__TeamClient<
      T,
      Null = never,
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > extends Prisma.PrismaPromise<T> {
      readonly [Symbol.toStringTag]: 'PrismaPromise';
      members<T extends Team$membersArgs<ExtArgs> = {}>(
         args?: Subset<T, Team$membersArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         | $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
         | Null
      >;
      projects<T extends Team$projectsArgs<ExtArgs> = {}>(
         args?: Subset<T, Team$projectsArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         | $Result.GetResult<Prisma.$TeamProjectPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
         | Null
      >;
      cycles<T extends Team$cyclesArgs<ExtArgs> = {}>(
         args?: Subset<T, Team$cyclesArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$CyclePayload<ExtArgs>, T, 'findMany', GlobalOmitOptions> | Null
      >;
      /**
       * Attaches callbacks for the resolution and/or rejection of the Promise.
       * @param onfulfilled The callback to execute when the Promise is resolved.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of which ever callback is executed.
       */
      then<TResult1 = T, TResult2 = never>(
         onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
         onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
      ): $Utils.JsPromise<TResult1 | TResult2>;
      /**
       * Attaches a callback for only the rejection of the Promise.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of the callback.
       */
      catch<TResult = never>(
         onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
      ): $Utils.JsPromise<T | TResult>;
      /**
       * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
       * resolved value cannot be modified from the callback.
       * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
       * @returns A Promise for the completion of the callback.
       */
      finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
   }

   /**
    * Fields of the Team model
    */
   interface TeamFieldRefs {
      readonly id: FieldRef<'Team', 'String'>;
      readonly name: FieldRef<'Team', 'String'>;
      readonly icon: FieldRef<'Team', 'String'>;
      readonly joined: FieldRef<'Team', 'Boolean'>;
      readonly color: FieldRef<'Team', 'String'>;
      readonly createdAt: FieldRef<'Team', 'DateTime'>;
      readonly updatedAt: FieldRef<'Team', 'DateTime'>;
   }

   // Custom InputTypes
   /**
    * Team findUnique
    */
   export type TeamFindUniqueArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Team
       */
      select?: TeamSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Team
       */
      omit?: TeamOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamInclude<ExtArgs> | null;
      /**
       * Filter, which Team to fetch.
       */
      where: TeamWhereUniqueInput;
   };

   /**
    * Team findUniqueOrThrow
    */
   export type TeamFindUniqueOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Team
       */
      select?: TeamSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Team
       */
      omit?: TeamOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamInclude<ExtArgs> | null;
      /**
       * Filter, which Team to fetch.
       */
      where: TeamWhereUniqueInput;
   };

   /**
    * Team findFirst
    */
   export type TeamFindFirstArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Team
       */
      select?: TeamSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Team
       */
      omit?: TeamOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamInclude<ExtArgs> | null;
      /**
       * Filter, which Team to fetch.
       */
      where?: TeamWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Teams to fetch.
       */
      orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for Teams.
       */
      cursor?: TeamWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Teams from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Teams.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of Teams.
       */
      distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[];
   };

   /**
    * Team findFirstOrThrow
    */
   export type TeamFindFirstOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Team
       */
      select?: TeamSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Team
       */
      omit?: TeamOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamInclude<ExtArgs> | null;
      /**
       * Filter, which Team to fetch.
       */
      where?: TeamWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Teams to fetch.
       */
      orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for Teams.
       */
      cursor?: TeamWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Teams from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Teams.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of Teams.
       */
      distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[];
   };

   /**
    * Team findMany
    */
   export type TeamFindManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Team
       */
      select?: TeamSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the Team
       */
      omit?: TeamOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamInclude<ExtArgs> | null;
      /**
       * Filter, which Teams to fetch.
       */
      where?: TeamWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of Teams to fetch.
       */
      orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing Teams.
       */
      cursor?: TeamWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` Teams from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` Teams.
       */
      skip?: number;
      distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[];
   };

   /**
    * Team create
    */
   export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Team
          */
         select?: TeamSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Team
          */
         omit?: TeamOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: TeamInclude<ExtArgs> | null;
         /**
          * The data needed to create a Team.
          */
         data: XOR<TeamCreateInput, TeamUncheckedCreateInput>;
      };

   /**
    * Team createMany
    */
   export type TeamCreateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to create many Teams.
       */
      data: TeamCreateManyInput | TeamCreateManyInput[];
   };

   /**
    * Team createManyAndReturn
    */
   export type TeamCreateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Team
       */
      select?: TeamSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the Team
       */
      omit?: TeamOmit<ExtArgs> | null;
      /**
       * The data used to create many Teams.
       */
      data: TeamCreateManyInput | TeamCreateManyInput[];
   };

   /**
    * Team update
    */
   export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Team
          */
         select?: TeamSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Team
          */
         omit?: TeamOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: TeamInclude<ExtArgs> | null;
         /**
          * The data needed to update a Team.
          */
         data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>;
         /**
          * Choose, which Team to update.
          */
         where: TeamWhereUniqueInput;
      };

   /**
    * Team updateMany
    */
   export type TeamUpdateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to update Teams.
       */
      data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>;
      /**
       * Filter which Teams to update
       */
      where?: TeamWhereInput;
      /**
       * Limit how many Teams to update.
       */
      limit?: number;
   };

   /**
    * Team updateManyAndReturn
    */
   export type TeamUpdateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the Team
       */
      select?: TeamSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the Team
       */
      omit?: TeamOmit<ExtArgs> | null;
      /**
       * The data used to update Teams.
       */
      data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>;
      /**
       * Filter which Teams to update
       */
      where?: TeamWhereInput;
      /**
       * Limit how many Teams to update.
       */
      limit?: number;
   };

   /**
    * Team upsert
    */
   export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Team
          */
         select?: TeamSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Team
          */
         omit?: TeamOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: TeamInclude<ExtArgs> | null;
         /**
          * The filter to search for the Team to update in case it exists.
          */
         where: TeamWhereUniqueInput;
         /**
          * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
          */
         create: XOR<TeamCreateInput, TeamUncheckedCreateInput>;
         /**
          * In case the Team was found with the provided `where` argument, update it with this data.
          */
         update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>;
      };

   /**
    * Team delete
    */
   export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Team
          */
         select?: TeamSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Team
          */
         omit?: TeamOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: TeamInclude<ExtArgs> | null;
         /**
          * Filter which Team to delete.
          */
         where: TeamWhereUniqueInput;
      };

   /**
    * Team deleteMany
    */
   export type TeamDeleteManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which Teams to delete
       */
      where?: TeamWhereInput;
      /**
       * Limit how many Teams to delete.
       */
      limit?: number;
   };

   /**
    * Team.members
    */
   export type Team$membersArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamMember
       */
      select?: TeamMemberSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamMember
       */
      omit?: TeamMemberOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamMemberInclude<ExtArgs> | null;
      where?: TeamMemberWhereInput;
      orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[];
      cursor?: TeamMemberWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
   };

   /**
    * Team.projects
    */
   export type Team$projectsArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamProject
       */
      select?: TeamProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamProject
       */
      omit?: TeamProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamProjectInclude<ExtArgs> | null;
      where?: TeamProjectWhereInput;
      orderBy?: TeamProjectOrderByWithRelationInput | TeamProjectOrderByWithRelationInput[];
      cursor?: TeamProjectWhereUniqueInput;
      take?: number;
      skip?: number;
      distinct?: TeamProjectScalarFieldEnum | TeamProjectScalarFieldEnum[];
   };

   /**
    * Team.cycles
    */
   export type Team$cyclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Cycle
          */
         select?: CycleSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Cycle
          */
         omit?: CycleOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: CycleInclude<ExtArgs> | null;
         where?: CycleWhereInput;
         orderBy?: CycleOrderByWithRelationInput | CycleOrderByWithRelationInput[];
         cursor?: CycleWhereUniqueInput;
         take?: number;
         skip?: number;
         distinct?: CycleScalarFieldEnum | CycleScalarFieldEnum[];
      };

   /**
    * Team without action
    */
   export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      {
         /**
          * Select specific fields to fetch from the Team
          */
         select?: TeamSelect<ExtArgs> | null;
         /**
          * Omit specific fields from the Team
          */
         omit?: TeamOmit<ExtArgs> | null;
         /**
          * Choose, which related nodes to fetch as well
          */
         include?: TeamInclude<ExtArgs> | null;
      };

   /**
    * Model TeamMember
    */

   export type AggregateTeamMember = {
      _count: TeamMemberCountAggregateOutputType | null;
      _min: TeamMemberMinAggregateOutputType | null;
      _max: TeamMemberMaxAggregateOutputType | null;
   };

   export type TeamMemberMinAggregateOutputType = {
      id: string | null;
      teamId: string | null;
      userId: string | null;
   };

   export type TeamMemberMaxAggregateOutputType = {
      id: string | null;
      teamId: string | null;
      userId: string | null;
   };

   export type TeamMemberCountAggregateOutputType = {
      id: number;
      teamId: number;
      userId: number;
      _all: number;
   };

   export type TeamMemberMinAggregateInputType = {
      id?: true;
      teamId?: true;
      userId?: true;
   };

   export type TeamMemberMaxAggregateInputType = {
      id?: true;
      teamId?: true;
      userId?: true;
   };

   export type TeamMemberCountAggregateInputType = {
      id?: true;
      teamId?: true;
      userId?: true;
      _all?: true;
   };

   export type TeamMemberAggregateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which TeamMember to aggregate.
       */
      where?: TeamMemberWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of TeamMembers to fetch.
       */
      orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: TeamMemberWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` TeamMembers from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` TeamMembers.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned TeamMembers
       **/
      _count?: true | TeamMemberCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: TeamMemberMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: TeamMemberMaxAggregateInputType;
   };

   export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
      [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
         ? T[P] extends true
            ? number
            : GetScalarType<T[P], AggregateTeamMember[P]>
         : GetScalarType<T[P], AggregateTeamMember[P]>;
   };

   export type TeamMemberGroupByArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: TeamMemberWhereInput;
      orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[];
      by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum;
      having?: TeamMemberScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: TeamMemberCountAggregateInputType | true;
      _min?: TeamMemberMinAggregateInputType;
      _max?: TeamMemberMaxAggregateInputType;
   };

   export type TeamMemberGroupByOutputType = {
      id: string;
      teamId: string;
      userId: string;
      _count: TeamMemberCountAggregateOutputType | null;
      _min: TeamMemberMinAggregateOutputType | null;
      _max: TeamMemberMaxAggregateOutputType | null;
   };

   type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
      Array<
         PickEnumerable<TeamMemberGroupByOutputType, T['by']> & {
            [P in keyof T & keyof TeamMemberGroupByOutputType]: P extends '_count'
               ? T[P] extends boolean
                  ? number
                  : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
               : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>;
         }
      >
   >;

   export type TeamMemberSelect<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         teamId?: boolean;
         userId?: boolean;
         team?: boolean | TeamDefaultArgs<ExtArgs>;
         user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['teamMember']
   >;

   export type TeamMemberSelectCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         teamId?: boolean;
         userId?: boolean;
         team?: boolean | TeamDefaultArgs<ExtArgs>;
         user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['teamMember']
   >;

   export type TeamMemberSelectUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         teamId?: boolean;
         userId?: boolean;
         team?: boolean | TeamDefaultArgs<ExtArgs>;
         user?: boolean | UserDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['teamMember']
   >;

   export type TeamMemberSelectScalar = {
      id?: boolean;
      teamId?: boolean;
      userId?: boolean;
   };

   export type TeamMemberOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetOmit<'id' | 'teamId' | 'userId', ExtArgs['result']['teamMember']>;
   export type TeamMemberInclude<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      team?: boolean | TeamDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
   };
   export type TeamMemberIncludeCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      team?: boolean | TeamDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
   };
   export type TeamMemberIncludeUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      team?: boolean | TeamDefaultArgs<ExtArgs>;
      user?: boolean | UserDefaultArgs<ExtArgs>;
   };

   export type $TeamMemberPayload<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      name: 'TeamMember';
      objects: {
         team: Prisma.$TeamPayload<ExtArgs>;
         user: Prisma.$UserPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
         {
            id: string;
            teamId: string;
            userId: string;
         },
         ExtArgs['result']['teamMember']
      >;
      composites: {};
   };

   type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> =
      $Result.GetResult<Prisma.$TeamMemberPayload, S>;

   type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
         select?: TeamMemberCountAggregateInputType | true;
      };

   export interface TeamMemberDelegate<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > {
      [K: symbol]: {
         types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'];
         meta: { name: 'TeamMember' };
      };
      /**
       * Find zero or one TeamMember that matches the filter.
       * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
       * @example
       * // Get one TeamMember
       * const teamMember = await prisma.teamMember.findUnique({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUnique<T extends TeamMemberFindUniqueArgs>(
         args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>
      ): Prisma__TeamMemberClient<
         $Result.GetResult<
            Prisma.$TeamMemberPayload<ExtArgs>,
            T,
            'findUnique',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'`
       * if no matches were found.
       * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
       * @example
       * // Get one TeamMember
       * const teamMember = await prisma.teamMember.findUniqueOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(
         args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>
      ): Prisma__TeamMemberClient<
         $Result.GetResult<
            Prisma.$TeamMemberPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first TeamMember that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
       * @example
       * // Get one TeamMember
       * const teamMember = await prisma.teamMember.findFirst({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirst<T extends TeamMemberFindFirstArgs>(
         args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>
      ): Prisma__TeamMemberClient<
         $Result.GetResult<
            Prisma.$TeamMemberPayload<ExtArgs>,
            T,
            'findFirst',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first TeamMember that matches the filter or
       * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
       * @example
       * // Get one TeamMember
       * const teamMember = await prisma.teamMember.findFirstOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(
         args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>
      ): Prisma__TeamMemberClient<
         $Result.GetResult<
            Prisma.$TeamMemberPayload<ExtArgs>,
            T,
            'findFirstOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find zero or more TeamMembers that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
       * @example
       * // Get all TeamMembers
       * const teamMembers = await prisma.teamMember.findMany()
       *
       * // Get first 10 TeamMembers
       * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
       *
       * // Only select the `id`
       * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
       *
       */
      findMany<T extends TeamMemberFindManyArgs>(
         args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      >;

      /**
       * Create a TeamMember.
       * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
       * @example
       * // Create one TeamMember
       * const TeamMember = await prisma.teamMember.create({
       *   data: {
       *     // ... data to create a TeamMember
       *   }
       * })
       *
       */
      create<T extends TeamMemberCreateArgs>(
         args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>
      ): Prisma__TeamMemberClient<
         $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Create many TeamMembers.
       * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
       * @example
       * // Create many TeamMembers
       * const teamMember = await prisma.teamMember.createMany({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       */
      createMany<T extends TeamMemberCreateManyArgs>(
         args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Create many TeamMembers and returns the data saved in the database.
       * @param {TeamMemberCreateManyAndReturnArgs} args - Arguments to create many TeamMembers.
       * @example
       * // Create many TeamMembers
       * const teamMember = await prisma.teamMember.createManyAndReturn({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Create many TeamMembers and only return the `id`
       * const teamMemberWithIdOnly = await prisma.teamMember.createManyAndReturn({
       *   select: { id: true },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      createManyAndReturn<T extends TeamMemberCreateManyAndReturnArgs>(
         args?: SelectSubset<T, TeamMemberCreateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$TeamMemberPayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Delete a TeamMember.
       * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
       * @example
       * // Delete one TeamMember
       * const TeamMember = await prisma.teamMember.delete({
       *   where: {
       *     // ... filter to delete one TeamMember
       *   }
       * })
       *
       */
      delete<T extends TeamMemberDeleteArgs>(
         args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>
      ): Prisma__TeamMemberClient<
         $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Update one TeamMember.
       * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
       * @example
       * // Update one TeamMember
       * const teamMember = await prisma.teamMember.update({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      update<T extends TeamMemberUpdateArgs>(
         args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>
      ): Prisma__TeamMemberClient<
         $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Delete zero or more TeamMembers.
       * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
       * @example
       * // Delete a few TeamMembers
       * const { count } = await prisma.teamMember.deleteMany({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       *
       */
      deleteMany<T extends TeamMemberDeleteManyArgs>(
         args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more TeamMembers.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
       * @example
       * // Update many TeamMembers
       * const teamMember = await prisma.teamMember.updateMany({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      updateMany<T extends TeamMemberUpdateManyArgs>(
         args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more TeamMembers and returns the data updated in the database.
       * @param {TeamMemberUpdateManyAndReturnArgs} args - Arguments to update many TeamMembers.
       * @example
       * // Update many TeamMembers
       * const teamMember = await prisma.teamMember.updateManyAndReturn({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Update zero or more TeamMembers and only return the `id`
       * const teamMemberWithIdOnly = await prisma.teamMember.updateManyAndReturn({
       *   select: { id: true },
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      updateManyAndReturn<T extends TeamMemberUpdateManyAndReturnArgs>(
         args: SelectSubset<T, TeamMemberUpdateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$TeamMemberPayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Create or update one TeamMember.
       * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
       * @example
       * // Update or create a TeamMember
       * const teamMember = await prisma.teamMember.upsert({
       *   create: {
       *     // ... data to create a TeamMember
       *   },
       *   update: {
       *     // ... in case it already exists, update
       *   },
       *   where: {
       *     // ... the filter for the TeamMember we want to update
       *   }
       * })
       */
      upsert<T extends TeamMemberUpsertArgs>(
         args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>
      ): Prisma__TeamMemberClient<
         $Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Count the number of TeamMembers.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
       * @example
       * // Count the number of TeamMembers
       * const count = await prisma.teamMember.count({
       *   where: {
       *     // ... the filter for the TeamMembers we want to count
       *   }
       * })
       **/
      count<T extends TeamMemberCountArgs>(
         args?: Subset<T, TeamMemberCountArgs>
      ): Prisma.PrismaPromise<
         T extends $Utils.Record<'select', any>
            ? T['select'] extends true
               ? number
               : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
            : number
      >;

      /**
       * Allows you to perform aggregations operations on a TeamMember.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
       * @example
       * // Ordered by age ascending
       * // Where email contains prisma.io
       * // Limited to the 10 users
       * const aggregations = await prisma.user.aggregate({
       *   _avg: {
       *     age: true,
       *   },
       *   where: {
       *     email: {
       *       contains: "prisma.io",
       *     },
       *   },
       *   orderBy: {
       *     age: "asc",
       *   },
       *   take: 10,
       * })
       **/
      aggregate<T extends TeamMemberAggregateArgs>(
         args: Subset<T, TeamMemberAggregateArgs>
      ): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>;

      /**
       * Group by TeamMember.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamMemberGroupByArgs} args - Group by arguments.
       * @example
       * // Group by city, order by createdAt, get count
       * const result = await prisma.user.groupBy({
       *   by: ['city', 'createdAt'],
       *   orderBy: {
       *     createdAt: true
       *   },
       *   _count: {
       *     _all: true
       *   },
       * })
       *
       **/
      groupBy<
         T extends TeamMemberGroupByArgs,
         HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
         OrderByArg extends True extends HasSelectOrTake
            ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
            : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
         OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
         ByFields extends MaybeTupleToUnion<T['by']>,
         ByValid extends Has<ByFields, OrderFields>,
         HavingFields extends GetHavingFields<T['having']>,
         HavingValid extends Has<ByFields, HavingFields>,
         ByEmpty extends T['by'] extends never[] ? True : False,
         InputErrors extends ByEmpty extends True
            ? `Error: "by" must not be empty.`
            : HavingValid extends False
              ? {
                   [P in HavingFields]: P extends ByFields
                      ? never
                      : P extends string
                        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                        : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Keys<T>
                ? 'orderBy' extends Keys<T>
                   ? ByValid extends True
                      ? {}
                      : {
                           [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                        }[OrderFields]
                   : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Keys<T>
                  ? 'orderBy' extends Keys<T>
                     ? ByValid extends True
                        ? {}
                        : {
                             [P in OrderFields]: P extends ByFields
                                ? never
                                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                     : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends True
                    ? {}
                    : {
                         [P in OrderFields]: P extends ByFields
                            ? never
                            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
      >(
         args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors
      ): {} extends InputErrors
         ? GetTeamMemberGroupByPayload<T>
         : Prisma.PrismaPromise<InputErrors>;
      /**
       * Fields of the TeamMember model
       */
      readonly fields: TeamMemberFieldRefs;
   }

   /**
    * The delegate class that acts as a "Promise-like" for TeamMember.
    * Why is this prefixed with `Prisma__`?
    * Because we want to prevent naming conflicts as mentioned in
    * https://github.com/prisma/prisma-client-js/issues/707
    */
   export interface Prisma__TeamMemberClient<
      T,
      Null = never,
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > extends Prisma.PrismaPromise<T> {
      readonly [Symbol.toStringTag]: 'PrismaPromise';
      team<T extends TeamDefaultArgs<ExtArgs> = {}>(
         args?: Subset<T, TeamDefaultArgs<ExtArgs>>
      ): Prisma__TeamClient<
         | $Result.GetResult<
              Prisma.$TeamPayload<ExtArgs>,
              T,
              'findUniqueOrThrow',
              GlobalOmitOptions
           >
         | Null,
         Null,
         ExtArgs,
         GlobalOmitOptions
      >;
      user<T extends UserDefaultArgs<ExtArgs> = {}>(
         args?: Subset<T, UserDefaultArgs<ExtArgs>>
      ): Prisma__UserClient<
         | $Result.GetResult<
              Prisma.$UserPayload<ExtArgs>,
              T,
              'findUniqueOrThrow',
              GlobalOmitOptions
           >
         | Null,
         Null,
         ExtArgs,
         GlobalOmitOptions
      >;
      /**
       * Attaches callbacks for the resolution and/or rejection of the Promise.
       * @param onfulfilled The callback to execute when the Promise is resolved.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of which ever callback is executed.
       */
      then<TResult1 = T, TResult2 = never>(
         onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
         onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
      ): $Utils.JsPromise<TResult1 | TResult2>;
      /**
       * Attaches a callback for only the rejection of the Promise.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of the callback.
       */
      catch<TResult = never>(
         onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
      ): $Utils.JsPromise<T | TResult>;
      /**
       * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
       * resolved value cannot be modified from the callback.
       * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
       * @returns A Promise for the completion of the callback.
       */
      finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
   }

   /**
    * Fields of the TeamMember model
    */
   interface TeamMemberFieldRefs {
      readonly id: FieldRef<'TeamMember', 'String'>;
      readonly teamId: FieldRef<'TeamMember', 'String'>;
      readonly userId: FieldRef<'TeamMember', 'String'>;
   }

   // Custom InputTypes
   /**
    * TeamMember findUnique
    */
   export type TeamMemberFindUniqueArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamMember
       */
      select?: TeamMemberSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamMember
       */
      omit?: TeamMemberOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamMemberInclude<ExtArgs> | null;
      /**
       * Filter, which TeamMember to fetch.
       */
      where: TeamMemberWhereUniqueInput;
   };

   /**
    * TeamMember findUniqueOrThrow
    */
   export type TeamMemberFindUniqueOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamMember
       */
      select?: TeamMemberSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamMember
       */
      omit?: TeamMemberOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamMemberInclude<ExtArgs> | null;
      /**
       * Filter, which TeamMember to fetch.
       */
      where: TeamMemberWhereUniqueInput;
   };

   /**
    * TeamMember findFirst
    */
   export type TeamMemberFindFirstArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamMember
       */
      select?: TeamMemberSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamMember
       */
      omit?: TeamMemberOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamMemberInclude<ExtArgs> | null;
      /**
       * Filter, which TeamMember to fetch.
       */
      where?: TeamMemberWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of TeamMembers to fetch.
       */
      orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for TeamMembers.
       */
      cursor?: TeamMemberWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` TeamMembers from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` TeamMembers.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of TeamMembers.
       */
      distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
   };

   /**
    * TeamMember findFirstOrThrow
    */
   export type TeamMemberFindFirstOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamMember
       */
      select?: TeamMemberSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamMember
       */
      omit?: TeamMemberOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamMemberInclude<ExtArgs> | null;
      /**
       * Filter, which TeamMember to fetch.
       */
      where?: TeamMemberWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of TeamMembers to fetch.
       */
      orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for TeamMembers.
       */
      cursor?: TeamMemberWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` TeamMembers from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` TeamMembers.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of TeamMembers.
       */
      distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
   };

   /**
    * TeamMember findMany
    */
   export type TeamMemberFindManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamMember
       */
      select?: TeamMemberSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamMember
       */
      omit?: TeamMemberOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamMemberInclude<ExtArgs> | null;
      /**
       * Filter, which TeamMembers to fetch.
       */
      where?: TeamMemberWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of TeamMembers to fetch.
       */
      orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing TeamMembers.
       */
      cursor?: TeamMemberWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` TeamMembers from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` TeamMembers.
       */
      skip?: number;
      distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[];
   };

   /**
    * TeamMember create
    */
   export type TeamMemberCreateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamMember
       */
      select?: TeamMemberSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamMember
       */
      omit?: TeamMemberOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamMemberInclude<ExtArgs> | null;
      /**
       * The data needed to create a TeamMember.
       */
      data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>;
   };

   /**
    * TeamMember createMany
    */
   export type TeamMemberCreateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to create many TeamMembers.
       */
      data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[];
   };

   /**
    * TeamMember createManyAndReturn
    */
   export type TeamMemberCreateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamMember
       */
      select?: TeamMemberSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamMember
       */
      omit?: TeamMemberOmit<ExtArgs> | null;
      /**
       * The data used to create many TeamMembers.
       */
      data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[];
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamMemberIncludeCreateManyAndReturn<ExtArgs> | null;
   };

   /**
    * TeamMember update
    */
   export type TeamMemberUpdateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamMember
       */
      select?: TeamMemberSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamMember
       */
      omit?: TeamMemberOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamMemberInclude<ExtArgs> | null;
      /**
       * The data needed to update a TeamMember.
       */
      data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>;
      /**
       * Choose, which TeamMember to update.
       */
      where: TeamMemberWhereUniqueInput;
   };

   /**
    * TeamMember updateMany
    */
   export type TeamMemberUpdateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to update TeamMembers.
       */
      data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>;
      /**
       * Filter which TeamMembers to update
       */
      where?: TeamMemberWhereInput;
      /**
       * Limit how many TeamMembers to update.
       */
      limit?: number;
   };

   /**
    * TeamMember updateManyAndReturn
    */
   export type TeamMemberUpdateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamMember
       */
      select?: TeamMemberSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamMember
       */
      omit?: TeamMemberOmit<ExtArgs> | null;
      /**
       * The data used to update TeamMembers.
       */
      data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>;
      /**
       * Filter which TeamMembers to update
       */
      where?: TeamMemberWhereInput;
      /**
       * Limit how many TeamMembers to update.
       */
      limit?: number;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamMemberIncludeUpdateManyAndReturn<ExtArgs> | null;
   };

   /**
    * TeamMember upsert
    */
   export type TeamMemberUpsertArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamMember
       */
      select?: TeamMemberSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamMember
       */
      omit?: TeamMemberOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamMemberInclude<ExtArgs> | null;
      /**
       * The filter to search for the TeamMember to update in case it exists.
       */
      where: TeamMemberWhereUniqueInput;
      /**
       * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
       */
      create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>;
      /**
       * In case the TeamMember was found with the provided `where` argument, update it with this data.
       */
      update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>;
   };

   /**
    * TeamMember delete
    */
   export type TeamMemberDeleteArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamMember
       */
      select?: TeamMemberSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamMember
       */
      omit?: TeamMemberOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamMemberInclude<ExtArgs> | null;
      /**
       * Filter which TeamMember to delete.
       */
      where: TeamMemberWhereUniqueInput;
   };

   /**
    * TeamMember deleteMany
    */
   export type TeamMemberDeleteManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which TeamMembers to delete
       */
      where?: TeamMemberWhereInput;
      /**
       * Limit how many TeamMembers to delete.
       */
      limit?: number;
   };

   /**
    * TeamMember without action
    */
   export type TeamMemberDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamMember
       */
      select?: TeamMemberSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamMember
       */
      omit?: TeamMemberOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamMemberInclude<ExtArgs> | null;
   };

   /**
    * Model TeamProject
    */

   export type AggregateTeamProject = {
      _count: TeamProjectCountAggregateOutputType | null;
      _min: TeamProjectMinAggregateOutputType | null;
      _max: TeamProjectMaxAggregateOutputType | null;
   };

   export type TeamProjectMinAggregateOutputType = {
      id: string | null;
      teamId: string | null;
      projectId: string | null;
   };

   export type TeamProjectMaxAggregateOutputType = {
      id: string | null;
      teamId: string | null;
      projectId: string | null;
   };

   export type TeamProjectCountAggregateOutputType = {
      id: number;
      teamId: number;
      projectId: number;
      _all: number;
   };

   export type TeamProjectMinAggregateInputType = {
      id?: true;
      teamId?: true;
      projectId?: true;
   };

   export type TeamProjectMaxAggregateInputType = {
      id?: true;
      teamId?: true;
      projectId?: true;
   };

   export type TeamProjectCountAggregateInputType = {
      id?: true;
      teamId?: true;
      projectId?: true;
      _all?: true;
   };

   export type TeamProjectAggregateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which TeamProject to aggregate.
       */
      where?: TeamProjectWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of TeamProjects to fetch.
       */
      orderBy?: TeamProjectOrderByWithRelationInput | TeamProjectOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the start position
       */
      cursor?: TeamProjectWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` TeamProjects from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` TeamProjects.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Count returned TeamProjects
       **/
      _count?: true | TeamProjectCountAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the minimum value
       **/
      _min?: TeamProjectMinAggregateInputType;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
       *
       * Select which fields to find the maximum value
       **/
      _max?: TeamProjectMaxAggregateInputType;
   };

   export type GetTeamProjectAggregateType<T extends TeamProjectAggregateArgs> = {
      [P in keyof T & keyof AggregateTeamProject]: P extends '_count' | 'count'
         ? T[P] extends true
            ? number
            : GetScalarType<T[P], AggregateTeamProject[P]>
         : GetScalarType<T[P], AggregateTeamProject[P]>;
   };

   export type TeamProjectGroupByArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      where?: TeamProjectWhereInput;
      orderBy?: TeamProjectOrderByWithAggregationInput | TeamProjectOrderByWithAggregationInput[];
      by: TeamProjectScalarFieldEnum[] | TeamProjectScalarFieldEnum;
      having?: TeamProjectScalarWhereWithAggregatesInput;
      take?: number;
      skip?: number;
      _count?: TeamProjectCountAggregateInputType | true;
      _min?: TeamProjectMinAggregateInputType;
      _max?: TeamProjectMaxAggregateInputType;
   };

   export type TeamProjectGroupByOutputType = {
      id: string;
      teamId: string;
      projectId: string;
      _count: TeamProjectCountAggregateOutputType | null;
      _min: TeamProjectMinAggregateOutputType | null;
      _max: TeamProjectMaxAggregateOutputType | null;
   };

   type GetTeamProjectGroupByPayload<T extends TeamProjectGroupByArgs> = Prisma.PrismaPromise<
      Array<
         PickEnumerable<TeamProjectGroupByOutputType, T['by']> & {
            [P in keyof T & keyof TeamProjectGroupByOutputType]: P extends '_count'
               ? T[P] extends boolean
                  ? number
                  : GetScalarType<T[P], TeamProjectGroupByOutputType[P]>
               : GetScalarType<T[P], TeamProjectGroupByOutputType[P]>;
         }
      >
   >;

   export type TeamProjectSelect<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         teamId?: boolean;
         projectId?: boolean;
         team?: boolean | TeamDefaultArgs<ExtArgs>;
         project?: boolean | ProjectDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['teamProject']
   >;

   export type TeamProjectSelectCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         teamId?: boolean;
         projectId?: boolean;
         team?: boolean | TeamDefaultArgs<ExtArgs>;
         project?: boolean | ProjectDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['teamProject']
   >;

   export type TeamProjectSelectUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = $Extensions.GetSelect<
      {
         id?: boolean;
         teamId?: boolean;
         projectId?: boolean;
         team?: boolean | TeamDefaultArgs<ExtArgs>;
         project?: boolean | ProjectDefaultArgs<ExtArgs>;
      },
      ExtArgs['result']['teamProject']
   >;

   export type TeamProjectSelectScalar = {
      id?: boolean;
      teamId?: boolean;
      projectId?: boolean;
   };

   export type TeamProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      $Extensions.GetOmit<'id' | 'teamId' | 'projectId', ExtArgs['result']['teamProject']>;
   export type TeamProjectInclude<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      team?: boolean | TeamDefaultArgs<ExtArgs>;
      project?: boolean | ProjectDefaultArgs<ExtArgs>;
   };
   export type TeamProjectIncludeCreateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      team?: boolean | TeamDefaultArgs<ExtArgs>;
      project?: boolean | ProjectDefaultArgs<ExtArgs>;
   };
   export type TeamProjectIncludeUpdateManyAndReturn<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      team?: boolean | TeamDefaultArgs<ExtArgs>;
      project?: boolean | ProjectDefaultArgs<ExtArgs>;
   };

   export type $TeamProjectPayload<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      name: 'TeamProject';
      objects: {
         team: Prisma.$TeamPayload<ExtArgs>;
         project: Prisma.$ProjectPayload<ExtArgs>;
      };
      scalars: $Extensions.GetPayloadResult<
         {
            id: string;
            teamId: string;
            projectId: string;
         },
         ExtArgs['result']['teamProject']
      >;
      composites: {};
   };

   type TeamProjectGetPayload<S extends boolean | null | undefined | TeamProjectDefaultArgs> =
      $Result.GetResult<Prisma.$TeamProjectPayload, S>;

   type TeamProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
      Omit<TeamProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
         select?: TeamProjectCountAggregateInputType | true;
      };

   export interface TeamProjectDelegate<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > {
      [K: symbol]: {
         types: Prisma.TypeMap<ExtArgs>['model']['TeamProject'];
         meta: { name: 'TeamProject' };
      };
      /**
       * Find zero or one TeamProject that matches the filter.
       * @param {TeamProjectFindUniqueArgs} args - Arguments to find a TeamProject
       * @example
       * // Get one TeamProject
       * const teamProject = await prisma.teamProject.findUnique({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUnique<T extends TeamProjectFindUniqueArgs>(
         args: SelectSubset<T, TeamProjectFindUniqueArgs<ExtArgs>>
      ): Prisma__TeamProjectClient<
         $Result.GetResult<
            Prisma.$TeamProjectPayload<ExtArgs>,
            T,
            'findUnique',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find one TeamProject that matches the filter or throw an error with `error.code='P2025'`
       * if no matches were found.
       * @param {TeamProjectFindUniqueOrThrowArgs} args - Arguments to find a TeamProject
       * @example
       * // Get one TeamProject
       * const teamProject = await prisma.teamProject.findUniqueOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findUniqueOrThrow<T extends TeamProjectFindUniqueOrThrowArgs>(
         args: SelectSubset<T, TeamProjectFindUniqueOrThrowArgs<ExtArgs>>
      ): Prisma__TeamProjectClient<
         $Result.GetResult<
            Prisma.$TeamProjectPayload<ExtArgs>,
            T,
            'findUniqueOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first TeamProject that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamProjectFindFirstArgs} args - Arguments to find a TeamProject
       * @example
       * // Get one TeamProject
       * const teamProject = await prisma.teamProject.findFirst({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirst<T extends TeamProjectFindFirstArgs>(
         args?: SelectSubset<T, TeamProjectFindFirstArgs<ExtArgs>>
      ): Prisma__TeamProjectClient<
         $Result.GetResult<
            Prisma.$TeamProjectPayload<ExtArgs>,
            T,
            'findFirst',
            GlobalOmitOptions
         > | null,
         null,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find the first TeamProject that matches the filter or
       * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamProjectFindFirstOrThrowArgs} args - Arguments to find a TeamProject
       * @example
       * // Get one TeamProject
       * const teamProject = await prisma.teamProject.findFirstOrThrow({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       */
      findFirstOrThrow<T extends TeamProjectFindFirstOrThrowArgs>(
         args?: SelectSubset<T, TeamProjectFindFirstOrThrowArgs<ExtArgs>>
      ): Prisma__TeamProjectClient<
         $Result.GetResult<
            Prisma.$TeamProjectPayload<ExtArgs>,
            T,
            'findFirstOrThrow',
            GlobalOmitOptions
         >,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Find zero or more TeamProjects that matches the filter.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamProjectFindManyArgs} args - Arguments to filter and select certain fields only.
       * @example
       * // Get all TeamProjects
       * const teamProjects = await prisma.teamProject.findMany()
       *
       * // Get first 10 TeamProjects
       * const teamProjects = await prisma.teamProject.findMany({ take: 10 })
       *
       * // Only select the `id`
       * const teamProjectWithIdOnly = await prisma.teamProject.findMany({ select: { id: true } })
       *
       */
      findMany<T extends TeamProjectFindManyArgs>(
         args?: SelectSubset<T, TeamProjectFindManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<Prisma.$TeamProjectPayload<ExtArgs>, T, 'findMany', GlobalOmitOptions>
      >;

      /**
       * Create a TeamProject.
       * @param {TeamProjectCreateArgs} args - Arguments to create a TeamProject.
       * @example
       * // Create one TeamProject
       * const TeamProject = await prisma.teamProject.create({
       *   data: {
       *     // ... data to create a TeamProject
       *   }
       * })
       *
       */
      create<T extends TeamProjectCreateArgs>(
         args: SelectSubset<T, TeamProjectCreateArgs<ExtArgs>>
      ): Prisma__TeamProjectClient<
         $Result.GetResult<Prisma.$TeamProjectPayload<ExtArgs>, T, 'create', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Create many TeamProjects.
       * @param {TeamProjectCreateManyArgs} args - Arguments to create many TeamProjects.
       * @example
       * // Create many TeamProjects
       * const teamProject = await prisma.teamProject.createMany({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       */
      createMany<T extends TeamProjectCreateManyArgs>(
         args?: SelectSubset<T, TeamProjectCreateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Create many TeamProjects and returns the data saved in the database.
       * @param {TeamProjectCreateManyAndReturnArgs} args - Arguments to create many TeamProjects.
       * @example
       * // Create many TeamProjects
       * const teamProject = await prisma.teamProject.createManyAndReturn({
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Create many TeamProjects and only return the `id`
       * const teamProjectWithIdOnly = await prisma.teamProject.createManyAndReturn({
       *   select: { id: true },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      createManyAndReturn<T extends TeamProjectCreateManyAndReturnArgs>(
         args?: SelectSubset<T, TeamProjectCreateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$TeamProjectPayload<ExtArgs>,
            T,
            'createManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Delete a TeamProject.
       * @param {TeamProjectDeleteArgs} args - Arguments to delete one TeamProject.
       * @example
       * // Delete one TeamProject
       * const TeamProject = await prisma.teamProject.delete({
       *   where: {
       *     // ... filter to delete one TeamProject
       *   }
       * })
       *
       */
      delete<T extends TeamProjectDeleteArgs>(
         args: SelectSubset<T, TeamProjectDeleteArgs<ExtArgs>>
      ): Prisma__TeamProjectClient<
         $Result.GetResult<Prisma.$TeamProjectPayload<ExtArgs>, T, 'delete', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Update one TeamProject.
       * @param {TeamProjectUpdateArgs} args - Arguments to update one TeamProject.
       * @example
       * // Update one TeamProject
       * const teamProject = await prisma.teamProject.update({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      update<T extends TeamProjectUpdateArgs>(
         args: SelectSubset<T, TeamProjectUpdateArgs<ExtArgs>>
      ): Prisma__TeamProjectClient<
         $Result.GetResult<Prisma.$TeamProjectPayload<ExtArgs>, T, 'update', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Delete zero or more TeamProjects.
       * @param {TeamProjectDeleteManyArgs} args - Arguments to filter TeamProjects to delete.
       * @example
       * // Delete a few TeamProjects
       * const { count } = await prisma.teamProject.deleteMany({
       *   where: {
       *     // ... provide filter here
       *   }
       * })
       *
       */
      deleteMany<T extends TeamProjectDeleteManyArgs>(
         args?: SelectSubset<T, TeamProjectDeleteManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more TeamProjects.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamProjectUpdateManyArgs} args - Arguments to update one or more rows.
       * @example
       * // Update many TeamProjects
       * const teamProject = await prisma.teamProject.updateMany({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: {
       *     // ... provide data here
       *   }
       * })
       *
       */
      updateMany<T extends TeamProjectUpdateManyArgs>(
         args: SelectSubset<T, TeamProjectUpdateManyArgs<ExtArgs>>
      ): Prisma.PrismaPromise<BatchPayload>;

      /**
       * Update zero or more TeamProjects and returns the data updated in the database.
       * @param {TeamProjectUpdateManyAndReturnArgs} args - Arguments to update many TeamProjects.
       * @example
       * // Update many TeamProjects
       * const teamProject = await prisma.teamProject.updateManyAndReturn({
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       *
       * // Update zero or more TeamProjects and only return the `id`
       * const teamProjectWithIdOnly = await prisma.teamProject.updateManyAndReturn({
       *   select: { id: true },
       *   where: {
       *     // ... provide filter here
       *   },
       *   data: [
       *     // ... provide data here
       *   ]
       * })
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       *
       */
      updateManyAndReturn<T extends TeamProjectUpdateManyAndReturnArgs>(
         args: SelectSubset<T, TeamProjectUpdateManyAndReturnArgs<ExtArgs>>
      ): Prisma.PrismaPromise<
         $Result.GetResult<
            Prisma.$TeamProjectPayload<ExtArgs>,
            T,
            'updateManyAndReturn',
            GlobalOmitOptions
         >
      >;

      /**
       * Create or update one TeamProject.
       * @param {TeamProjectUpsertArgs} args - Arguments to update or create a TeamProject.
       * @example
       * // Update or create a TeamProject
       * const teamProject = await prisma.teamProject.upsert({
       *   create: {
       *     // ... data to create a TeamProject
       *   },
       *   update: {
       *     // ... in case it already exists, update
       *   },
       *   where: {
       *     // ... the filter for the TeamProject we want to update
       *   }
       * })
       */
      upsert<T extends TeamProjectUpsertArgs>(
         args: SelectSubset<T, TeamProjectUpsertArgs<ExtArgs>>
      ): Prisma__TeamProjectClient<
         $Result.GetResult<Prisma.$TeamProjectPayload<ExtArgs>, T, 'upsert', GlobalOmitOptions>,
         never,
         ExtArgs,
         GlobalOmitOptions
      >;

      /**
       * Count the number of TeamProjects.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamProjectCountArgs} args - Arguments to filter TeamProjects to count.
       * @example
       * // Count the number of TeamProjects
       * const count = await prisma.teamProject.count({
       *   where: {
       *     // ... the filter for the TeamProjects we want to count
       *   }
       * })
       **/
      count<T extends TeamProjectCountArgs>(
         args?: Subset<T, TeamProjectCountArgs>
      ): Prisma.PrismaPromise<
         T extends $Utils.Record<'select', any>
            ? T['select'] extends true
               ? number
               : GetScalarType<T['select'], TeamProjectCountAggregateOutputType>
            : number
      >;

      /**
       * Allows you to perform aggregations operations on a TeamProject.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
       * @example
       * // Ordered by age ascending
       * // Where email contains prisma.io
       * // Limited to the 10 users
       * const aggregations = await prisma.user.aggregate({
       *   _avg: {
       *     age: true,
       *   },
       *   where: {
       *     email: {
       *       contains: "prisma.io",
       *     },
       *   },
       *   orderBy: {
       *     age: "asc",
       *   },
       *   take: 10,
       * })
       **/
      aggregate<T extends TeamProjectAggregateArgs>(
         args: Subset<T, TeamProjectAggregateArgs>
      ): Prisma.PrismaPromise<GetTeamProjectAggregateType<T>>;

      /**
       * Group by TeamProject.
       * Note, that providing `undefined` is treated as the value not being there.
       * Read more here: https://pris.ly/d/null-undefined
       * @param {TeamProjectGroupByArgs} args - Group by arguments.
       * @example
       * // Group by city, order by createdAt, get count
       * const result = await prisma.user.groupBy({
       *   by: ['city', 'createdAt'],
       *   orderBy: {
       *     createdAt: true
       *   },
       *   _count: {
       *     _all: true
       *   },
       * })
       *
       **/
      groupBy<
         T extends TeamProjectGroupByArgs,
         HasSelectOrTake extends Or<Extends<'skip', Keys<T>>, Extends<'take', Keys<T>>>,
         OrderByArg extends True extends HasSelectOrTake
            ? { orderBy: TeamProjectGroupByArgs['orderBy'] }
            : { orderBy?: TeamProjectGroupByArgs['orderBy'] },
         OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
         ByFields extends MaybeTupleToUnion<T['by']>,
         ByValid extends Has<ByFields, OrderFields>,
         HavingFields extends GetHavingFields<T['having']>,
         HavingValid extends Has<ByFields, HavingFields>,
         ByEmpty extends T['by'] extends never[] ? True : False,
         InputErrors extends ByEmpty extends True
            ? `Error: "by" must not be empty.`
            : HavingValid extends False
              ? {
                   [P in HavingFields]: P extends ByFields
                      ? never
                      : P extends string
                        ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
                        : [Error, 'Field ', P, ` in "having" needs to be provided in "by"`];
                }[HavingFields]
              : 'take' extends Keys<T>
                ? 'orderBy' extends Keys<T>
                   ? ByValid extends True
                      ? {}
                      : {
                           [P in OrderFields]: P extends ByFields
                              ? never
                              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                        }[OrderFields]
                   : 'Error: If you provide "take", you also need to provide "orderBy"'
                : 'skip' extends Keys<T>
                  ? 'orderBy' extends Keys<T>
                     ? ByValid extends True
                        ? {}
                        : {
                             [P in OrderFields]: P extends ByFields
                                ? never
                                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                          }[OrderFields]
                     : 'Error: If you provide "skip", you also need to provide "orderBy"'
                  : ByValid extends True
                    ? {}
                    : {
                         [P in OrderFields]: P extends ByFields
                            ? never
                            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`;
                      }[OrderFields],
      >(
         args: SubsetIntersection<T, TeamProjectGroupByArgs, OrderByArg> & InputErrors
      ): {} extends InputErrors
         ? GetTeamProjectGroupByPayload<T>
         : Prisma.PrismaPromise<InputErrors>;
      /**
       * Fields of the TeamProject model
       */
      readonly fields: TeamProjectFieldRefs;
   }

   /**
    * The delegate class that acts as a "Promise-like" for TeamProject.
    * Why is this prefixed with `Prisma__`?
    * Because we want to prevent naming conflicts as mentioned in
    * https://github.com/prisma/prisma-client-js/issues/707
    */
   export interface Prisma__TeamProjectClient<
      T,
      Null = never,
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
      GlobalOmitOptions = {},
   > extends Prisma.PrismaPromise<T> {
      readonly [Symbol.toStringTag]: 'PrismaPromise';
      team<T extends TeamDefaultArgs<ExtArgs> = {}>(
         args?: Subset<T, TeamDefaultArgs<ExtArgs>>
      ): Prisma__TeamClient<
         | $Result.GetResult<
              Prisma.$TeamPayload<ExtArgs>,
              T,
              'findUniqueOrThrow',
              GlobalOmitOptions
           >
         | Null,
         Null,
         ExtArgs,
         GlobalOmitOptions
      >;
      project<T extends ProjectDefaultArgs<ExtArgs> = {}>(
         args?: Subset<T, ProjectDefaultArgs<ExtArgs>>
      ): Prisma__ProjectClient<
         | $Result.GetResult<
              Prisma.$ProjectPayload<ExtArgs>,
              T,
              'findUniqueOrThrow',
              GlobalOmitOptions
           >
         | Null,
         Null,
         ExtArgs,
         GlobalOmitOptions
      >;
      /**
       * Attaches callbacks for the resolution and/or rejection of the Promise.
       * @param onfulfilled The callback to execute when the Promise is resolved.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of which ever callback is executed.
       */
      then<TResult1 = T, TResult2 = never>(
         onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null,
         onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null
      ): $Utils.JsPromise<TResult1 | TResult2>;
      /**
       * Attaches a callback for only the rejection of the Promise.
       * @param onrejected The callback to execute when the Promise is rejected.
       * @returns A Promise for the completion of the callback.
       */
      catch<TResult = never>(
         onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null
      ): $Utils.JsPromise<T | TResult>;
      /**
       * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
       * resolved value cannot be modified from the callback.
       * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
       * @returns A Promise for the completion of the callback.
       */
      finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
   }

   /**
    * Fields of the TeamProject model
    */
   interface TeamProjectFieldRefs {
      readonly id: FieldRef<'TeamProject', 'String'>;
      readonly teamId: FieldRef<'TeamProject', 'String'>;
      readonly projectId: FieldRef<'TeamProject', 'String'>;
   }

   // Custom InputTypes
   /**
    * TeamProject findUnique
    */
   export type TeamProjectFindUniqueArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamProject
       */
      select?: TeamProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamProject
       */
      omit?: TeamProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamProjectInclude<ExtArgs> | null;
      /**
       * Filter, which TeamProject to fetch.
       */
      where: TeamProjectWhereUniqueInput;
   };

   /**
    * TeamProject findUniqueOrThrow
    */
   export type TeamProjectFindUniqueOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamProject
       */
      select?: TeamProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamProject
       */
      omit?: TeamProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamProjectInclude<ExtArgs> | null;
      /**
       * Filter, which TeamProject to fetch.
       */
      where: TeamProjectWhereUniqueInput;
   };

   /**
    * TeamProject findFirst
    */
   export type TeamProjectFindFirstArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamProject
       */
      select?: TeamProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamProject
       */
      omit?: TeamProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamProjectInclude<ExtArgs> | null;
      /**
       * Filter, which TeamProject to fetch.
       */
      where?: TeamProjectWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of TeamProjects to fetch.
       */
      orderBy?: TeamProjectOrderByWithRelationInput | TeamProjectOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for TeamProjects.
       */
      cursor?: TeamProjectWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` TeamProjects from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` TeamProjects.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of TeamProjects.
       */
      distinct?: TeamProjectScalarFieldEnum | TeamProjectScalarFieldEnum[];
   };

   /**
    * TeamProject findFirstOrThrow
    */
   export type TeamProjectFindFirstOrThrowArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamProject
       */
      select?: TeamProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamProject
       */
      omit?: TeamProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamProjectInclude<ExtArgs> | null;
      /**
       * Filter, which TeamProject to fetch.
       */
      where?: TeamProjectWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of TeamProjects to fetch.
       */
      orderBy?: TeamProjectOrderByWithRelationInput | TeamProjectOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for searching for TeamProjects.
       */
      cursor?: TeamProjectWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` TeamProjects from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` TeamProjects.
       */
      skip?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
       *
       * Filter by unique combinations of TeamProjects.
       */
      distinct?: TeamProjectScalarFieldEnum | TeamProjectScalarFieldEnum[];
   };

   /**
    * TeamProject findMany
    */
   export type TeamProjectFindManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamProject
       */
      select?: TeamProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamProject
       */
      omit?: TeamProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamProjectInclude<ExtArgs> | null;
      /**
       * Filter, which TeamProjects to fetch.
       */
      where?: TeamProjectWhereInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
       *
       * Determine the order of TeamProjects to fetch.
       */
      orderBy?: TeamProjectOrderByWithRelationInput | TeamProjectOrderByWithRelationInput[];
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
       *
       * Sets the position for listing TeamProjects.
       */
      cursor?: TeamProjectWhereUniqueInput;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Take `±n` TeamProjects from the position of the cursor.
       */
      take?: number;
      /**
       * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
       *
       * Skip the first `n` TeamProjects.
       */
      skip?: number;
      distinct?: TeamProjectScalarFieldEnum | TeamProjectScalarFieldEnum[];
   };

   /**
    * TeamProject create
    */
   export type TeamProjectCreateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamProject
       */
      select?: TeamProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamProject
       */
      omit?: TeamProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamProjectInclude<ExtArgs> | null;
      /**
       * The data needed to create a TeamProject.
       */
      data: XOR<TeamProjectCreateInput, TeamProjectUncheckedCreateInput>;
   };

   /**
    * TeamProject createMany
    */
   export type TeamProjectCreateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to create many TeamProjects.
       */
      data: TeamProjectCreateManyInput | TeamProjectCreateManyInput[];
   };

   /**
    * TeamProject createManyAndReturn
    */
   export type TeamProjectCreateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamProject
       */
      select?: TeamProjectSelectCreateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamProject
       */
      omit?: TeamProjectOmit<ExtArgs> | null;
      /**
       * The data used to create many TeamProjects.
       */
      data: TeamProjectCreateManyInput | TeamProjectCreateManyInput[];
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamProjectIncludeCreateManyAndReturn<ExtArgs> | null;
   };

   /**
    * TeamProject update
    */
   export type TeamProjectUpdateArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamProject
       */
      select?: TeamProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamProject
       */
      omit?: TeamProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamProjectInclude<ExtArgs> | null;
      /**
       * The data needed to update a TeamProject.
       */
      data: XOR<TeamProjectUpdateInput, TeamProjectUncheckedUpdateInput>;
      /**
       * Choose, which TeamProject to update.
       */
      where: TeamProjectWhereUniqueInput;
   };

   /**
    * TeamProject updateMany
    */
   export type TeamProjectUpdateManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * The data used to update TeamProjects.
       */
      data: XOR<TeamProjectUpdateManyMutationInput, TeamProjectUncheckedUpdateManyInput>;
      /**
       * Filter which TeamProjects to update
       */
      where?: TeamProjectWhereInput;
      /**
       * Limit how many TeamProjects to update.
       */
      limit?: number;
   };

   /**
    * TeamProject updateManyAndReturn
    */
   export type TeamProjectUpdateManyAndReturnArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamProject
       */
      select?: TeamProjectSelectUpdateManyAndReturn<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamProject
       */
      omit?: TeamProjectOmit<ExtArgs> | null;
      /**
       * The data used to update TeamProjects.
       */
      data: XOR<TeamProjectUpdateManyMutationInput, TeamProjectUncheckedUpdateManyInput>;
      /**
       * Filter which TeamProjects to update
       */
      where?: TeamProjectWhereInput;
      /**
       * Limit how many TeamProjects to update.
       */
      limit?: number;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamProjectIncludeUpdateManyAndReturn<ExtArgs> | null;
   };

   /**
    * TeamProject upsert
    */
   export type TeamProjectUpsertArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamProject
       */
      select?: TeamProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamProject
       */
      omit?: TeamProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamProjectInclude<ExtArgs> | null;
      /**
       * The filter to search for the TeamProject to update in case it exists.
       */
      where: TeamProjectWhereUniqueInput;
      /**
       * In case the TeamProject found by the `where` argument doesn't exist, create a new TeamProject with this data.
       */
      create: XOR<TeamProjectCreateInput, TeamProjectUncheckedCreateInput>;
      /**
       * In case the TeamProject was found with the provided `where` argument, update it with this data.
       */
      update: XOR<TeamProjectUpdateInput, TeamProjectUncheckedUpdateInput>;
   };

   /**
    * TeamProject delete
    */
   export type TeamProjectDeleteArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamProject
       */
      select?: TeamProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamProject
       */
      omit?: TeamProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamProjectInclude<ExtArgs> | null;
      /**
       * Filter which TeamProject to delete.
       */
      where: TeamProjectWhereUniqueInput;
   };

   /**
    * TeamProject deleteMany
    */
   export type TeamProjectDeleteManyArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Filter which TeamProjects to delete
       */
      where?: TeamProjectWhereInput;
      /**
       * Limit how many TeamProjects to delete.
       */
      limit?: number;
   };

   /**
    * TeamProject without action
    */
   export type TeamProjectDefaultArgs<
      ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs,
   > = {
      /**
       * Select specific fields to fetch from the TeamProject
       */
      select?: TeamProjectSelect<ExtArgs> | null;
      /**
       * Omit specific fields from the TeamProject
       */
      omit?: TeamProjectOmit<ExtArgs> | null;
      /**
       * Choose, which related nodes to fetch as well
       */
      include?: TeamProjectInclude<ExtArgs> | null;
   };

   /**
    * Enums
    */

   export const TransactionIsolationLevel: {
      Serializable: 'Serializable';
   };

   export type TransactionIsolationLevel =
      (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel];

   export const TaskScalarFieldEnum: {
      id: 'id';
      title: 'title';
      description: 'description';
      details: 'details';
      testStrategy: 'testStrategy';
      priority: 'priority';
      status: 'status';
      complexity: 'complexity';
      createdAt: 'createdAt';
      updatedAt: 'updatedAt';
   };

   export type TaskScalarFieldEnum = (typeof TaskScalarFieldEnum)[keyof typeof TaskScalarFieldEnum];

   export const SubtaskScalarFieldEnum: {
      id: 'id';
      title: 'title';
      description: 'description';
      details: 'details';
      testStrategy: 'testStrategy';
      status: 'status';
      parentId: 'parentId';
      dependencies: 'dependencies';
      createdAt: 'createdAt';
      updatedAt: 'updatedAt';
   };

   export type SubtaskScalarFieldEnum =
      (typeof SubtaskScalarFieldEnum)[keyof typeof SubtaskScalarFieldEnum];

   export const TaskDependencyScalarFieldEnum: {
      id: 'id';
      taskId: 'taskId';
      dependsOnId: 'dependsOnId';
      createdAt: 'createdAt';
   };

   export type TaskDependencyScalarFieldEnum =
      (typeof TaskDependencyScalarFieldEnum)[keyof typeof TaskDependencyScalarFieldEnum];

   export const TaskMasterMetadataScalarFieldEnum: {
      id: 'id';
      created: 'created';
      updated: 'updated';
      description: 'description';
   };

   export type TaskMasterMetadataScalarFieldEnum =
      (typeof TaskMasterMetadataScalarFieldEnum)[keyof typeof TaskMasterMetadataScalarFieldEnum];

   export const SyncOperationScalarFieldEnum: {
      id: 'id';
      type: 'type';
      status: 'status';
      source: 'source';
      timestamp: 'timestamp';
      completedAt: 'completedAt';
      data: 'data';
      rollbackData: 'rollbackData';
      metadata: 'metadata';
      retryCount: 'retryCount';
      maxRetries: 'maxRetries';
      error: 'error';
      taskIds: 'taskIds';
   };

   export type SyncOperationScalarFieldEnum =
      (typeof SyncOperationScalarFieldEnum)[keyof typeof SyncOperationScalarFieldEnum];

   export const SyncConflictScalarFieldEnum: {
      id: 'id';
      operationType: 'operationType';
      taskId: 'taskId';
      uiVersion: 'uiVersion';
      cliVersion: 'cliVersion';
      resolved: 'resolved';
      resolution: 'resolution';
      resolvedAt: 'resolvedAt';
      resolvedBy: 'resolvedBy';
      timestamp: 'timestamp';
   };

   export type SyncConflictScalarFieldEnum =
      (typeof SyncConflictScalarFieldEnum)[keyof typeof SyncConflictScalarFieldEnum];

   export const UserScalarFieldEnum: {
      id: 'id';
      name: 'name';
      email: 'email';
      avatarUrl: 'avatarUrl';
      status: 'status';
      role: 'role';
      joinedDate: 'joinedDate';
      teamIds: 'teamIds';
      createdAt: 'createdAt';
      updatedAt: 'updatedAt';
   };

   export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum];

   export const ProjectScalarFieldEnum: {
      id: 'id';
      name: 'name';
      description: 'description';
      color: 'color';
      identifier: 'identifier';
      icon: 'icon';
      percentComplete: 'percentComplete';
      startDate: 'startDate';
      health: 'health';
      leadId: 'leadId';
      createdAt: 'createdAt';
      updatedAt: 'updatedAt';
   };

   export type ProjectScalarFieldEnum =
      (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum];

   export const LabelScalarFieldEnum: {
      id: 'id';
      name: 'name';
      color: 'color';
      description: 'description';
      createdAt: 'createdAt';
      updatedAt: 'updatedAt';
   };

   export type LabelScalarFieldEnum =
      (typeof LabelScalarFieldEnum)[keyof typeof LabelScalarFieldEnum];

   export const IssueStatusScalarFieldEnum: {
      id: 'id';
      name: 'name';
      color: 'color';
      iconName: 'iconName';
      createdAt: 'createdAt';
      updatedAt: 'updatedAt';
   };

   export type IssueStatusScalarFieldEnum =
      (typeof IssueStatusScalarFieldEnum)[keyof typeof IssueStatusScalarFieldEnum];

   export const IssuePriorityScalarFieldEnum: {
      id: 'id';
      name: 'name';
      iconName: 'iconName';
      order: 'order';
      createdAt: 'createdAt';
      updatedAt: 'updatedAt';
   };

   export type IssuePriorityScalarFieldEnum =
      (typeof IssuePriorityScalarFieldEnum)[keyof typeof IssuePriorityScalarFieldEnum];

   export const IssueScalarFieldEnum: {
      id: 'id';
      identifier: 'identifier';
      title: 'title';
      description: 'description';
      statusId: 'statusId';
      priorityId: 'priorityId';
      status: 'status';
      priority: 'priority';
      rank: 'rank';
      cycleId: 'cycleId';
      dueDate: 'dueDate';
      taskId: 'taskId';
      subtaskId: 'subtaskId';
      issueType: 'issueType';
      assigneeId: 'assigneeId';
      projectId: 'projectId';
      subissues: 'subissues';
      createdAt: 'createdAt';
      updatedAt: 'updatedAt';
   };

   export type IssueScalarFieldEnum =
      (typeof IssueScalarFieldEnum)[keyof typeof IssueScalarFieldEnum];

   export const IssueLabelScalarFieldEnum: {
      id: 'id';
      issueId: 'issueId';
      labelId: 'labelId';
   };

   export type IssueLabelScalarFieldEnum =
      (typeof IssueLabelScalarFieldEnum)[keyof typeof IssueLabelScalarFieldEnum];

   export const CycleScalarFieldEnum: {
      id: 'id';
      number: 'number';
      name: 'name';
      teamId: 'teamId';
      startDate: 'startDate';
      endDate: 'endDate';
      progress: 'progress';
      createdAt: 'createdAt';
      updatedAt: 'updatedAt';
   };

   export type CycleScalarFieldEnum =
      (typeof CycleScalarFieldEnum)[keyof typeof CycleScalarFieldEnum];

   export const TeamScalarFieldEnum: {
      id: 'id';
      name: 'name';
      icon: 'icon';
      joined: 'joined';
      color: 'color';
      createdAt: 'createdAt';
      updatedAt: 'updatedAt';
   };

   export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum];

   export const TeamMemberScalarFieldEnum: {
      id: 'id';
      teamId: 'teamId';
      userId: 'userId';
   };

   export type TeamMemberScalarFieldEnum =
      (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum];

   export const TeamProjectScalarFieldEnum: {
      id: 'id';
      teamId: 'teamId';
      projectId: 'projectId';
   };

   export type TeamProjectScalarFieldEnum =
      (typeof TeamProjectScalarFieldEnum)[keyof typeof TeamProjectScalarFieldEnum];

   export const SortOrder: {
      asc: 'asc';
      desc: 'desc';
   };

   export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder];

   export const NullsOrder: {
      first: 'first';
      last: 'last';
   };

   export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder];

   /**
    * Field references
    */

   /**
    * Reference to a field of type 'Int'
    */
   export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>;

   /**
    * Reference to a field of type 'String'
    */
   export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>;

   /**
    * Reference to a field of type 'DateTime'
    */
   export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>;

   /**
    * Reference to a field of type 'Boolean'
    */
   export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>;

   /**
    * Reference to a field of type 'UserStatus'
    */
   export type EnumUserStatusFieldRefInput<$PrismaModel> = FieldRefInputType<
      $PrismaModel,
      'UserStatus'
   >;

   /**
    * Reference to a field of type 'UserRole'
    */
   export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<
      $PrismaModel,
      'UserRole'
   >;

   /**
    * Reference to a field of type 'ProjectHealth'
    */
   export type EnumProjectHealthFieldRefInput<$PrismaModel> = FieldRefInputType<
      $PrismaModel,
      'ProjectHealth'
   >;

   /**
    * Reference to a field of type 'IssueType'
    */
   export type EnumIssueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<
      $PrismaModel,
      'IssueType'
   >;

   /**
    * Reference to a field of type 'Float'
    */
   export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>;

   /**
    * Deep Input Types
    */

   export type TaskWhereInput = {
      AND?: TaskWhereInput | TaskWhereInput[];
      OR?: TaskWhereInput[];
      NOT?: TaskWhereInput | TaskWhereInput[];
      id?: IntFilter<'Task'> | number;
      title?: StringFilter<'Task'> | string;
      description?: StringFilter<'Task'> | string;
      details?: StringNullableFilter<'Task'> | string | null;
      testStrategy?: StringNullableFilter<'Task'> | string | null;
      priority?: StringFilter<'Task'> | string;
      status?: StringFilter<'Task'> | string;
      complexity?: IntNullableFilter<'Task'> | number | null;
      createdAt?: DateTimeFilter<'Task'> | Date | string;
      updatedAt?: DateTimeFilter<'Task'> | Date | string;
      subtasks?: SubtaskListRelationFilter;
      dependencies?: TaskDependencyListRelationFilter;
      dependents?: TaskDependencyListRelationFilter;
      issues?: IssueListRelationFilter;
   };

   export type TaskOrderByWithRelationInput = {
      id?: SortOrder;
      title?: SortOrder;
      description?: SortOrder;
      details?: SortOrderInput | SortOrder;
      testStrategy?: SortOrderInput | SortOrder;
      priority?: SortOrder;
      status?: SortOrder;
      complexity?: SortOrderInput | SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      subtasks?: SubtaskOrderByRelationAggregateInput;
      dependencies?: TaskDependencyOrderByRelationAggregateInput;
      dependents?: TaskDependencyOrderByRelationAggregateInput;
      issues?: IssueOrderByRelationAggregateInput;
   };

   export type TaskWhereUniqueInput = Prisma.AtLeast<
      {
         id?: number;
         AND?: TaskWhereInput | TaskWhereInput[];
         OR?: TaskWhereInput[];
         NOT?: TaskWhereInput | TaskWhereInput[];
         title?: StringFilter<'Task'> | string;
         description?: StringFilter<'Task'> | string;
         details?: StringNullableFilter<'Task'> | string | null;
         testStrategy?: StringNullableFilter<'Task'> | string | null;
         priority?: StringFilter<'Task'> | string;
         status?: StringFilter<'Task'> | string;
         complexity?: IntNullableFilter<'Task'> | number | null;
         createdAt?: DateTimeFilter<'Task'> | Date | string;
         updatedAt?: DateTimeFilter<'Task'> | Date | string;
         subtasks?: SubtaskListRelationFilter;
         dependencies?: TaskDependencyListRelationFilter;
         dependents?: TaskDependencyListRelationFilter;
         issues?: IssueListRelationFilter;
      },
      'id'
   >;

   export type TaskOrderByWithAggregationInput = {
      id?: SortOrder;
      title?: SortOrder;
      description?: SortOrder;
      details?: SortOrderInput | SortOrder;
      testStrategy?: SortOrderInput | SortOrder;
      priority?: SortOrder;
      status?: SortOrder;
      complexity?: SortOrderInput | SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      _count?: TaskCountOrderByAggregateInput;
      _avg?: TaskAvgOrderByAggregateInput;
      _max?: TaskMaxOrderByAggregateInput;
      _min?: TaskMinOrderByAggregateInput;
      _sum?: TaskSumOrderByAggregateInput;
   };

   export type TaskScalarWhereWithAggregatesInput = {
      AND?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[];
      OR?: TaskScalarWhereWithAggregatesInput[];
      NOT?: TaskScalarWhereWithAggregatesInput | TaskScalarWhereWithAggregatesInput[];
      id?: IntWithAggregatesFilter<'Task'> | number;
      title?: StringWithAggregatesFilter<'Task'> | string;
      description?: StringWithAggregatesFilter<'Task'> | string;
      details?: StringNullableWithAggregatesFilter<'Task'> | string | null;
      testStrategy?: StringNullableWithAggregatesFilter<'Task'> | string | null;
      priority?: StringWithAggregatesFilter<'Task'> | string;
      status?: StringWithAggregatesFilter<'Task'> | string;
      complexity?: IntNullableWithAggregatesFilter<'Task'> | number | null;
      createdAt?: DateTimeWithAggregatesFilter<'Task'> | Date | string;
      updatedAt?: DateTimeWithAggregatesFilter<'Task'> | Date | string;
   };

   export type SubtaskWhereInput = {
      AND?: SubtaskWhereInput | SubtaskWhereInput[];
      OR?: SubtaskWhereInput[];
      NOT?: SubtaskWhereInput | SubtaskWhereInput[];
      id?: StringFilter<'Subtask'> | string;
      title?: StringFilter<'Subtask'> | string;
      description?: StringFilter<'Subtask'> | string;
      details?: StringNullableFilter<'Subtask'> | string | null;
      testStrategy?: StringNullableFilter<'Subtask'> | string | null;
      status?: StringFilter<'Subtask'> | string;
      parentId?: IntFilter<'Subtask'> | number;
      dependencies?: StringFilter<'Subtask'> | string;
      createdAt?: DateTimeFilter<'Subtask'> | Date | string;
      updatedAt?: DateTimeFilter<'Subtask'> | Date | string;
      parentTask?: XOR<TaskScalarRelationFilter, TaskWhereInput>;
   };

   export type SubtaskOrderByWithRelationInput = {
      id?: SortOrder;
      title?: SortOrder;
      description?: SortOrder;
      details?: SortOrderInput | SortOrder;
      testStrategy?: SortOrderInput | SortOrder;
      status?: SortOrder;
      parentId?: SortOrder;
      dependencies?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      parentTask?: TaskOrderByWithRelationInput;
   };

   export type SubtaskWhereUniqueInput = Prisma.AtLeast<
      {
         id?: string;
         AND?: SubtaskWhereInput | SubtaskWhereInput[];
         OR?: SubtaskWhereInput[];
         NOT?: SubtaskWhereInput | SubtaskWhereInput[];
         title?: StringFilter<'Subtask'> | string;
         description?: StringFilter<'Subtask'> | string;
         details?: StringNullableFilter<'Subtask'> | string | null;
         testStrategy?: StringNullableFilter<'Subtask'> | string | null;
         status?: StringFilter<'Subtask'> | string;
         parentId?: IntFilter<'Subtask'> | number;
         dependencies?: StringFilter<'Subtask'> | string;
         createdAt?: DateTimeFilter<'Subtask'> | Date | string;
         updatedAt?: DateTimeFilter<'Subtask'> | Date | string;
         parentTask?: XOR<TaskScalarRelationFilter, TaskWhereInput>;
      },
      'id'
   >;

   export type SubtaskOrderByWithAggregationInput = {
      id?: SortOrder;
      title?: SortOrder;
      description?: SortOrder;
      details?: SortOrderInput | SortOrder;
      testStrategy?: SortOrderInput | SortOrder;
      status?: SortOrder;
      parentId?: SortOrder;
      dependencies?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      _count?: SubtaskCountOrderByAggregateInput;
      _avg?: SubtaskAvgOrderByAggregateInput;
      _max?: SubtaskMaxOrderByAggregateInput;
      _min?: SubtaskMinOrderByAggregateInput;
      _sum?: SubtaskSumOrderByAggregateInput;
   };

   export type SubtaskScalarWhereWithAggregatesInput = {
      AND?: SubtaskScalarWhereWithAggregatesInput | SubtaskScalarWhereWithAggregatesInput[];
      OR?: SubtaskScalarWhereWithAggregatesInput[];
      NOT?: SubtaskScalarWhereWithAggregatesInput | SubtaskScalarWhereWithAggregatesInput[];
      id?: StringWithAggregatesFilter<'Subtask'> | string;
      title?: StringWithAggregatesFilter<'Subtask'> | string;
      description?: StringWithAggregatesFilter<'Subtask'> | string;
      details?: StringNullableWithAggregatesFilter<'Subtask'> | string | null;
      testStrategy?: StringNullableWithAggregatesFilter<'Subtask'> | string | null;
      status?: StringWithAggregatesFilter<'Subtask'> | string;
      parentId?: IntWithAggregatesFilter<'Subtask'> | number;
      dependencies?: StringWithAggregatesFilter<'Subtask'> | string;
      createdAt?: DateTimeWithAggregatesFilter<'Subtask'> | Date | string;
      updatedAt?: DateTimeWithAggregatesFilter<'Subtask'> | Date | string;
   };

   export type TaskDependencyWhereInput = {
      AND?: TaskDependencyWhereInput | TaskDependencyWhereInput[];
      OR?: TaskDependencyWhereInput[];
      NOT?: TaskDependencyWhereInput | TaskDependencyWhereInput[];
      id?: IntFilter<'TaskDependency'> | number;
      taskId?: IntFilter<'TaskDependency'> | number;
      dependsOnId?: IntFilter<'TaskDependency'> | number;
      createdAt?: DateTimeFilter<'TaskDependency'> | Date | string;
      task?: XOR<TaskScalarRelationFilter, TaskWhereInput>;
      dependsOn?: XOR<TaskScalarRelationFilter, TaskWhereInput>;
   };

   export type TaskDependencyOrderByWithRelationInput = {
      id?: SortOrder;
      taskId?: SortOrder;
      dependsOnId?: SortOrder;
      createdAt?: SortOrder;
      task?: TaskOrderByWithRelationInput;
      dependsOn?: TaskOrderByWithRelationInput;
   };

   export type TaskDependencyWhereUniqueInput = Prisma.AtLeast<
      {
         id?: number;
         taskId_dependsOnId?: TaskDependencyTaskIdDependsOnIdCompoundUniqueInput;
         AND?: TaskDependencyWhereInput | TaskDependencyWhereInput[];
         OR?: TaskDependencyWhereInput[];
         NOT?: TaskDependencyWhereInput | TaskDependencyWhereInput[];
         taskId?: IntFilter<'TaskDependency'> | number;
         dependsOnId?: IntFilter<'TaskDependency'> | number;
         createdAt?: DateTimeFilter<'TaskDependency'> | Date | string;
         task?: XOR<TaskScalarRelationFilter, TaskWhereInput>;
         dependsOn?: XOR<TaskScalarRelationFilter, TaskWhereInput>;
      },
      'id' | 'taskId_dependsOnId'
   >;

   export type TaskDependencyOrderByWithAggregationInput = {
      id?: SortOrder;
      taskId?: SortOrder;
      dependsOnId?: SortOrder;
      createdAt?: SortOrder;
      _count?: TaskDependencyCountOrderByAggregateInput;
      _avg?: TaskDependencyAvgOrderByAggregateInput;
      _max?: TaskDependencyMaxOrderByAggregateInput;
      _min?: TaskDependencyMinOrderByAggregateInput;
      _sum?: TaskDependencySumOrderByAggregateInput;
   };

   export type TaskDependencyScalarWhereWithAggregatesInput = {
      AND?:
         | TaskDependencyScalarWhereWithAggregatesInput
         | TaskDependencyScalarWhereWithAggregatesInput[];
      OR?: TaskDependencyScalarWhereWithAggregatesInput[];
      NOT?:
         | TaskDependencyScalarWhereWithAggregatesInput
         | TaskDependencyScalarWhereWithAggregatesInput[];
      id?: IntWithAggregatesFilter<'TaskDependency'> | number;
      taskId?: IntWithAggregatesFilter<'TaskDependency'> | number;
      dependsOnId?: IntWithAggregatesFilter<'TaskDependency'> | number;
      createdAt?: DateTimeWithAggregatesFilter<'TaskDependency'> | Date | string;
   };

   export type TaskMasterMetadataWhereInput = {
      AND?: TaskMasterMetadataWhereInput | TaskMasterMetadataWhereInput[];
      OR?: TaskMasterMetadataWhereInput[];
      NOT?: TaskMasterMetadataWhereInput | TaskMasterMetadataWhereInput[];
      id?: IntFilter<'TaskMasterMetadata'> | number;
      created?: DateTimeFilter<'TaskMasterMetadata'> | Date | string;
      updated?: DateTimeFilter<'TaskMasterMetadata'> | Date | string;
      description?: StringFilter<'TaskMasterMetadata'> | string;
   };

   export type TaskMasterMetadataOrderByWithRelationInput = {
      id?: SortOrder;
      created?: SortOrder;
      updated?: SortOrder;
      description?: SortOrder;
   };

   export type TaskMasterMetadataWhereUniqueInput = Prisma.AtLeast<
      {
         id?: number;
         AND?: TaskMasterMetadataWhereInput | TaskMasterMetadataWhereInput[];
         OR?: TaskMasterMetadataWhereInput[];
         NOT?: TaskMasterMetadataWhereInput | TaskMasterMetadataWhereInput[];
         created?: DateTimeFilter<'TaskMasterMetadata'> | Date | string;
         updated?: DateTimeFilter<'TaskMasterMetadata'> | Date | string;
         description?: StringFilter<'TaskMasterMetadata'> | string;
      },
      'id'
   >;

   export type TaskMasterMetadataOrderByWithAggregationInput = {
      id?: SortOrder;
      created?: SortOrder;
      updated?: SortOrder;
      description?: SortOrder;
      _count?: TaskMasterMetadataCountOrderByAggregateInput;
      _avg?: TaskMasterMetadataAvgOrderByAggregateInput;
      _max?: TaskMasterMetadataMaxOrderByAggregateInput;
      _min?: TaskMasterMetadataMinOrderByAggregateInput;
      _sum?: TaskMasterMetadataSumOrderByAggregateInput;
   };

   export type TaskMasterMetadataScalarWhereWithAggregatesInput = {
      AND?:
         | TaskMasterMetadataScalarWhereWithAggregatesInput
         | TaskMasterMetadataScalarWhereWithAggregatesInput[];
      OR?: TaskMasterMetadataScalarWhereWithAggregatesInput[];
      NOT?:
         | TaskMasterMetadataScalarWhereWithAggregatesInput
         | TaskMasterMetadataScalarWhereWithAggregatesInput[];
      id?: IntWithAggregatesFilter<'TaskMasterMetadata'> | number;
      created?: DateTimeWithAggregatesFilter<'TaskMasterMetadata'> | Date | string;
      updated?: DateTimeWithAggregatesFilter<'TaskMasterMetadata'> | Date | string;
      description?: StringWithAggregatesFilter<'TaskMasterMetadata'> | string;
   };

   export type SyncOperationWhereInput = {
      AND?: SyncOperationWhereInput | SyncOperationWhereInput[];
      OR?: SyncOperationWhereInput[];
      NOT?: SyncOperationWhereInput | SyncOperationWhereInput[];
      id?: StringFilter<'SyncOperation'> | string;
      type?: StringFilter<'SyncOperation'> | string;
      status?: StringFilter<'SyncOperation'> | string;
      source?: StringFilter<'SyncOperation'> | string;
      timestamp?: DateTimeFilter<'SyncOperation'> | Date | string;
      completedAt?: DateTimeNullableFilter<'SyncOperation'> | Date | string | null;
      data?: StringFilter<'SyncOperation'> | string;
      rollbackData?: StringNullableFilter<'SyncOperation'> | string | null;
      metadata?: StringNullableFilter<'SyncOperation'> | string | null;
      retryCount?: IntFilter<'SyncOperation'> | number;
      maxRetries?: IntFilter<'SyncOperation'> | number;
      error?: StringNullableFilter<'SyncOperation'> | string | null;
      taskIds?: StringFilter<'SyncOperation'> | string;
   };

   export type SyncOperationOrderByWithRelationInput = {
      id?: SortOrder;
      type?: SortOrder;
      status?: SortOrder;
      source?: SortOrder;
      timestamp?: SortOrder;
      completedAt?: SortOrderInput | SortOrder;
      data?: SortOrder;
      rollbackData?: SortOrderInput | SortOrder;
      metadata?: SortOrderInput | SortOrder;
      retryCount?: SortOrder;
      maxRetries?: SortOrder;
      error?: SortOrderInput | SortOrder;
      taskIds?: SortOrder;
   };

   export type SyncOperationWhereUniqueInput = Prisma.AtLeast<
      {
         id?: string;
         AND?: SyncOperationWhereInput | SyncOperationWhereInput[];
         OR?: SyncOperationWhereInput[];
         NOT?: SyncOperationWhereInput | SyncOperationWhereInput[];
         type?: StringFilter<'SyncOperation'> | string;
         status?: StringFilter<'SyncOperation'> | string;
         source?: StringFilter<'SyncOperation'> | string;
         timestamp?: DateTimeFilter<'SyncOperation'> | Date | string;
         completedAt?: DateTimeNullableFilter<'SyncOperation'> | Date | string | null;
         data?: StringFilter<'SyncOperation'> | string;
         rollbackData?: StringNullableFilter<'SyncOperation'> | string | null;
         metadata?: StringNullableFilter<'SyncOperation'> | string | null;
         retryCount?: IntFilter<'SyncOperation'> | number;
         maxRetries?: IntFilter<'SyncOperation'> | number;
         error?: StringNullableFilter<'SyncOperation'> | string | null;
         taskIds?: StringFilter<'SyncOperation'> | string;
      },
      'id'
   >;

   export type SyncOperationOrderByWithAggregationInput = {
      id?: SortOrder;
      type?: SortOrder;
      status?: SortOrder;
      source?: SortOrder;
      timestamp?: SortOrder;
      completedAt?: SortOrderInput | SortOrder;
      data?: SortOrder;
      rollbackData?: SortOrderInput | SortOrder;
      metadata?: SortOrderInput | SortOrder;
      retryCount?: SortOrder;
      maxRetries?: SortOrder;
      error?: SortOrderInput | SortOrder;
      taskIds?: SortOrder;
      _count?: SyncOperationCountOrderByAggregateInput;
      _avg?: SyncOperationAvgOrderByAggregateInput;
      _max?: SyncOperationMaxOrderByAggregateInput;
      _min?: SyncOperationMinOrderByAggregateInput;
      _sum?: SyncOperationSumOrderByAggregateInput;
   };

   export type SyncOperationScalarWhereWithAggregatesInput = {
      AND?:
         | SyncOperationScalarWhereWithAggregatesInput
         | SyncOperationScalarWhereWithAggregatesInput[];
      OR?: SyncOperationScalarWhereWithAggregatesInput[];
      NOT?:
         | SyncOperationScalarWhereWithAggregatesInput
         | SyncOperationScalarWhereWithAggregatesInput[];
      id?: StringWithAggregatesFilter<'SyncOperation'> | string;
      type?: StringWithAggregatesFilter<'SyncOperation'> | string;
      status?: StringWithAggregatesFilter<'SyncOperation'> | string;
      source?: StringWithAggregatesFilter<'SyncOperation'> | string;
      timestamp?: DateTimeWithAggregatesFilter<'SyncOperation'> | Date | string;
      completedAt?: DateTimeNullableWithAggregatesFilter<'SyncOperation'> | Date | string | null;
      data?: StringWithAggregatesFilter<'SyncOperation'> | string;
      rollbackData?: StringNullableWithAggregatesFilter<'SyncOperation'> | string | null;
      metadata?: StringNullableWithAggregatesFilter<'SyncOperation'> | string | null;
      retryCount?: IntWithAggregatesFilter<'SyncOperation'> | number;
      maxRetries?: IntWithAggregatesFilter<'SyncOperation'> | number;
      error?: StringNullableWithAggregatesFilter<'SyncOperation'> | string | null;
      taskIds?: StringWithAggregatesFilter<'SyncOperation'> | string;
   };

   export type SyncConflictWhereInput = {
      AND?: SyncConflictWhereInput | SyncConflictWhereInput[];
      OR?: SyncConflictWhereInput[];
      NOT?: SyncConflictWhereInput | SyncConflictWhereInput[];
      id?: StringFilter<'SyncConflict'> | string;
      operationType?: StringFilter<'SyncConflict'> | string;
      taskId?: StringFilter<'SyncConflict'> | string;
      uiVersion?: StringFilter<'SyncConflict'> | string;
      cliVersion?: StringFilter<'SyncConflict'> | string;
      resolved?: BoolFilter<'SyncConflict'> | boolean;
      resolution?: StringNullableFilter<'SyncConflict'> | string | null;
      resolvedAt?: DateTimeNullableFilter<'SyncConflict'> | Date | string | null;
      resolvedBy?: StringNullableFilter<'SyncConflict'> | string | null;
      timestamp?: DateTimeFilter<'SyncConflict'> | Date | string;
   };

   export type SyncConflictOrderByWithRelationInput = {
      id?: SortOrder;
      operationType?: SortOrder;
      taskId?: SortOrder;
      uiVersion?: SortOrder;
      cliVersion?: SortOrder;
      resolved?: SortOrder;
      resolution?: SortOrderInput | SortOrder;
      resolvedAt?: SortOrderInput | SortOrder;
      resolvedBy?: SortOrderInput | SortOrder;
      timestamp?: SortOrder;
   };

   export type SyncConflictWhereUniqueInput = Prisma.AtLeast<
      {
         id?: string;
         AND?: SyncConflictWhereInput | SyncConflictWhereInput[];
         OR?: SyncConflictWhereInput[];
         NOT?: SyncConflictWhereInput | SyncConflictWhereInput[];
         operationType?: StringFilter<'SyncConflict'> | string;
         taskId?: StringFilter<'SyncConflict'> | string;
         uiVersion?: StringFilter<'SyncConflict'> | string;
         cliVersion?: StringFilter<'SyncConflict'> | string;
         resolved?: BoolFilter<'SyncConflict'> | boolean;
         resolution?: StringNullableFilter<'SyncConflict'> | string | null;
         resolvedAt?: DateTimeNullableFilter<'SyncConflict'> | Date | string | null;
         resolvedBy?: StringNullableFilter<'SyncConflict'> | string | null;
         timestamp?: DateTimeFilter<'SyncConflict'> | Date | string;
      },
      'id'
   >;

   export type SyncConflictOrderByWithAggregationInput = {
      id?: SortOrder;
      operationType?: SortOrder;
      taskId?: SortOrder;
      uiVersion?: SortOrder;
      cliVersion?: SortOrder;
      resolved?: SortOrder;
      resolution?: SortOrderInput | SortOrder;
      resolvedAt?: SortOrderInput | SortOrder;
      resolvedBy?: SortOrderInput | SortOrder;
      timestamp?: SortOrder;
      _count?: SyncConflictCountOrderByAggregateInput;
      _max?: SyncConflictMaxOrderByAggregateInput;
      _min?: SyncConflictMinOrderByAggregateInput;
   };

   export type SyncConflictScalarWhereWithAggregatesInput = {
      AND?:
         | SyncConflictScalarWhereWithAggregatesInput
         | SyncConflictScalarWhereWithAggregatesInput[];
      OR?: SyncConflictScalarWhereWithAggregatesInput[];
      NOT?:
         | SyncConflictScalarWhereWithAggregatesInput
         | SyncConflictScalarWhereWithAggregatesInput[];
      id?: StringWithAggregatesFilter<'SyncConflict'> | string;
      operationType?: StringWithAggregatesFilter<'SyncConflict'> | string;
      taskId?: StringWithAggregatesFilter<'SyncConflict'> | string;
      uiVersion?: StringWithAggregatesFilter<'SyncConflict'> | string;
      cliVersion?: StringWithAggregatesFilter<'SyncConflict'> | string;
      resolved?: BoolWithAggregatesFilter<'SyncConflict'> | boolean;
      resolution?: StringNullableWithAggregatesFilter<'SyncConflict'> | string | null;
      resolvedAt?: DateTimeNullableWithAggregatesFilter<'SyncConflict'> | Date | string | null;
      resolvedBy?: StringNullableWithAggregatesFilter<'SyncConflict'> | string | null;
      timestamp?: DateTimeWithAggregatesFilter<'SyncConflict'> | Date | string;
   };

   export type UserWhereInput = {
      AND?: UserWhereInput | UserWhereInput[];
      OR?: UserWhereInput[];
      NOT?: UserWhereInput | UserWhereInput[];
      id?: StringFilter<'User'> | string;
      name?: StringFilter<'User'> | string;
      email?: StringFilter<'User'> | string;
      avatarUrl?: StringNullableFilter<'User'> | string | null;
      status?: EnumUserStatusFilter<'User'> | $Enums.UserStatus;
      role?: EnumUserRoleFilter<'User'> | $Enums.UserRole;
      joinedDate?: DateTimeFilter<'User'> | Date | string;
      teamIds?: StringFilter<'User'> | string;
      createdAt?: DateTimeFilter<'User'> | Date | string;
      updatedAt?: DateTimeFilter<'User'> | Date | string;
      assignedIssues?: IssueListRelationFilter;
      teams?: TeamMemberListRelationFilter;
      ledProjects?: ProjectListRelationFilter;
   };

   export type UserOrderByWithRelationInput = {
      id?: SortOrder;
      name?: SortOrder;
      email?: SortOrder;
      avatarUrl?: SortOrderInput | SortOrder;
      status?: SortOrder;
      role?: SortOrder;
      joinedDate?: SortOrder;
      teamIds?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      assignedIssues?: IssueOrderByRelationAggregateInput;
      teams?: TeamMemberOrderByRelationAggregateInput;
      ledProjects?: ProjectOrderByRelationAggregateInput;
   };

   export type UserWhereUniqueInput = Prisma.AtLeast<
      {
         id?: string;
         email?: string;
         AND?: UserWhereInput | UserWhereInput[];
         OR?: UserWhereInput[];
         NOT?: UserWhereInput | UserWhereInput[];
         name?: StringFilter<'User'> | string;
         avatarUrl?: StringNullableFilter<'User'> | string | null;
         status?: EnumUserStatusFilter<'User'> | $Enums.UserStatus;
         role?: EnumUserRoleFilter<'User'> | $Enums.UserRole;
         joinedDate?: DateTimeFilter<'User'> | Date | string;
         teamIds?: StringFilter<'User'> | string;
         createdAt?: DateTimeFilter<'User'> | Date | string;
         updatedAt?: DateTimeFilter<'User'> | Date | string;
         assignedIssues?: IssueListRelationFilter;
         teams?: TeamMemberListRelationFilter;
         ledProjects?: ProjectListRelationFilter;
      },
      'id' | 'email'
   >;

   export type UserOrderByWithAggregationInput = {
      id?: SortOrder;
      name?: SortOrder;
      email?: SortOrder;
      avatarUrl?: SortOrderInput | SortOrder;
      status?: SortOrder;
      role?: SortOrder;
      joinedDate?: SortOrder;
      teamIds?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      _count?: UserCountOrderByAggregateInput;
      _max?: UserMaxOrderByAggregateInput;
      _min?: UserMinOrderByAggregateInput;
   };

   export type UserScalarWhereWithAggregatesInput = {
      AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
      OR?: UserScalarWhereWithAggregatesInput[];
      NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[];
      id?: StringWithAggregatesFilter<'User'> | string;
      name?: StringWithAggregatesFilter<'User'> | string;
      email?: StringWithAggregatesFilter<'User'> | string;
      avatarUrl?: StringNullableWithAggregatesFilter<'User'> | string | null;
      status?: EnumUserStatusWithAggregatesFilter<'User'> | $Enums.UserStatus;
      role?: EnumUserRoleWithAggregatesFilter<'User'> | $Enums.UserRole;
      joinedDate?: DateTimeWithAggregatesFilter<'User'> | Date | string;
      teamIds?: StringWithAggregatesFilter<'User'> | string;
      createdAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
      updatedAt?: DateTimeWithAggregatesFilter<'User'> | Date | string;
   };

   export type ProjectWhereInput = {
      AND?: ProjectWhereInput | ProjectWhereInput[];
      OR?: ProjectWhereInput[];
      NOT?: ProjectWhereInput | ProjectWhereInput[];
      id?: StringFilter<'Project'> | string;
      name?: StringFilter<'Project'> | string;
      description?: StringNullableFilter<'Project'> | string | null;
      color?: StringNullableFilter<'Project'> | string | null;
      identifier?: StringNullableFilter<'Project'> | string | null;
      icon?: StringNullableFilter<'Project'> | string | null;
      percentComplete?: IntFilter<'Project'> | number;
      startDate?: DateTimeNullableFilter<'Project'> | Date | string | null;
      health?: EnumProjectHealthFilter<'Project'> | $Enums.ProjectHealth;
      leadId?: StringNullableFilter<'Project'> | string | null;
      createdAt?: DateTimeFilter<'Project'> | Date | string;
      updatedAt?: DateTimeFilter<'Project'> | Date | string;
      issues?: IssueListRelationFilter;
      lead?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      teams?: TeamProjectListRelationFilter;
   };

   export type ProjectOrderByWithRelationInput = {
      id?: SortOrder;
      name?: SortOrder;
      description?: SortOrderInput | SortOrder;
      color?: SortOrderInput | SortOrder;
      identifier?: SortOrderInput | SortOrder;
      icon?: SortOrderInput | SortOrder;
      percentComplete?: SortOrder;
      startDate?: SortOrderInput | SortOrder;
      health?: SortOrder;
      leadId?: SortOrderInput | SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      issues?: IssueOrderByRelationAggregateInput;
      lead?: UserOrderByWithRelationInput;
      teams?: TeamProjectOrderByRelationAggregateInput;
   };

   export type ProjectWhereUniqueInput = Prisma.AtLeast<
      {
         id?: string;
         AND?: ProjectWhereInput | ProjectWhereInput[];
         OR?: ProjectWhereInput[];
         NOT?: ProjectWhereInput | ProjectWhereInput[];
         name?: StringFilter<'Project'> | string;
         description?: StringNullableFilter<'Project'> | string | null;
         color?: StringNullableFilter<'Project'> | string | null;
         identifier?: StringNullableFilter<'Project'> | string | null;
         icon?: StringNullableFilter<'Project'> | string | null;
         percentComplete?: IntFilter<'Project'> | number;
         startDate?: DateTimeNullableFilter<'Project'> | Date | string | null;
         health?: EnumProjectHealthFilter<'Project'> | $Enums.ProjectHealth;
         leadId?: StringNullableFilter<'Project'> | string | null;
         createdAt?: DateTimeFilter<'Project'> | Date | string;
         updatedAt?: DateTimeFilter<'Project'> | Date | string;
         issues?: IssueListRelationFilter;
         lead?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
         teams?: TeamProjectListRelationFilter;
      },
      'id'
   >;

   export type ProjectOrderByWithAggregationInput = {
      id?: SortOrder;
      name?: SortOrder;
      description?: SortOrderInput | SortOrder;
      color?: SortOrderInput | SortOrder;
      identifier?: SortOrderInput | SortOrder;
      icon?: SortOrderInput | SortOrder;
      percentComplete?: SortOrder;
      startDate?: SortOrderInput | SortOrder;
      health?: SortOrder;
      leadId?: SortOrderInput | SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      _count?: ProjectCountOrderByAggregateInput;
      _avg?: ProjectAvgOrderByAggregateInput;
      _max?: ProjectMaxOrderByAggregateInput;
      _min?: ProjectMinOrderByAggregateInput;
      _sum?: ProjectSumOrderByAggregateInput;
   };

   export type ProjectScalarWhereWithAggregatesInput = {
      AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[];
      OR?: ProjectScalarWhereWithAggregatesInput[];
      NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[];
      id?: StringWithAggregatesFilter<'Project'> | string;
      name?: StringWithAggregatesFilter<'Project'> | string;
      description?: StringNullableWithAggregatesFilter<'Project'> | string | null;
      color?: StringNullableWithAggregatesFilter<'Project'> | string | null;
      identifier?: StringNullableWithAggregatesFilter<'Project'> | string | null;
      icon?: StringNullableWithAggregatesFilter<'Project'> | string | null;
      percentComplete?: IntWithAggregatesFilter<'Project'> | number;
      startDate?: DateTimeNullableWithAggregatesFilter<'Project'> | Date | string | null;
      health?: EnumProjectHealthWithAggregatesFilter<'Project'> | $Enums.ProjectHealth;
      leadId?: StringNullableWithAggregatesFilter<'Project'> | string | null;
      createdAt?: DateTimeWithAggregatesFilter<'Project'> | Date | string;
      updatedAt?: DateTimeWithAggregatesFilter<'Project'> | Date | string;
   };

   export type LabelWhereInput = {
      AND?: LabelWhereInput | LabelWhereInput[];
      OR?: LabelWhereInput[];
      NOT?: LabelWhereInput | LabelWhereInput[];
      id?: StringFilter<'Label'> | string;
      name?: StringFilter<'Label'> | string;
      color?: StringFilter<'Label'> | string;
      description?: StringNullableFilter<'Label'> | string | null;
      createdAt?: DateTimeFilter<'Label'> | Date | string;
      updatedAt?: DateTimeFilter<'Label'> | Date | string;
      issues?: IssueLabelListRelationFilter;
   };

   export type LabelOrderByWithRelationInput = {
      id?: SortOrder;
      name?: SortOrder;
      color?: SortOrder;
      description?: SortOrderInput | SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      issues?: IssueLabelOrderByRelationAggregateInput;
   };

   export type LabelWhereUniqueInput = Prisma.AtLeast<
      {
         id?: string;
         AND?: LabelWhereInput | LabelWhereInput[];
         OR?: LabelWhereInput[];
         NOT?: LabelWhereInput | LabelWhereInput[];
         name?: StringFilter<'Label'> | string;
         color?: StringFilter<'Label'> | string;
         description?: StringNullableFilter<'Label'> | string | null;
         createdAt?: DateTimeFilter<'Label'> | Date | string;
         updatedAt?: DateTimeFilter<'Label'> | Date | string;
         issues?: IssueLabelListRelationFilter;
      },
      'id'
   >;

   export type LabelOrderByWithAggregationInput = {
      id?: SortOrder;
      name?: SortOrder;
      color?: SortOrder;
      description?: SortOrderInput | SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      _count?: LabelCountOrderByAggregateInput;
      _max?: LabelMaxOrderByAggregateInput;
      _min?: LabelMinOrderByAggregateInput;
   };

   export type LabelScalarWhereWithAggregatesInput = {
      AND?: LabelScalarWhereWithAggregatesInput | LabelScalarWhereWithAggregatesInput[];
      OR?: LabelScalarWhereWithAggregatesInput[];
      NOT?: LabelScalarWhereWithAggregatesInput | LabelScalarWhereWithAggregatesInput[];
      id?: StringWithAggregatesFilter<'Label'> | string;
      name?: StringWithAggregatesFilter<'Label'> | string;
      color?: StringWithAggregatesFilter<'Label'> | string;
      description?: StringNullableWithAggregatesFilter<'Label'> | string | null;
      createdAt?: DateTimeWithAggregatesFilter<'Label'> | Date | string;
      updatedAt?: DateTimeWithAggregatesFilter<'Label'> | Date | string;
   };

   export type IssueStatusWhereInput = {
      AND?: IssueStatusWhereInput | IssueStatusWhereInput[];
      OR?: IssueStatusWhereInput[];
      NOT?: IssueStatusWhereInput | IssueStatusWhereInput[];
      id?: StringFilter<'IssueStatus'> | string;
      name?: StringFilter<'IssueStatus'> | string;
      color?: StringFilter<'IssueStatus'> | string;
      iconName?: StringFilter<'IssueStatus'> | string;
      createdAt?: DateTimeFilter<'IssueStatus'> | Date | string;
      updatedAt?: DateTimeFilter<'IssueStatus'> | Date | string;
      issues?: IssueListRelationFilter;
   };

   export type IssueStatusOrderByWithRelationInput = {
      id?: SortOrder;
      name?: SortOrder;
      color?: SortOrder;
      iconName?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      issues?: IssueOrderByRelationAggregateInput;
   };

   export type IssueStatusWhereUniqueInput = Prisma.AtLeast<
      {
         id?: string;
         AND?: IssueStatusWhereInput | IssueStatusWhereInput[];
         OR?: IssueStatusWhereInput[];
         NOT?: IssueStatusWhereInput | IssueStatusWhereInput[];
         name?: StringFilter<'IssueStatus'> | string;
         color?: StringFilter<'IssueStatus'> | string;
         iconName?: StringFilter<'IssueStatus'> | string;
         createdAt?: DateTimeFilter<'IssueStatus'> | Date | string;
         updatedAt?: DateTimeFilter<'IssueStatus'> | Date | string;
         issues?: IssueListRelationFilter;
      },
      'id'
   >;

   export type IssueStatusOrderByWithAggregationInput = {
      id?: SortOrder;
      name?: SortOrder;
      color?: SortOrder;
      iconName?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      _count?: IssueStatusCountOrderByAggregateInput;
      _max?: IssueStatusMaxOrderByAggregateInput;
      _min?: IssueStatusMinOrderByAggregateInput;
   };

   export type IssueStatusScalarWhereWithAggregatesInput = {
      AND?: IssueStatusScalarWhereWithAggregatesInput | IssueStatusScalarWhereWithAggregatesInput[];
      OR?: IssueStatusScalarWhereWithAggregatesInput[];
      NOT?: IssueStatusScalarWhereWithAggregatesInput | IssueStatusScalarWhereWithAggregatesInput[];
      id?: StringWithAggregatesFilter<'IssueStatus'> | string;
      name?: StringWithAggregatesFilter<'IssueStatus'> | string;
      color?: StringWithAggregatesFilter<'IssueStatus'> | string;
      iconName?: StringWithAggregatesFilter<'IssueStatus'> | string;
      createdAt?: DateTimeWithAggregatesFilter<'IssueStatus'> | Date | string;
      updatedAt?: DateTimeWithAggregatesFilter<'IssueStatus'> | Date | string;
   };

   export type IssuePriorityWhereInput = {
      AND?: IssuePriorityWhereInput | IssuePriorityWhereInput[];
      OR?: IssuePriorityWhereInput[];
      NOT?: IssuePriorityWhereInput | IssuePriorityWhereInput[];
      id?: StringFilter<'IssuePriority'> | string;
      name?: StringFilter<'IssuePriority'> | string;
      iconName?: StringFilter<'IssuePriority'> | string;
      order?: IntFilter<'IssuePriority'> | number;
      createdAt?: DateTimeFilter<'IssuePriority'> | Date | string;
      updatedAt?: DateTimeFilter<'IssuePriority'> | Date | string;
      issues?: IssueListRelationFilter;
   };

   export type IssuePriorityOrderByWithRelationInput = {
      id?: SortOrder;
      name?: SortOrder;
      iconName?: SortOrder;
      order?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      issues?: IssueOrderByRelationAggregateInput;
   };

   export type IssuePriorityWhereUniqueInput = Prisma.AtLeast<
      {
         id?: string;
         AND?: IssuePriorityWhereInput | IssuePriorityWhereInput[];
         OR?: IssuePriorityWhereInput[];
         NOT?: IssuePriorityWhereInput | IssuePriorityWhereInput[];
         name?: StringFilter<'IssuePriority'> | string;
         iconName?: StringFilter<'IssuePriority'> | string;
         order?: IntFilter<'IssuePriority'> | number;
         createdAt?: DateTimeFilter<'IssuePriority'> | Date | string;
         updatedAt?: DateTimeFilter<'IssuePriority'> | Date | string;
         issues?: IssueListRelationFilter;
      },
      'id'
   >;

   export type IssuePriorityOrderByWithAggregationInput = {
      id?: SortOrder;
      name?: SortOrder;
      iconName?: SortOrder;
      order?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      _count?: IssuePriorityCountOrderByAggregateInput;
      _avg?: IssuePriorityAvgOrderByAggregateInput;
      _max?: IssuePriorityMaxOrderByAggregateInput;
      _min?: IssuePriorityMinOrderByAggregateInput;
      _sum?: IssuePrioritySumOrderByAggregateInput;
   };

   export type IssuePriorityScalarWhereWithAggregatesInput = {
      AND?:
         | IssuePriorityScalarWhereWithAggregatesInput
         | IssuePriorityScalarWhereWithAggregatesInput[];
      OR?: IssuePriorityScalarWhereWithAggregatesInput[];
      NOT?:
         | IssuePriorityScalarWhereWithAggregatesInput
         | IssuePriorityScalarWhereWithAggregatesInput[];
      id?: StringWithAggregatesFilter<'IssuePriority'> | string;
      name?: StringWithAggregatesFilter<'IssuePriority'> | string;
      iconName?: StringWithAggregatesFilter<'IssuePriority'> | string;
      order?: IntWithAggregatesFilter<'IssuePriority'> | number;
      createdAt?: DateTimeWithAggregatesFilter<'IssuePriority'> | Date | string;
      updatedAt?: DateTimeWithAggregatesFilter<'IssuePriority'> | Date | string;
   };

   export type IssueWhereInput = {
      AND?: IssueWhereInput | IssueWhereInput[];
      OR?: IssueWhereInput[];
      NOT?: IssueWhereInput | IssueWhereInput[];
      id?: StringFilter<'Issue'> | string;
      identifier?: StringFilter<'Issue'> | string;
      title?: StringFilter<'Issue'> | string;
      description?: StringFilter<'Issue'> | string;
      statusId?: StringNullableFilter<'Issue'> | string | null;
      priorityId?: StringNullableFilter<'Issue'> | string | null;
      status?: StringNullableFilter<'Issue'> | string | null;
      priority?: StringNullableFilter<'Issue'> | string | null;
      rank?: StringFilter<'Issue'> | string;
      cycleId?: StringNullableFilter<'Issue'> | string | null;
      dueDate?: DateTimeNullableFilter<'Issue'> | Date | string | null;
      taskId?: IntNullableFilter<'Issue'> | number | null;
      subtaskId?: StringNullableFilter<'Issue'> | string | null;
      issueType?: EnumIssueTypeFilter<'Issue'> | $Enums.IssueType;
      assigneeId?: StringNullableFilter<'Issue'> | string | null;
      projectId?: StringNullableFilter<'Issue'> | string | null;
      subissues?: StringFilter<'Issue'> | string;
      createdAt?: DateTimeFilter<'Issue'> | Date | string;
      updatedAt?: DateTimeFilter<'Issue'> | Date | string;
      assignee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
      project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null;
      cycle?: XOR<CycleNullableScalarRelationFilter, CycleWhereInput> | null;
      task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null;
      issueStatus?: XOR<IssueStatusNullableScalarRelationFilter, IssueStatusWhereInput> | null;
      issuePriority?: XOR<
         IssuePriorityNullableScalarRelationFilter,
         IssuePriorityWhereInput
      > | null;
      labels?: IssueLabelListRelationFilter;
   };

   export type IssueOrderByWithRelationInput = {
      id?: SortOrder;
      identifier?: SortOrder;
      title?: SortOrder;
      description?: SortOrder;
      statusId?: SortOrderInput | SortOrder;
      priorityId?: SortOrderInput | SortOrder;
      status?: SortOrderInput | SortOrder;
      priority?: SortOrderInput | SortOrder;
      rank?: SortOrder;
      cycleId?: SortOrderInput | SortOrder;
      dueDate?: SortOrderInput | SortOrder;
      taskId?: SortOrderInput | SortOrder;
      subtaskId?: SortOrderInput | SortOrder;
      issueType?: SortOrder;
      assigneeId?: SortOrderInput | SortOrder;
      projectId?: SortOrderInput | SortOrder;
      subissues?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      assignee?: UserOrderByWithRelationInput;
      project?: ProjectOrderByWithRelationInput;
      cycle?: CycleOrderByWithRelationInput;
      task?: TaskOrderByWithRelationInput;
      issueStatus?: IssueStatusOrderByWithRelationInput;
      issuePriority?: IssuePriorityOrderByWithRelationInput;
      labels?: IssueLabelOrderByRelationAggregateInput;
   };

   export type IssueWhereUniqueInput = Prisma.AtLeast<
      {
         id?: string;
         identifier?: string;
         AND?: IssueWhereInput | IssueWhereInput[];
         OR?: IssueWhereInput[];
         NOT?: IssueWhereInput | IssueWhereInput[];
         title?: StringFilter<'Issue'> | string;
         description?: StringFilter<'Issue'> | string;
         statusId?: StringNullableFilter<'Issue'> | string | null;
         priorityId?: StringNullableFilter<'Issue'> | string | null;
         status?: StringNullableFilter<'Issue'> | string | null;
         priority?: StringNullableFilter<'Issue'> | string | null;
         rank?: StringFilter<'Issue'> | string;
         cycleId?: StringNullableFilter<'Issue'> | string | null;
         dueDate?: DateTimeNullableFilter<'Issue'> | Date | string | null;
         taskId?: IntNullableFilter<'Issue'> | number | null;
         subtaskId?: StringNullableFilter<'Issue'> | string | null;
         issueType?: EnumIssueTypeFilter<'Issue'> | $Enums.IssueType;
         assigneeId?: StringNullableFilter<'Issue'> | string | null;
         projectId?: StringNullableFilter<'Issue'> | string | null;
         subissues?: StringFilter<'Issue'> | string;
         createdAt?: DateTimeFilter<'Issue'> | Date | string;
         updatedAt?: DateTimeFilter<'Issue'> | Date | string;
         assignee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null;
         project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null;
         cycle?: XOR<CycleNullableScalarRelationFilter, CycleWhereInput> | null;
         task?: XOR<TaskNullableScalarRelationFilter, TaskWhereInput> | null;
         issueStatus?: XOR<IssueStatusNullableScalarRelationFilter, IssueStatusWhereInput> | null;
         issuePriority?: XOR<
            IssuePriorityNullableScalarRelationFilter,
            IssuePriorityWhereInput
         > | null;
         labels?: IssueLabelListRelationFilter;
      },
      'id' | 'identifier'
   >;

   export type IssueOrderByWithAggregationInput = {
      id?: SortOrder;
      identifier?: SortOrder;
      title?: SortOrder;
      description?: SortOrder;
      statusId?: SortOrderInput | SortOrder;
      priorityId?: SortOrderInput | SortOrder;
      status?: SortOrderInput | SortOrder;
      priority?: SortOrderInput | SortOrder;
      rank?: SortOrder;
      cycleId?: SortOrderInput | SortOrder;
      dueDate?: SortOrderInput | SortOrder;
      taskId?: SortOrderInput | SortOrder;
      subtaskId?: SortOrderInput | SortOrder;
      issueType?: SortOrder;
      assigneeId?: SortOrderInput | SortOrder;
      projectId?: SortOrderInput | SortOrder;
      subissues?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      _count?: IssueCountOrderByAggregateInput;
      _avg?: IssueAvgOrderByAggregateInput;
      _max?: IssueMaxOrderByAggregateInput;
      _min?: IssueMinOrderByAggregateInput;
      _sum?: IssueSumOrderByAggregateInput;
   };

   export type IssueScalarWhereWithAggregatesInput = {
      AND?: IssueScalarWhereWithAggregatesInput | IssueScalarWhereWithAggregatesInput[];
      OR?: IssueScalarWhereWithAggregatesInput[];
      NOT?: IssueScalarWhereWithAggregatesInput | IssueScalarWhereWithAggregatesInput[];
      id?: StringWithAggregatesFilter<'Issue'> | string;
      identifier?: StringWithAggregatesFilter<'Issue'> | string;
      title?: StringWithAggregatesFilter<'Issue'> | string;
      description?: StringWithAggregatesFilter<'Issue'> | string;
      statusId?: StringNullableWithAggregatesFilter<'Issue'> | string | null;
      priorityId?: StringNullableWithAggregatesFilter<'Issue'> | string | null;
      status?: StringNullableWithAggregatesFilter<'Issue'> | string | null;
      priority?: StringNullableWithAggregatesFilter<'Issue'> | string | null;
      rank?: StringWithAggregatesFilter<'Issue'> | string;
      cycleId?: StringNullableWithAggregatesFilter<'Issue'> | string | null;
      dueDate?: DateTimeNullableWithAggregatesFilter<'Issue'> | Date | string | null;
      taskId?: IntNullableWithAggregatesFilter<'Issue'> | number | null;
      subtaskId?: StringNullableWithAggregatesFilter<'Issue'> | string | null;
      issueType?: EnumIssueTypeWithAggregatesFilter<'Issue'> | $Enums.IssueType;
      assigneeId?: StringNullableWithAggregatesFilter<'Issue'> | string | null;
      projectId?: StringNullableWithAggregatesFilter<'Issue'> | string | null;
      subissues?: StringWithAggregatesFilter<'Issue'> | string;
      createdAt?: DateTimeWithAggregatesFilter<'Issue'> | Date | string;
      updatedAt?: DateTimeWithAggregatesFilter<'Issue'> | Date | string;
   };

   export type IssueLabelWhereInput = {
      AND?: IssueLabelWhereInput | IssueLabelWhereInput[];
      OR?: IssueLabelWhereInput[];
      NOT?: IssueLabelWhereInput | IssueLabelWhereInput[];
      id?: StringFilter<'IssueLabel'> | string;
      issueId?: StringFilter<'IssueLabel'> | string;
      labelId?: StringFilter<'IssueLabel'> | string;
      issue?: XOR<IssueScalarRelationFilter, IssueWhereInput>;
      label?: XOR<LabelScalarRelationFilter, LabelWhereInput>;
   };

   export type IssueLabelOrderByWithRelationInput = {
      id?: SortOrder;
      issueId?: SortOrder;
      labelId?: SortOrder;
      issue?: IssueOrderByWithRelationInput;
      label?: LabelOrderByWithRelationInput;
   };

   export type IssueLabelWhereUniqueInput = Prisma.AtLeast<
      {
         id?: string;
         issueId_labelId?: IssueLabelIssueIdLabelIdCompoundUniqueInput;
         AND?: IssueLabelWhereInput | IssueLabelWhereInput[];
         OR?: IssueLabelWhereInput[];
         NOT?: IssueLabelWhereInput | IssueLabelWhereInput[];
         issueId?: StringFilter<'IssueLabel'> | string;
         labelId?: StringFilter<'IssueLabel'> | string;
         issue?: XOR<IssueScalarRelationFilter, IssueWhereInput>;
         label?: XOR<LabelScalarRelationFilter, LabelWhereInput>;
      },
      'id' | 'issueId_labelId'
   >;

   export type IssueLabelOrderByWithAggregationInput = {
      id?: SortOrder;
      issueId?: SortOrder;
      labelId?: SortOrder;
      _count?: IssueLabelCountOrderByAggregateInput;
      _max?: IssueLabelMaxOrderByAggregateInput;
      _min?: IssueLabelMinOrderByAggregateInput;
   };

   export type IssueLabelScalarWhereWithAggregatesInput = {
      AND?: IssueLabelScalarWhereWithAggregatesInput | IssueLabelScalarWhereWithAggregatesInput[];
      OR?: IssueLabelScalarWhereWithAggregatesInput[];
      NOT?: IssueLabelScalarWhereWithAggregatesInput | IssueLabelScalarWhereWithAggregatesInput[];
      id?: StringWithAggregatesFilter<'IssueLabel'> | string;
      issueId?: StringWithAggregatesFilter<'IssueLabel'> | string;
      labelId?: StringWithAggregatesFilter<'IssueLabel'> | string;
   };

   export type CycleWhereInput = {
      AND?: CycleWhereInput | CycleWhereInput[];
      OR?: CycleWhereInput[];
      NOT?: CycleWhereInput | CycleWhereInput[];
      id?: StringFilter<'Cycle'> | string;
      number?: IntFilter<'Cycle'> | number;
      name?: StringFilter<'Cycle'> | string;
      teamId?: StringFilter<'Cycle'> | string;
      startDate?: DateTimeFilter<'Cycle'> | Date | string;
      endDate?: DateTimeFilter<'Cycle'> | Date | string;
      progress?: IntFilter<'Cycle'> | number;
      createdAt?: DateTimeFilter<'Cycle'> | Date | string;
      updatedAt?: DateTimeFilter<'Cycle'> | Date | string;
      team?: XOR<TeamScalarRelationFilter, TeamWhereInput>;
      issues?: IssueListRelationFilter;
   };

   export type CycleOrderByWithRelationInput = {
      id?: SortOrder;
      number?: SortOrder;
      name?: SortOrder;
      teamId?: SortOrder;
      startDate?: SortOrder;
      endDate?: SortOrder;
      progress?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      team?: TeamOrderByWithRelationInput;
      issues?: IssueOrderByRelationAggregateInput;
   };

   export type CycleWhereUniqueInput = Prisma.AtLeast<
      {
         id?: string;
         AND?: CycleWhereInput | CycleWhereInput[];
         OR?: CycleWhereInput[];
         NOT?: CycleWhereInput | CycleWhereInput[];
         number?: IntFilter<'Cycle'> | number;
         name?: StringFilter<'Cycle'> | string;
         teamId?: StringFilter<'Cycle'> | string;
         startDate?: DateTimeFilter<'Cycle'> | Date | string;
         endDate?: DateTimeFilter<'Cycle'> | Date | string;
         progress?: IntFilter<'Cycle'> | number;
         createdAt?: DateTimeFilter<'Cycle'> | Date | string;
         updatedAt?: DateTimeFilter<'Cycle'> | Date | string;
         team?: XOR<TeamScalarRelationFilter, TeamWhereInput>;
         issues?: IssueListRelationFilter;
      },
      'id'
   >;

   export type CycleOrderByWithAggregationInput = {
      id?: SortOrder;
      number?: SortOrder;
      name?: SortOrder;
      teamId?: SortOrder;
      startDate?: SortOrder;
      endDate?: SortOrder;
      progress?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      _count?: CycleCountOrderByAggregateInput;
      _avg?: CycleAvgOrderByAggregateInput;
      _max?: CycleMaxOrderByAggregateInput;
      _min?: CycleMinOrderByAggregateInput;
      _sum?: CycleSumOrderByAggregateInput;
   };

   export type CycleScalarWhereWithAggregatesInput = {
      AND?: CycleScalarWhereWithAggregatesInput | CycleScalarWhereWithAggregatesInput[];
      OR?: CycleScalarWhereWithAggregatesInput[];
      NOT?: CycleScalarWhereWithAggregatesInput | CycleScalarWhereWithAggregatesInput[];
      id?: StringWithAggregatesFilter<'Cycle'> | string;
      number?: IntWithAggregatesFilter<'Cycle'> | number;
      name?: StringWithAggregatesFilter<'Cycle'> | string;
      teamId?: StringWithAggregatesFilter<'Cycle'> | string;
      startDate?: DateTimeWithAggregatesFilter<'Cycle'> | Date | string;
      endDate?: DateTimeWithAggregatesFilter<'Cycle'> | Date | string;
      progress?: IntWithAggregatesFilter<'Cycle'> | number;
      createdAt?: DateTimeWithAggregatesFilter<'Cycle'> | Date | string;
      updatedAt?: DateTimeWithAggregatesFilter<'Cycle'> | Date | string;
   };

   export type TeamWhereInput = {
      AND?: TeamWhereInput | TeamWhereInput[];
      OR?: TeamWhereInput[];
      NOT?: TeamWhereInput | TeamWhereInput[];
      id?: StringFilter<'Team'> | string;
      name?: StringFilter<'Team'> | string;
      icon?: StringFilter<'Team'> | string;
      joined?: BoolFilter<'Team'> | boolean;
      color?: StringFilter<'Team'> | string;
      createdAt?: DateTimeFilter<'Team'> | Date | string;
      updatedAt?: DateTimeFilter<'Team'> | Date | string;
      members?: TeamMemberListRelationFilter;
      projects?: TeamProjectListRelationFilter;
      cycles?: CycleListRelationFilter;
   };

   export type TeamOrderByWithRelationInput = {
      id?: SortOrder;
      name?: SortOrder;
      icon?: SortOrder;
      joined?: SortOrder;
      color?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      members?: TeamMemberOrderByRelationAggregateInput;
      projects?: TeamProjectOrderByRelationAggregateInput;
      cycles?: CycleOrderByRelationAggregateInput;
   };

   export type TeamWhereUniqueInput = Prisma.AtLeast<
      {
         id?: string;
         AND?: TeamWhereInput | TeamWhereInput[];
         OR?: TeamWhereInput[];
         NOT?: TeamWhereInput | TeamWhereInput[];
         name?: StringFilter<'Team'> | string;
         icon?: StringFilter<'Team'> | string;
         joined?: BoolFilter<'Team'> | boolean;
         color?: StringFilter<'Team'> | string;
         createdAt?: DateTimeFilter<'Team'> | Date | string;
         updatedAt?: DateTimeFilter<'Team'> | Date | string;
         members?: TeamMemberListRelationFilter;
         projects?: TeamProjectListRelationFilter;
         cycles?: CycleListRelationFilter;
      },
      'id'
   >;

   export type TeamOrderByWithAggregationInput = {
      id?: SortOrder;
      name?: SortOrder;
      icon?: SortOrder;
      joined?: SortOrder;
      color?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
      _count?: TeamCountOrderByAggregateInput;
      _max?: TeamMaxOrderByAggregateInput;
      _min?: TeamMinOrderByAggregateInput;
   };

   export type TeamScalarWhereWithAggregatesInput = {
      AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[];
      OR?: TeamScalarWhereWithAggregatesInput[];
      NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[];
      id?: StringWithAggregatesFilter<'Team'> | string;
      name?: StringWithAggregatesFilter<'Team'> | string;
      icon?: StringWithAggregatesFilter<'Team'> | string;
      joined?: BoolWithAggregatesFilter<'Team'> | boolean;
      color?: StringWithAggregatesFilter<'Team'> | string;
      createdAt?: DateTimeWithAggregatesFilter<'Team'> | Date | string;
      updatedAt?: DateTimeWithAggregatesFilter<'Team'> | Date | string;
   };

   export type TeamMemberWhereInput = {
      AND?: TeamMemberWhereInput | TeamMemberWhereInput[];
      OR?: TeamMemberWhereInput[];
      NOT?: TeamMemberWhereInput | TeamMemberWhereInput[];
      id?: StringFilter<'TeamMember'> | string;
      teamId?: StringFilter<'TeamMember'> | string;
      userId?: StringFilter<'TeamMember'> | string;
      team?: XOR<TeamScalarRelationFilter, TeamWhereInput>;
      user?: XOR<UserScalarRelationFilter, UserWhereInput>;
   };

   export type TeamMemberOrderByWithRelationInput = {
      id?: SortOrder;
      teamId?: SortOrder;
      userId?: SortOrder;
      team?: TeamOrderByWithRelationInput;
      user?: UserOrderByWithRelationInput;
   };

   export type TeamMemberWhereUniqueInput = Prisma.AtLeast<
      {
         id?: string;
         teamId_userId?: TeamMemberTeamIdUserIdCompoundUniqueInput;
         AND?: TeamMemberWhereInput | TeamMemberWhereInput[];
         OR?: TeamMemberWhereInput[];
         NOT?: TeamMemberWhereInput | TeamMemberWhereInput[];
         teamId?: StringFilter<'TeamMember'> | string;
         userId?: StringFilter<'TeamMember'> | string;
         team?: XOR<TeamScalarRelationFilter, TeamWhereInput>;
         user?: XOR<UserScalarRelationFilter, UserWhereInput>;
      },
      'id' | 'teamId_userId'
   >;

   export type TeamMemberOrderByWithAggregationInput = {
      id?: SortOrder;
      teamId?: SortOrder;
      userId?: SortOrder;
      _count?: TeamMemberCountOrderByAggregateInput;
      _max?: TeamMemberMaxOrderByAggregateInput;
      _min?: TeamMemberMinOrderByAggregateInput;
   };

   export type TeamMemberScalarWhereWithAggregatesInput = {
      AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[];
      OR?: TeamMemberScalarWhereWithAggregatesInput[];
      NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[];
      id?: StringWithAggregatesFilter<'TeamMember'> | string;
      teamId?: StringWithAggregatesFilter<'TeamMember'> | string;
      userId?: StringWithAggregatesFilter<'TeamMember'> | string;
   };

   export type TeamProjectWhereInput = {
      AND?: TeamProjectWhereInput | TeamProjectWhereInput[];
      OR?: TeamProjectWhereInput[];
      NOT?: TeamProjectWhereInput | TeamProjectWhereInput[];
      id?: StringFilter<'TeamProject'> | string;
      teamId?: StringFilter<'TeamProject'> | string;
      projectId?: StringFilter<'TeamProject'> | string;
      team?: XOR<TeamScalarRelationFilter, TeamWhereInput>;
      project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>;
   };

   export type TeamProjectOrderByWithRelationInput = {
      id?: SortOrder;
      teamId?: SortOrder;
      projectId?: SortOrder;
      team?: TeamOrderByWithRelationInput;
      project?: ProjectOrderByWithRelationInput;
   };

   export type TeamProjectWhereUniqueInput = Prisma.AtLeast<
      {
         id?: string;
         teamId_projectId?: TeamProjectTeamIdProjectIdCompoundUniqueInput;
         AND?: TeamProjectWhereInput | TeamProjectWhereInput[];
         OR?: TeamProjectWhereInput[];
         NOT?: TeamProjectWhereInput | TeamProjectWhereInput[];
         teamId?: StringFilter<'TeamProject'> | string;
         projectId?: StringFilter<'TeamProject'> | string;
         team?: XOR<TeamScalarRelationFilter, TeamWhereInput>;
         project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>;
      },
      'id' | 'teamId_projectId'
   >;

   export type TeamProjectOrderByWithAggregationInput = {
      id?: SortOrder;
      teamId?: SortOrder;
      projectId?: SortOrder;
      _count?: TeamProjectCountOrderByAggregateInput;
      _max?: TeamProjectMaxOrderByAggregateInput;
      _min?: TeamProjectMinOrderByAggregateInput;
   };

   export type TeamProjectScalarWhereWithAggregatesInput = {
      AND?: TeamProjectScalarWhereWithAggregatesInput | TeamProjectScalarWhereWithAggregatesInput[];
      OR?: TeamProjectScalarWhereWithAggregatesInput[];
      NOT?: TeamProjectScalarWhereWithAggregatesInput | TeamProjectScalarWhereWithAggregatesInput[];
      id?: StringWithAggregatesFilter<'TeamProject'> | string;
      teamId?: StringWithAggregatesFilter<'TeamProject'> | string;
      projectId?: StringWithAggregatesFilter<'TeamProject'> | string;
   };

   export type TaskCreateInput = {
      id: number;
      title: string;
      description: string;
      details?: string | null;
      testStrategy?: string | null;
      priority: string;
      status: string;
      complexity?: number | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      subtasks?: SubtaskCreateNestedManyWithoutParentTaskInput;
      dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput;
      dependents?: TaskDependencyCreateNestedManyWithoutDependsOnInput;
      issues?: IssueCreateNestedManyWithoutTaskInput;
   };

   export type TaskUncheckedCreateInput = {
      id: number;
      title: string;
      description: string;
      details?: string | null;
      testStrategy?: string | null;
      priority: string;
      status: string;
      complexity?: number | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      subtasks?: SubtaskUncheckedCreateNestedManyWithoutParentTaskInput;
      dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput;
      dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDependsOnInput;
      issues?: IssueUncheckedCreateNestedManyWithoutTaskInput;
   };

   export type TaskUpdateInput = {
      id?: IntFieldUpdateOperationsInput | number;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: StringFieldUpdateOperationsInput | string;
      status?: StringFieldUpdateOperationsInput | string;
      complexity?: NullableIntFieldUpdateOperationsInput | number | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      subtasks?: SubtaskUpdateManyWithoutParentTaskNestedInput;
      dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput;
      dependents?: TaskDependencyUpdateManyWithoutDependsOnNestedInput;
      issues?: IssueUpdateManyWithoutTaskNestedInput;
   };

   export type TaskUncheckedUpdateInput = {
      id?: IntFieldUpdateOperationsInput | number;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: StringFieldUpdateOperationsInput | string;
      status?: StringFieldUpdateOperationsInput | string;
      complexity?: NullableIntFieldUpdateOperationsInput | number | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      subtasks?: SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput;
      dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput;
      dependents?: TaskDependencyUncheckedUpdateManyWithoutDependsOnNestedInput;
      issues?: IssueUncheckedUpdateManyWithoutTaskNestedInput;
   };

   export type TaskCreateManyInput = {
      id: number;
      title: string;
      description: string;
      details?: string | null;
      testStrategy?: string | null;
      priority: string;
      status: string;
      complexity?: number | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type TaskUpdateManyMutationInput = {
      id?: IntFieldUpdateOperationsInput | number;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: StringFieldUpdateOperationsInput | string;
      status?: StringFieldUpdateOperationsInput | string;
      complexity?: NullableIntFieldUpdateOperationsInput | number | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type TaskUncheckedUpdateManyInput = {
      id?: IntFieldUpdateOperationsInput | number;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: StringFieldUpdateOperationsInput | string;
      status?: StringFieldUpdateOperationsInput | string;
      complexity?: NullableIntFieldUpdateOperationsInput | number | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type SubtaskCreateInput = {
      id: string;
      title: string;
      description: string;
      details?: string | null;
      testStrategy?: string | null;
      status: string;
      dependencies?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      parentTask: TaskCreateNestedOneWithoutSubtasksInput;
   };

   export type SubtaskUncheckedCreateInput = {
      id: string;
      title: string;
      description: string;
      details?: string | null;
      testStrategy?: string | null;
      status: string;
      parentId: number;
      dependencies?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type SubtaskUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: StringFieldUpdateOperationsInput | string;
      dependencies?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      parentTask?: TaskUpdateOneRequiredWithoutSubtasksNestedInput;
   };

   export type SubtaskUncheckedUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: StringFieldUpdateOperationsInput | string;
      parentId?: IntFieldUpdateOperationsInput | number;
      dependencies?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type SubtaskCreateManyInput = {
      id: string;
      title: string;
      description: string;
      details?: string | null;
      testStrategy?: string | null;
      status: string;
      parentId: number;
      dependencies?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type SubtaskUpdateManyMutationInput = {
      id?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: StringFieldUpdateOperationsInput | string;
      dependencies?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type SubtaskUncheckedUpdateManyInput = {
      id?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: StringFieldUpdateOperationsInput | string;
      parentId?: IntFieldUpdateOperationsInput | number;
      dependencies?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type TaskDependencyCreateInput = {
      createdAt?: Date | string;
      task: TaskCreateNestedOneWithoutDependenciesInput;
      dependsOn: TaskCreateNestedOneWithoutDependentsInput;
   };

   export type TaskDependencyUncheckedCreateInput = {
      id?: number;
      taskId: number;
      dependsOnId: number;
      createdAt?: Date | string;
   };

   export type TaskDependencyUpdateInput = {
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      task?: TaskUpdateOneRequiredWithoutDependenciesNestedInput;
      dependsOn?: TaskUpdateOneRequiredWithoutDependentsNestedInput;
   };

   export type TaskDependencyUncheckedUpdateInput = {
      id?: IntFieldUpdateOperationsInput | number;
      taskId?: IntFieldUpdateOperationsInput | number;
      dependsOnId?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type TaskDependencyCreateManyInput = {
      id?: number;
      taskId: number;
      dependsOnId: number;
      createdAt?: Date | string;
   };

   export type TaskDependencyUpdateManyMutationInput = {
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type TaskDependencyUncheckedUpdateManyInput = {
      id?: IntFieldUpdateOperationsInput | number;
      taskId?: IntFieldUpdateOperationsInput | number;
      dependsOnId?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type TaskMasterMetadataCreateInput = {
      created: Date | string;
      updated: Date | string;
      description: string;
   };

   export type TaskMasterMetadataUncheckedCreateInput = {
      id?: number;
      created: Date | string;
      updated: Date | string;
      description: string;
   };

   export type TaskMasterMetadataUpdateInput = {
      created?: DateTimeFieldUpdateOperationsInput | Date | string;
      updated?: DateTimeFieldUpdateOperationsInput | Date | string;
      description?: StringFieldUpdateOperationsInput | string;
   };

   export type TaskMasterMetadataUncheckedUpdateInput = {
      id?: IntFieldUpdateOperationsInput | number;
      created?: DateTimeFieldUpdateOperationsInput | Date | string;
      updated?: DateTimeFieldUpdateOperationsInput | Date | string;
      description?: StringFieldUpdateOperationsInput | string;
   };

   export type TaskMasterMetadataCreateManyInput = {
      id?: number;
      created: Date | string;
      updated: Date | string;
      description: string;
   };

   export type TaskMasterMetadataUpdateManyMutationInput = {
      created?: DateTimeFieldUpdateOperationsInput | Date | string;
      updated?: DateTimeFieldUpdateOperationsInput | Date | string;
      description?: StringFieldUpdateOperationsInput | string;
   };

   export type TaskMasterMetadataUncheckedUpdateManyInput = {
      id?: IntFieldUpdateOperationsInput | number;
      created?: DateTimeFieldUpdateOperationsInput | Date | string;
      updated?: DateTimeFieldUpdateOperationsInput | Date | string;
      description?: StringFieldUpdateOperationsInput | string;
   };

   export type SyncOperationCreateInput = {
      id?: string;
      type: string;
      status: string;
      source: string;
      timestamp?: Date | string;
      completedAt?: Date | string | null;
      data: string;
      rollbackData?: string | null;
      metadata?: string | null;
      retryCount?: number;
      maxRetries?: number;
      error?: string | null;
      taskIds?: string;
   };

   export type SyncOperationUncheckedCreateInput = {
      id?: string;
      type: string;
      status: string;
      source: string;
      timestamp?: Date | string;
      completedAt?: Date | string | null;
      data: string;
      rollbackData?: string | null;
      metadata?: string | null;
      retryCount?: number;
      maxRetries?: number;
      error?: string | null;
      taskIds?: string;
   };

   export type SyncOperationUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      type?: StringFieldUpdateOperationsInput | string;
      status?: StringFieldUpdateOperationsInput | string;
      source?: StringFieldUpdateOperationsInput | string;
      timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
      completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      data?: StringFieldUpdateOperationsInput | string;
      rollbackData?: NullableStringFieldUpdateOperationsInput | string | null;
      metadata?: NullableStringFieldUpdateOperationsInput | string | null;
      retryCount?: IntFieldUpdateOperationsInput | number;
      maxRetries?: IntFieldUpdateOperationsInput | number;
      error?: NullableStringFieldUpdateOperationsInput | string | null;
      taskIds?: StringFieldUpdateOperationsInput | string;
   };

   export type SyncOperationUncheckedUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      type?: StringFieldUpdateOperationsInput | string;
      status?: StringFieldUpdateOperationsInput | string;
      source?: StringFieldUpdateOperationsInput | string;
      timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
      completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      data?: StringFieldUpdateOperationsInput | string;
      rollbackData?: NullableStringFieldUpdateOperationsInput | string | null;
      metadata?: NullableStringFieldUpdateOperationsInput | string | null;
      retryCount?: IntFieldUpdateOperationsInput | number;
      maxRetries?: IntFieldUpdateOperationsInput | number;
      error?: NullableStringFieldUpdateOperationsInput | string | null;
      taskIds?: StringFieldUpdateOperationsInput | string;
   };

   export type SyncOperationCreateManyInput = {
      id?: string;
      type: string;
      status: string;
      source: string;
      timestamp?: Date | string;
      completedAt?: Date | string | null;
      data: string;
      rollbackData?: string | null;
      metadata?: string | null;
      retryCount?: number;
      maxRetries?: number;
      error?: string | null;
      taskIds?: string;
   };

   export type SyncOperationUpdateManyMutationInput = {
      id?: StringFieldUpdateOperationsInput | string;
      type?: StringFieldUpdateOperationsInput | string;
      status?: StringFieldUpdateOperationsInput | string;
      source?: StringFieldUpdateOperationsInput | string;
      timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
      completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      data?: StringFieldUpdateOperationsInput | string;
      rollbackData?: NullableStringFieldUpdateOperationsInput | string | null;
      metadata?: NullableStringFieldUpdateOperationsInput | string | null;
      retryCount?: IntFieldUpdateOperationsInput | number;
      maxRetries?: IntFieldUpdateOperationsInput | number;
      error?: NullableStringFieldUpdateOperationsInput | string | null;
      taskIds?: StringFieldUpdateOperationsInput | string;
   };

   export type SyncOperationUncheckedUpdateManyInput = {
      id?: StringFieldUpdateOperationsInput | string;
      type?: StringFieldUpdateOperationsInput | string;
      status?: StringFieldUpdateOperationsInput | string;
      source?: StringFieldUpdateOperationsInput | string;
      timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
      completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      data?: StringFieldUpdateOperationsInput | string;
      rollbackData?: NullableStringFieldUpdateOperationsInput | string | null;
      metadata?: NullableStringFieldUpdateOperationsInput | string | null;
      retryCount?: IntFieldUpdateOperationsInput | number;
      maxRetries?: IntFieldUpdateOperationsInput | number;
      error?: NullableStringFieldUpdateOperationsInput | string | null;
      taskIds?: StringFieldUpdateOperationsInput | string;
   };

   export type SyncConflictCreateInput = {
      id?: string;
      operationType: string;
      taskId: string;
      uiVersion: string;
      cliVersion: string;
      resolved?: boolean;
      resolution?: string | null;
      resolvedAt?: Date | string | null;
      resolvedBy?: string | null;
      timestamp?: Date | string;
   };

   export type SyncConflictUncheckedCreateInput = {
      id?: string;
      operationType: string;
      taskId: string;
      uiVersion: string;
      cliVersion: string;
      resolved?: boolean;
      resolution?: string | null;
      resolvedAt?: Date | string | null;
      resolvedBy?: string | null;
      timestamp?: Date | string;
   };

   export type SyncConflictUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      operationType?: StringFieldUpdateOperationsInput | string;
      taskId?: StringFieldUpdateOperationsInput | string;
      uiVersion?: StringFieldUpdateOperationsInput | string;
      cliVersion?: StringFieldUpdateOperationsInput | string;
      resolved?: BoolFieldUpdateOperationsInput | boolean;
      resolution?: NullableStringFieldUpdateOperationsInput | string | null;
      resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
      timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type SyncConflictUncheckedUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      operationType?: StringFieldUpdateOperationsInput | string;
      taskId?: StringFieldUpdateOperationsInput | string;
      uiVersion?: StringFieldUpdateOperationsInput | string;
      cliVersion?: StringFieldUpdateOperationsInput | string;
      resolved?: BoolFieldUpdateOperationsInput | boolean;
      resolution?: NullableStringFieldUpdateOperationsInput | string | null;
      resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
      timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type SyncConflictCreateManyInput = {
      id?: string;
      operationType: string;
      taskId: string;
      uiVersion: string;
      cliVersion: string;
      resolved?: boolean;
      resolution?: string | null;
      resolvedAt?: Date | string | null;
      resolvedBy?: string | null;
      timestamp?: Date | string;
   };

   export type SyncConflictUpdateManyMutationInput = {
      id?: StringFieldUpdateOperationsInput | string;
      operationType?: StringFieldUpdateOperationsInput | string;
      taskId?: StringFieldUpdateOperationsInput | string;
      uiVersion?: StringFieldUpdateOperationsInput | string;
      cliVersion?: StringFieldUpdateOperationsInput | string;
      resolved?: BoolFieldUpdateOperationsInput | boolean;
      resolution?: NullableStringFieldUpdateOperationsInput | string | null;
      resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
      timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type SyncConflictUncheckedUpdateManyInput = {
      id?: StringFieldUpdateOperationsInput | string;
      operationType?: StringFieldUpdateOperationsInput | string;
      taskId?: StringFieldUpdateOperationsInput | string;
      uiVersion?: StringFieldUpdateOperationsInput | string;
      cliVersion?: StringFieldUpdateOperationsInput | string;
      resolved?: BoolFieldUpdateOperationsInput | boolean;
      resolution?: NullableStringFieldUpdateOperationsInput | string | null;
      resolvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      resolvedBy?: NullableStringFieldUpdateOperationsInput | string | null;
      timestamp?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type UserCreateInput = {
      id?: string;
      name: string;
      email: string;
      avatarUrl?: string | null;
      status?: $Enums.UserStatus;
      role?: $Enums.UserRole;
      joinedDate: Date | string;
      teamIds?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      assignedIssues?: IssueCreateNestedManyWithoutAssigneeInput;
      teams?: TeamMemberCreateNestedManyWithoutUserInput;
      ledProjects?: ProjectCreateNestedManyWithoutLeadInput;
   };

   export type UserUncheckedCreateInput = {
      id?: string;
      name: string;
      email: string;
      avatarUrl?: string | null;
      status?: $Enums.UserStatus;
      role?: $Enums.UserRole;
      joinedDate: Date | string;
      teamIds?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      assignedIssues?: IssueUncheckedCreateNestedManyWithoutAssigneeInput;
      teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
      ledProjects?: ProjectUncheckedCreateNestedManyWithoutLeadInput;
   };

   export type UserUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      email?: StringFieldUpdateOperationsInput | string;
      avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
      role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
      joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      teamIds?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      assignedIssues?: IssueUpdateManyWithoutAssigneeNestedInput;
      teams?: TeamMemberUpdateManyWithoutUserNestedInput;
      ledProjects?: ProjectUpdateManyWithoutLeadNestedInput;
   };

   export type UserUncheckedUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      email?: StringFieldUpdateOperationsInput | string;
      avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
      role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
      joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      teamIds?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      assignedIssues?: IssueUncheckedUpdateManyWithoutAssigneeNestedInput;
      teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
      ledProjects?: ProjectUncheckedUpdateManyWithoutLeadNestedInput;
   };

   export type UserCreateManyInput = {
      id?: string;
      name: string;
      email: string;
      avatarUrl?: string | null;
      status?: $Enums.UserStatus;
      role?: $Enums.UserRole;
      joinedDate: Date | string;
      teamIds?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type UserUpdateManyMutationInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      email?: StringFieldUpdateOperationsInput | string;
      avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
      role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
      joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      teamIds?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type UserUncheckedUpdateManyInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      email?: StringFieldUpdateOperationsInput | string;
      avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
      role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
      joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      teamIds?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type ProjectCreateInput = {
      id?: string;
      name: string;
      description?: string | null;
      color?: string | null;
      identifier?: string | null;
      icon?: string | null;
      percentComplete?: number;
      startDate?: Date | string | null;
      health?: $Enums.ProjectHealth;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      issues?: IssueCreateNestedManyWithoutProjectInput;
      lead?: UserCreateNestedOneWithoutLedProjectsInput;
      teams?: TeamProjectCreateNestedManyWithoutProjectInput;
   };

   export type ProjectUncheckedCreateInput = {
      id?: string;
      name: string;
      description?: string | null;
      color?: string | null;
      identifier?: string | null;
      icon?: string | null;
      percentComplete?: number;
      startDate?: Date | string | null;
      health?: $Enums.ProjectHealth;
      leadId?: string | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      issues?: IssueUncheckedCreateNestedManyWithoutProjectInput;
      teams?: TeamProjectUncheckedCreateNestedManyWithoutProjectInput;
   };

   export type ProjectUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      description?: NullableStringFieldUpdateOperationsInput | string | null;
      color?: NullableStringFieldUpdateOperationsInput | string | null;
      identifier?: NullableStringFieldUpdateOperationsInput | string | null;
      icon?: NullableStringFieldUpdateOperationsInput | string | null;
      percentComplete?: IntFieldUpdateOperationsInput | number;
      startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      health?: EnumProjectHealthFieldUpdateOperationsInput | $Enums.ProjectHealth;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      issues?: IssueUpdateManyWithoutProjectNestedInput;
      lead?: UserUpdateOneWithoutLedProjectsNestedInput;
      teams?: TeamProjectUpdateManyWithoutProjectNestedInput;
   };

   export type ProjectUncheckedUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      description?: NullableStringFieldUpdateOperationsInput | string | null;
      color?: NullableStringFieldUpdateOperationsInput | string | null;
      identifier?: NullableStringFieldUpdateOperationsInput | string | null;
      icon?: NullableStringFieldUpdateOperationsInput | string | null;
      percentComplete?: IntFieldUpdateOperationsInput | number;
      startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      health?: EnumProjectHealthFieldUpdateOperationsInput | $Enums.ProjectHealth;
      leadId?: NullableStringFieldUpdateOperationsInput | string | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      issues?: IssueUncheckedUpdateManyWithoutProjectNestedInput;
      teams?: TeamProjectUncheckedUpdateManyWithoutProjectNestedInput;
   };

   export type ProjectCreateManyInput = {
      id?: string;
      name: string;
      description?: string | null;
      color?: string | null;
      identifier?: string | null;
      icon?: string | null;
      percentComplete?: number;
      startDate?: Date | string | null;
      health?: $Enums.ProjectHealth;
      leadId?: string | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type ProjectUpdateManyMutationInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      description?: NullableStringFieldUpdateOperationsInput | string | null;
      color?: NullableStringFieldUpdateOperationsInput | string | null;
      identifier?: NullableStringFieldUpdateOperationsInput | string | null;
      icon?: NullableStringFieldUpdateOperationsInput | string | null;
      percentComplete?: IntFieldUpdateOperationsInput | number;
      startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      health?: EnumProjectHealthFieldUpdateOperationsInput | $Enums.ProjectHealth;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type ProjectUncheckedUpdateManyInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      description?: NullableStringFieldUpdateOperationsInput | string | null;
      color?: NullableStringFieldUpdateOperationsInput | string | null;
      identifier?: NullableStringFieldUpdateOperationsInput | string | null;
      icon?: NullableStringFieldUpdateOperationsInput | string | null;
      percentComplete?: IntFieldUpdateOperationsInput | number;
      startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      health?: EnumProjectHealthFieldUpdateOperationsInput | $Enums.ProjectHealth;
      leadId?: NullableStringFieldUpdateOperationsInput | string | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type LabelCreateInput = {
      id?: string;
      name: string;
      color: string;
      description?: string | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      issues?: IssueLabelCreateNestedManyWithoutLabelInput;
   };

   export type LabelUncheckedCreateInput = {
      id?: string;
      name: string;
      color: string;
      description?: string | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      issues?: IssueLabelUncheckedCreateNestedManyWithoutLabelInput;
   };

   export type LabelUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      color?: StringFieldUpdateOperationsInput | string;
      description?: NullableStringFieldUpdateOperationsInput | string | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      issues?: IssueLabelUpdateManyWithoutLabelNestedInput;
   };

   export type LabelUncheckedUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      color?: StringFieldUpdateOperationsInput | string;
      description?: NullableStringFieldUpdateOperationsInput | string | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      issues?: IssueLabelUncheckedUpdateManyWithoutLabelNestedInput;
   };

   export type LabelCreateManyInput = {
      id?: string;
      name: string;
      color: string;
      description?: string | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type LabelUpdateManyMutationInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      color?: StringFieldUpdateOperationsInput | string;
      description?: NullableStringFieldUpdateOperationsInput | string | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type LabelUncheckedUpdateManyInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      color?: StringFieldUpdateOperationsInput | string;
      description?: NullableStringFieldUpdateOperationsInput | string | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type IssueStatusCreateInput = {
      id: string;
      name: string;
      color: string;
      iconName: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      issues?: IssueCreateNestedManyWithoutIssueStatusInput;
   };

   export type IssueStatusUncheckedCreateInput = {
      id: string;
      name: string;
      color: string;
      iconName: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      issues?: IssueUncheckedCreateNestedManyWithoutIssueStatusInput;
   };

   export type IssueStatusUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      color?: StringFieldUpdateOperationsInput | string;
      iconName?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      issues?: IssueUpdateManyWithoutIssueStatusNestedInput;
   };

   export type IssueStatusUncheckedUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      color?: StringFieldUpdateOperationsInput | string;
      iconName?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      issues?: IssueUncheckedUpdateManyWithoutIssueStatusNestedInput;
   };

   export type IssueStatusCreateManyInput = {
      id: string;
      name: string;
      color: string;
      iconName: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type IssueStatusUpdateManyMutationInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      color?: StringFieldUpdateOperationsInput | string;
      iconName?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type IssueStatusUncheckedUpdateManyInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      color?: StringFieldUpdateOperationsInput | string;
      iconName?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type IssuePriorityCreateInput = {
      id: string;
      name: string;
      iconName: string;
      order: number;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      issues?: IssueCreateNestedManyWithoutIssuePriorityInput;
   };

   export type IssuePriorityUncheckedCreateInput = {
      id: string;
      name: string;
      iconName: string;
      order: number;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      issues?: IssueUncheckedCreateNestedManyWithoutIssuePriorityInput;
   };

   export type IssuePriorityUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      iconName?: StringFieldUpdateOperationsInput | string;
      order?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      issues?: IssueUpdateManyWithoutIssuePriorityNestedInput;
   };

   export type IssuePriorityUncheckedUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      iconName?: StringFieldUpdateOperationsInput | string;
      order?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      issues?: IssueUncheckedUpdateManyWithoutIssuePriorityNestedInput;
   };

   export type IssuePriorityCreateManyInput = {
      id: string;
      name: string;
      iconName: string;
      order: number;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type IssuePriorityUpdateManyMutationInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      iconName?: StringFieldUpdateOperationsInput | string;
      order?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type IssuePriorityUncheckedUpdateManyInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      iconName?: StringFieldUpdateOperationsInput | string;
      order?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type IssueCreateInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      status?: string | null;
      priority?: string | null;
      rank: string;
      dueDate?: Date | string | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      assignee?: UserCreateNestedOneWithoutAssignedIssuesInput;
      project?: ProjectCreateNestedOneWithoutIssuesInput;
      cycle?: CycleCreateNestedOneWithoutIssuesInput;
      task?: TaskCreateNestedOneWithoutIssuesInput;
      issueStatus?: IssueStatusCreateNestedOneWithoutIssuesInput;
      issuePriority?: IssuePriorityCreateNestedOneWithoutIssuesInput;
      labels?: IssueLabelCreateNestedManyWithoutIssueInput;
   };

   export type IssueUncheckedCreateInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      statusId?: string | null;
      priorityId?: string | null;
      status?: string | null;
      priority?: string | null;
      rank: string;
      cycleId?: string | null;
      dueDate?: Date | string | null;
      taskId?: number | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      assigneeId?: string | null;
      projectId?: string | null;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      labels?: IssueLabelUncheckedCreateNestedManyWithoutIssueInput;
   };

   export type IssueUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      assignee?: UserUpdateOneWithoutAssignedIssuesNestedInput;
      project?: ProjectUpdateOneWithoutIssuesNestedInput;
      cycle?: CycleUpdateOneWithoutIssuesNestedInput;
      task?: TaskUpdateOneWithoutIssuesNestedInput;
      issueStatus?: IssueStatusUpdateOneWithoutIssuesNestedInput;
      issuePriority?: IssuePriorityUpdateOneWithoutIssuesNestedInput;
      labels?: IssueLabelUpdateManyWithoutIssueNestedInput;
   };

   export type IssueUncheckedUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      statusId?: NullableStringFieldUpdateOperationsInput | string | null;
      priorityId?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      cycleId?: NullableStringFieldUpdateOperationsInput | string | null;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      taskId?: NullableIntFieldUpdateOperationsInput | number | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      assigneeId?: NullableStringFieldUpdateOperationsInput | string | null;
      projectId?: NullableStringFieldUpdateOperationsInput | string | null;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      labels?: IssueLabelUncheckedUpdateManyWithoutIssueNestedInput;
   };

   export type IssueCreateManyInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      statusId?: string | null;
      priorityId?: string | null;
      status?: string | null;
      priority?: string | null;
      rank: string;
      cycleId?: string | null;
      dueDate?: Date | string | null;
      taskId?: number | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      assigneeId?: string | null;
      projectId?: string | null;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type IssueUpdateManyMutationInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type IssueUncheckedUpdateManyInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      statusId?: NullableStringFieldUpdateOperationsInput | string | null;
      priorityId?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      cycleId?: NullableStringFieldUpdateOperationsInput | string | null;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      taskId?: NullableIntFieldUpdateOperationsInput | number | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      assigneeId?: NullableStringFieldUpdateOperationsInput | string | null;
      projectId?: NullableStringFieldUpdateOperationsInput | string | null;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type IssueLabelCreateInput = {
      id?: string;
      issue: IssueCreateNestedOneWithoutLabelsInput;
      label: LabelCreateNestedOneWithoutIssuesInput;
   };

   export type IssueLabelUncheckedCreateInput = {
      id?: string;
      issueId: string;
      labelId: string;
   };

   export type IssueLabelUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      issue?: IssueUpdateOneRequiredWithoutLabelsNestedInput;
      label?: LabelUpdateOneRequiredWithoutIssuesNestedInput;
   };

   export type IssueLabelUncheckedUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      issueId?: StringFieldUpdateOperationsInput | string;
      labelId?: StringFieldUpdateOperationsInput | string;
   };

   export type IssueLabelCreateManyInput = {
      id?: string;
      issueId: string;
      labelId: string;
   };

   export type IssueLabelUpdateManyMutationInput = {
      id?: StringFieldUpdateOperationsInput | string;
   };

   export type IssueLabelUncheckedUpdateManyInput = {
      id?: StringFieldUpdateOperationsInput | string;
      issueId?: StringFieldUpdateOperationsInput | string;
      labelId?: StringFieldUpdateOperationsInput | string;
   };

   export type CycleCreateInput = {
      id?: string;
      number: number;
      name: string;
      startDate: Date | string;
      endDate: Date | string;
      progress?: number;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      team: TeamCreateNestedOneWithoutCyclesInput;
      issues?: IssueCreateNestedManyWithoutCycleInput;
   };

   export type CycleUncheckedCreateInput = {
      id?: string;
      number: number;
      name: string;
      teamId: string;
      startDate: Date | string;
      endDate: Date | string;
      progress?: number;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      issues?: IssueUncheckedCreateNestedManyWithoutCycleInput;
   };

   export type CycleUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      number?: IntFieldUpdateOperationsInput | number;
      name?: StringFieldUpdateOperationsInput | string;
      startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      progress?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      team?: TeamUpdateOneRequiredWithoutCyclesNestedInput;
      issues?: IssueUpdateManyWithoutCycleNestedInput;
   };

   export type CycleUncheckedUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      number?: IntFieldUpdateOperationsInput | number;
      name?: StringFieldUpdateOperationsInput | string;
      teamId?: StringFieldUpdateOperationsInput | string;
      startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      progress?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      issues?: IssueUncheckedUpdateManyWithoutCycleNestedInput;
   };

   export type CycleCreateManyInput = {
      id?: string;
      number: number;
      name: string;
      teamId: string;
      startDate: Date | string;
      endDate: Date | string;
      progress?: number;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type CycleUpdateManyMutationInput = {
      id?: StringFieldUpdateOperationsInput | string;
      number?: IntFieldUpdateOperationsInput | number;
      name?: StringFieldUpdateOperationsInput | string;
      startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      progress?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type CycleUncheckedUpdateManyInput = {
      id?: StringFieldUpdateOperationsInput | string;
      number?: IntFieldUpdateOperationsInput | number;
      name?: StringFieldUpdateOperationsInput | string;
      teamId?: StringFieldUpdateOperationsInput | string;
      startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      progress?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type TeamCreateInput = {
      id?: string;
      name: string;
      icon: string;
      joined?: boolean;
      color: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      members?: TeamMemberCreateNestedManyWithoutTeamInput;
      projects?: TeamProjectCreateNestedManyWithoutTeamInput;
      cycles?: CycleCreateNestedManyWithoutTeamInput;
   };

   export type TeamUncheckedCreateInput = {
      id?: string;
      name: string;
      icon: string;
      joined?: boolean;
      color: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput;
      projects?: TeamProjectUncheckedCreateNestedManyWithoutTeamInput;
      cycles?: CycleUncheckedCreateNestedManyWithoutTeamInput;
   };

   export type TeamUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      icon?: StringFieldUpdateOperationsInput | string;
      joined?: BoolFieldUpdateOperationsInput | boolean;
      color?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      members?: TeamMemberUpdateManyWithoutTeamNestedInput;
      projects?: TeamProjectUpdateManyWithoutTeamNestedInput;
      cycles?: CycleUpdateManyWithoutTeamNestedInput;
   };

   export type TeamUncheckedUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      icon?: StringFieldUpdateOperationsInput | string;
      joined?: BoolFieldUpdateOperationsInput | boolean;
      color?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput;
      projects?: TeamProjectUncheckedUpdateManyWithoutTeamNestedInput;
      cycles?: CycleUncheckedUpdateManyWithoutTeamNestedInput;
   };

   export type TeamCreateManyInput = {
      id?: string;
      name: string;
      icon: string;
      joined?: boolean;
      color: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type TeamUpdateManyMutationInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      icon?: StringFieldUpdateOperationsInput | string;
      joined?: BoolFieldUpdateOperationsInput | boolean;
      color?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type TeamUncheckedUpdateManyInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      icon?: StringFieldUpdateOperationsInput | string;
      joined?: BoolFieldUpdateOperationsInput | boolean;
      color?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type TeamMemberCreateInput = {
      id?: string;
      team: TeamCreateNestedOneWithoutMembersInput;
      user: UserCreateNestedOneWithoutTeamsInput;
   };

   export type TeamMemberUncheckedCreateInput = {
      id?: string;
      teamId: string;
      userId: string;
   };

   export type TeamMemberUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      team?: TeamUpdateOneRequiredWithoutMembersNestedInput;
      user?: UserUpdateOneRequiredWithoutTeamsNestedInput;
   };

   export type TeamMemberUncheckedUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      teamId?: StringFieldUpdateOperationsInput | string;
      userId?: StringFieldUpdateOperationsInput | string;
   };

   export type TeamMemberCreateManyInput = {
      id?: string;
      teamId: string;
      userId: string;
   };

   export type TeamMemberUpdateManyMutationInput = {
      id?: StringFieldUpdateOperationsInput | string;
   };

   export type TeamMemberUncheckedUpdateManyInput = {
      id?: StringFieldUpdateOperationsInput | string;
      teamId?: StringFieldUpdateOperationsInput | string;
      userId?: StringFieldUpdateOperationsInput | string;
   };

   export type TeamProjectCreateInput = {
      id?: string;
      team: TeamCreateNestedOneWithoutProjectsInput;
      project: ProjectCreateNestedOneWithoutTeamsInput;
   };

   export type TeamProjectUncheckedCreateInput = {
      id?: string;
      teamId: string;
      projectId: string;
   };

   export type TeamProjectUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      team?: TeamUpdateOneRequiredWithoutProjectsNestedInput;
      project?: ProjectUpdateOneRequiredWithoutTeamsNestedInput;
   };

   export type TeamProjectUncheckedUpdateInput = {
      id?: StringFieldUpdateOperationsInput | string;
      teamId?: StringFieldUpdateOperationsInput | string;
      projectId?: StringFieldUpdateOperationsInput | string;
   };

   export type TeamProjectCreateManyInput = {
      id?: string;
      teamId: string;
      projectId: string;
   };

   export type TeamProjectUpdateManyMutationInput = {
      id?: StringFieldUpdateOperationsInput | string;
   };

   export type TeamProjectUncheckedUpdateManyInput = {
      id?: StringFieldUpdateOperationsInput | string;
      teamId?: StringFieldUpdateOperationsInput | string;
      projectId?: StringFieldUpdateOperationsInput | string;
   };

   export type IntFilter<$PrismaModel = never> = {
      equals?: number | IntFieldRefInput<$PrismaModel>;
      in?: number[];
      notIn?: number[];
      lt?: number | IntFieldRefInput<$PrismaModel>;
      lte?: number | IntFieldRefInput<$PrismaModel>;
      gt?: number | IntFieldRefInput<$PrismaModel>;
      gte?: number | IntFieldRefInput<$PrismaModel>;
      not?: NestedIntFilter<$PrismaModel> | number;
   };

   export type StringFilter<$PrismaModel = never> = {
      equals?: string | StringFieldRefInput<$PrismaModel>;
      in?: string[];
      notIn?: string[];
      lt?: string | StringFieldRefInput<$PrismaModel>;
      lte?: string | StringFieldRefInput<$PrismaModel>;
      gt?: string | StringFieldRefInput<$PrismaModel>;
      gte?: string | StringFieldRefInput<$PrismaModel>;
      contains?: string | StringFieldRefInput<$PrismaModel>;
      startsWith?: string | StringFieldRefInput<$PrismaModel>;
      endsWith?: string | StringFieldRefInput<$PrismaModel>;
      not?: NestedStringFilter<$PrismaModel> | string;
   };

   export type StringNullableFilter<$PrismaModel = never> = {
      equals?: string | StringFieldRefInput<$PrismaModel> | null;
      in?: string[] | null;
      notIn?: string[] | null;
      lt?: string | StringFieldRefInput<$PrismaModel>;
      lte?: string | StringFieldRefInput<$PrismaModel>;
      gt?: string | StringFieldRefInput<$PrismaModel>;
      gte?: string | StringFieldRefInput<$PrismaModel>;
      contains?: string | StringFieldRefInput<$PrismaModel>;
      startsWith?: string | StringFieldRefInput<$PrismaModel>;
      endsWith?: string | StringFieldRefInput<$PrismaModel>;
      not?: NestedStringNullableFilter<$PrismaModel> | string | null;
   };

   export type IntNullableFilter<$PrismaModel = never> = {
      equals?: number | IntFieldRefInput<$PrismaModel> | null;
      in?: number[] | null;
      notIn?: number[] | null;
      lt?: number | IntFieldRefInput<$PrismaModel>;
      lte?: number | IntFieldRefInput<$PrismaModel>;
      gt?: number | IntFieldRefInput<$PrismaModel>;
      gte?: number | IntFieldRefInput<$PrismaModel>;
      not?: NestedIntNullableFilter<$PrismaModel> | number | null;
   };

   export type DateTimeFilter<$PrismaModel = never> = {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      in?: Date[] | string[];
      notIn?: Date[] | string[];
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
   };

   export type SubtaskListRelationFilter = {
      every?: SubtaskWhereInput;
      some?: SubtaskWhereInput;
      none?: SubtaskWhereInput;
   };

   export type TaskDependencyListRelationFilter = {
      every?: TaskDependencyWhereInput;
      some?: TaskDependencyWhereInput;
      none?: TaskDependencyWhereInput;
   };

   export type IssueListRelationFilter = {
      every?: IssueWhereInput;
      some?: IssueWhereInput;
      none?: IssueWhereInput;
   };

   export type SortOrderInput = {
      sort: SortOrder;
      nulls?: NullsOrder;
   };

   export type SubtaskOrderByRelationAggregateInput = {
      _count?: SortOrder;
   };

   export type TaskDependencyOrderByRelationAggregateInput = {
      _count?: SortOrder;
   };

   export type IssueOrderByRelationAggregateInput = {
      _count?: SortOrder;
   };

   export type TaskCountOrderByAggregateInput = {
      id?: SortOrder;
      title?: SortOrder;
      description?: SortOrder;
      details?: SortOrder;
      testStrategy?: SortOrder;
      priority?: SortOrder;
      status?: SortOrder;
      complexity?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type TaskAvgOrderByAggregateInput = {
      id?: SortOrder;
      complexity?: SortOrder;
   };

   export type TaskMaxOrderByAggregateInput = {
      id?: SortOrder;
      title?: SortOrder;
      description?: SortOrder;
      details?: SortOrder;
      testStrategy?: SortOrder;
      priority?: SortOrder;
      status?: SortOrder;
      complexity?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type TaskMinOrderByAggregateInput = {
      id?: SortOrder;
      title?: SortOrder;
      description?: SortOrder;
      details?: SortOrder;
      testStrategy?: SortOrder;
      priority?: SortOrder;
      status?: SortOrder;
      complexity?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type TaskSumOrderByAggregateInput = {
      id?: SortOrder;
      complexity?: SortOrder;
   };

   export type IntWithAggregatesFilter<$PrismaModel = never> = {
      equals?: number | IntFieldRefInput<$PrismaModel>;
      in?: number[];
      notIn?: number[];
      lt?: number | IntFieldRefInput<$PrismaModel>;
      lte?: number | IntFieldRefInput<$PrismaModel>;
      gt?: number | IntFieldRefInput<$PrismaModel>;
      gte?: number | IntFieldRefInput<$PrismaModel>;
      not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
      _count?: NestedIntFilter<$PrismaModel>;
      _avg?: NestedFloatFilter<$PrismaModel>;
      _sum?: NestedIntFilter<$PrismaModel>;
      _min?: NestedIntFilter<$PrismaModel>;
      _max?: NestedIntFilter<$PrismaModel>;
   };

   export type StringWithAggregatesFilter<$PrismaModel = never> = {
      equals?: string | StringFieldRefInput<$PrismaModel>;
      in?: string[];
      notIn?: string[];
      lt?: string | StringFieldRefInput<$PrismaModel>;
      lte?: string | StringFieldRefInput<$PrismaModel>;
      gt?: string | StringFieldRefInput<$PrismaModel>;
      gte?: string | StringFieldRefInput<$PrismaModel>;
      contains?: string | StringFieldRefInput<$PrismaModel>;
      startsWith?: string | StringFieldRefInput<$PrismaModel>;
      endsWith?: string | StringFieldRefInput<$PrismaModel>;
      not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedStringFilter<$PrismaModel>;
      _max?: NestedStringFilter<$PrismaModel>;
   };

   export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
      equals?: string | StringFieldRefInput<$PrismaModel> | null;
      in?: string[] | null;
      notIn?: string[] | null;
      lt?: string | StringFieldRefInput<$PrismaModel>;
      lte?: string | StringFieldRefInput<$PrismaModel>;
      gt?: string | StringFieldRefInput<$PrismaModel>;
      gte?: string | StringFieldRefInput<$PrismaModel>;
      contains?: string | StringFieldRefInput<$PrismaModel>;
      startsWith?: string | StringFieldRefInput<$PrismaModel>;
      endsWith?: string | StringFieldRefInput<$PrismaModel>;
      not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedStringNullableFilter<$PrismaModel>;
      _max?: NestedStringNullableFilter<$PrismaModel>;
   };

   export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
      equals?: number | IntFieldRefInput<$PrismaModel> | null;
      in?: number[] | null;
      notIn?: number[] | null;
      lt?: number | IntFieldRefInput<$PrismaModel>;
      lte?: number | IntFieldRefInput<$PrismaModel>;
      gt?: number | IntFieldRefInput<$PrismaModel>;
      gte?: number | IntFieldRefInput<$PrismaModel>;
      not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _avg?: NestedFloatNullableFilter<$PrismaModel>;
      _sum?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedIntNullableFilter<$PrismaModel>;
      _max?: NestedIntNullableFilter<$PrismaModel>;
   };

   export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      in?: Date[] | string[];
      notIn?: Date[] | string[];
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedDateTimeFilter<$PrismaModel>;
      _max?: NestedDateTimeFilter<$PrismaModel>;
   };

   export type TaskScalarRelationFilter = {
      is?: TaskWhereInput;
      isNot?: TaskWhereInput;
   };

   export type SubtaskCountOrderByAggregateInput = {
      id?: SortOrder;
      title?: SortOrder;
      description?: SortOrder;
      details?: SortOrder;
      testStrategy?: SortOrder;
      status?: SortOrder;
      parentId?: SortOrder;
      dependencies?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type SubtaskAvgOrderByAggregateInput = {
      parentId?: SortOrder;
   };

   export type SubtaskMaxOrderByAggregateInput = {
      id?: SortOrder;
      title?: SortOrder;
      description?: SortOrder;
      details?: SortOrder;
      testStrategy?: SortOrder;
      status?: SortOrder;
      parentId?: SortOrder;
      dependencies?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type SubtaskMinOrderByAggregateInput = {
      id?: SortOrder;
      title?: SortOrder;
      description?: SortOrder;
      details?: SortOrder;
      testStrategy?: SortOrder;
      status?: SortOrder;
      parentId?: SortOrder;
      dependencies?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type SubtaskSumOrderByAggregateInput = {
      parentId?: SortOrder;
   };

   export type TaskDependencyTaskIdDependsOnIdCompoundUniqueInput = {
      taskId: number;
      dependsOnId: number;
   };

   export type TaskDependencyCountOrderByAggregateInput = {
      id?: SortOrder;
      taskId?: SortOrder;
      dependsOnId?: SortOrder;
      createdAt?: SortOrder;
   };

   export type TaskDependencyAvgOrderByAggregateInput = {
      id?: SortOrder;
      taskId?: SortOrder;
      dependsOnId?: SortOrder;
   };

   export type TaskDependencyMaxOrderByAggregateInput = {
      id?: SortOrder;
      taskId?: SortOrder;
      dependsOnId?: SortOrder;
      createdAt?: SortOrder;
   };

   export type TaskDependencyMinOrderByAggregateInput = {
      id?: SortOrder;
      taskId?: SortOrder;
      dependsOnId?: SortOrder;
      createdAt?: SortOrder;
   };

   export type TaskDependencySumOrderByAggregateInput = {
      id?: SortOrder;
      taskId?: SortOrder;
      dependsOnId?: SortOrder;
   };

   export type TaskMasterMetadataCountOrderByAggregateInput = {
      id?: SortOrder;
      created?: SortOrder;
      updated?: SortOrder;
      description?: SortOrder;
   };

   export type TaskMasterMetadataAvgOrderByAggregateInput = {
      id?: SortOrder;
   };

   export type TaskMasterMetadataMaxOrderByAggregateInput = {
      id?: SortOrder;
      created?: SortOrder;
      updated?: SortOrder;
      description?: SortOrder;
   };

   export type TaskMasterMetadataMinOrderByAggregateInput = {
      id?: SortOrder;
      created?: SortOrder;
      updated?: SortOrder;
      description?: SortOrder;
   };

   export type TaskMasterMetadataSumOrderByAggregateInput = {
      id?: SortOrder;
   };

   export type DateTimeNullableFilter<$PrismaModel = never> = {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | null;
      notIn?: Date[] | string[] | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
   };

   export type SyncOperationCountOrderByAggregateInput = {
      id?: SortOrder;
      type?: SortOrder;
      status?: SortOrder;
      source?: SortOrder;
      timestamp?: SortOrder;
      completedAt?: SortOrder;
      data?: SortOrder;
      rollbackData?: SortOrder;
      metadata?: SortOrder;
      retryCount?: SortOrder;
      maxRetries?: SortOrder;
      error?: SortOrder;
      taskIds?: SortOrder;
   };

   export type SyncOperationAvgOrderByAggregateInput = {
      retryCount?: SortOrder;
      maxRetries?: SortOrder;
   };

   export type SyncOperationMaxOrderByAggregateInput = {
      id?: SortOrder;
      type?: SortOrder;
      status?: SortOrder;
      source?: SortOrder;
      timestamp?: SortOrder;
      completedAt?: SortOrder;
      data?: SortOrder;
      rollbackData?: SortOrder;
      metadata?: SortOrder;
      retryCount?: SortOrder;
      maxRetries?: SortOrder;
      error?: SortOrder;
      taskIds?: SortOrder;
   };

   export type SyncOperationMinOrderByAggregateInput = {
      id?: SortOrder;
      type?: SortOrder;
      status?: SortOrder;
      source?: SortOrder;
      timestamp?: SortOrder;
      completedAt?: SortOrder;
      data?: SortOrder;
      rollbackData?: SortOrder;
      metadata?: SortOrder;
      retryCount?: SortOrder;
      maxRetries?: SortOrder;
      error?: SortOrder;
      taskIds?: SortOrder;
   };

   export type SyncOperationSumOrderByAggregateInput = {
      retryCount?: SortOrder;
      maxRetries?: SortOrder;
   };

   export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | null;
      notIn?: Date[] | string[] | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
   };

   export type BoolFilter<$PrismaModel = never> = {
      equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
      not?: NestedBoolFilter<$PrismaModel> | boolean;
   };

   export type SyncConflictCountOrderByAggregateInput = {
      id?: SortOrder;
      operationType?: SortOrder;
      taskId?: SortOrder;
      uiVersion?: SortOrder;
      cliVersion?: SortOrder;
      resolved?: SortOrder;
      resolution?: SortOrder;
      resolvedAt?: SortOrder;
      resolvedBy?: SortOrder;
      timestamp?: SortOrder;
   };

   export type SyncConflictMaxOrderByAggregateInput = {
      id?: SortOrder;
      operationType?: SortOrder;
      taskId?: SortOrder;
      uiVersion?: SortOrder;
      cliVersion?: SortOrder;
      resolved?: SortOrder;
      resolution?: SortOrder;
      resolvedAt?: SortOrder;
      resolvedBy?: SortOrder;
      timestamp?: SortOrder;
   };

   export type SyncConflictMinOrderByAggregateInput = {
      id?: SortOrder;
      operationType?: SortOrder;
      taskId?: SortOrder;
      uiVersion?: SortOrder;
      cliVersion?: SortOrder;
      resolved?: SortOrder;
      resolution?: SortOrder;
      resolvedAt?: SortOrder;
      resolvedBy?: SortOrder;
      timestamp?: SortOrder;
   };

   export type BoolWithAggregatesFilter<$PrismaModel = never> = {
      equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
      not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedBoolFilter<$PrismaModel>;
      _max?: NestedBoolFilter<$PrismaModel>;
   };

   export type EnumUserStatusFilter<$PrismaModel = never> = {
      equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>;
      in?: $Enums.UserStatus[];
      notIn?: $Enums.UserStatus[];
      not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus;
   };

   export type EnumUserRoleFilter<$PrismaModel = never> = {
      equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
      in?: $Enums.UserRole[];
      notIn?: $Enums.UserRole[];
      not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole;
   };

   export type TeamMemberListRelationFilter = {
      every?: TeamMemberWhereInput;
      some?: TeamMemberWhereInput;
      none?: TeamMemberWhereInput;
   };

   export type ProjectListRelationFilter = {
      every?: ProjectWhereInput;
      some?: ProjectWhereInput;
      none?: ProjectWhereInput;
   };

   export type TeamMemberOrderByRelationAggregateInput = {
      _count?: SortOrder;
   };

   export type ProjectOrderByRelationAggregateInput = {
      _count?: SortOrder;
   };

   export type UserCountOrderByAggregateInput = {
      id?: SortOrder;
      name?: SortOrder;
      email?: SortOrder;
      avatarUrl?: SortOrder;
      status?: SortOrder;
      role?: SortOrder;
      joinedDate?: SortOrder;
      teamIds?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type UserMaxOrderByAggregateInput = {
      id?: SortOrder;
      name?: SortOrder;
      email?: SortOrder;
      avatarUrl?: SortOrder;
      status?: SortOrder;
      role?: SortOrder;
      joinedDate?: SortOrder;
      teamIds?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type UserMinOrderByAggregateInput = {
      id?: SortOrder;
      name?: SortOrder;
      email?: SortOrder;
      avatarUrl?: SortOrder;
      status?: SortOrder;
      role?: SortOrder;
      joinedDate?: SortOrder;
      teamIds?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type EnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
      equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>;
      in?: $Enums.UserStatus[];
      notIn?: $Enums.UserStatus[];
      not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumUserStatusFilter<$PrismaModel>;
      _max?: NestedEnumUserStatusFilter<$PrismaModel>;
   };

   export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
      equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
      in?: $Enums.UserRole[];
      notIn?: $Enums.UserRole[];
      not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumUserRoleFilter<$PrismaModel>;
      _max?: NestedEnumUserRoleFilter<$PrismaModel>;
   };

   export type EnumProjectHealthFilter<$PrismaModel = never> = {
      equals?: $Enums.ProjectHealth | EnumProjectHealthFieldRefInput<$PrismaModel>;
      in?: $Enums.ProjectHealth[];
      notIn?: $Enums.ProjectHealth[];
      not?: NestedEnumProjectHealthFilter<$PrismaModel> | $Enums.ProjectHealth;
   };

   export type UserNullableScalarRelationFilter = {
      is?: UserWhereInput | null;
      isNot?: UserWhereInput | null;
   };

   export type TeamProjectListRelationFilter = {
      every?: TeamProjectWhereInput;
      some?: TeamProjectWhereInput;
      none?: TeamProjectWhereInput;
   };

   export type TeamProjectOrderByRelationAggregateInput = {
      _count?: SortOrder;
   };

   export type ProjectCountOrderByAggregateInput = {
      id?: SortOrder;
      name?: SortOrder;
      description?: SortOrder;
      color?: SortOrder;
      identifier?: SortOrder;
      icon?: SortOrder;
      percentComplete?: SortOrder;
      startDate?: SortOrder;
      health?: SortOrder;
      leadId?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type ProjectAvgOrderByAggregateInput = {
      percentComplete?: SortOrder;
   };

   export type ProjectMaxOrderByAggregateInput = {
      id?: SortOrder;
      name?: SortOrder;
      description?: SortOrder;
      color?: SortOrder;
      identifier?: SortOrder;
      icon?: SortOrder;
      percentComplete?: SortOrder;
      startDate?: SortOrder;
      health?: SortOrder;
      leadId?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type ProjectMinOrderByAggregateInput = {
      id?: SortOrder;
      name?: SortOrder;
      description?: SortOrder;
      color?: SortOrder;
      identifier?: SortOrder;
      icon?: SortOrder;
      percentComplete?: SortOrder;
      startDate?: SortOrder;
      health?: SortOrder;
      leadId?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type ProjectSumOrderByAggregateInput = {
      percentComplete?: SortOrder;
   };

   export type EnumProjectHealthWithAggregatesFilter<$PrismaModel = never> = {
      equals?: $Enums.ProjectHealth | EnumProjectHealthFieldRefInput<$PrismaModel>;
      in?: $Enums.ProjectHealth[];
      notIn?: $Enums.ProjectHealth[];
      not?: NestedEnumProjectHealthWithAggregatesFilter<$PrismaModel> | $Enums.ProjectHealth;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumProjectHealthFilter<$PrismaModel>;
      _max?: NestedEnumProjectHealthFilter<$PrismaModel>;
   };

   export type IssueLabelListRelationFilter = {
      every?: IssueLabelWhereInput;
      some?: IssueLabelWhereInput;
      none?: IssueLabelWhereInput;
   };

   export type IssueLabelOrderByRelationAggregateInput = {
      _count?: SortOrder;
   };

   export type LabelCountOrderByAggregateInput = {
      id?: SortOrder;
      name?: SortOrder;
      color?: SortOrder;
      description?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type LabelMaxOrderByAggregateInput = {
      id?: SortOrder;
      name?: SortOrder;
      color?: SortOrder;
      description?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type LabelMinOrderByAggregateInput = {
      id?: SortOrder;
      name?: SortOrder;
      color?: SortOrder;
      description?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type IssueStatusCountOrderByAggregateInput = {
      id?: SortOrder;
      name?: SortOrder;
      color?: SortOrder;
      iconName?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type IssueStatusMaxOrderByAggregateInput = {
      id?: SortOrder;
      name?: SortOrder;
      color?: SortOrder;
      iconName?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type IssueStatusMinOrderByAggregateInput = {
      id?: SortOrder;
      name?: SortOrder;
      color?: SortOrder;
      iconName?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type IssuePriorityCountOrderByAggregateInput = {
      id?: SortOrder;
      name?: SortOrder;
      iconName?: SortOrder;
      order?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type IssuePriorityAvgOrderByAggregateInput = {
      order?: SortOrder;
   };

   export type IssuePriorityMaxOrderByAggregateInput = {
      id?: SortOrder;
      name?: SortOrder;
      iconName?: SortOrder;
      order?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type IssuePriorityMinOrderByAggregateInput = {
      id?: SortOrder;
      name?: SortOrder;
      iconName?: SortOrder;
      order?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type IssuePrioritySumOrderByAggregateInput = {
      order?: SortOrder;
   };

   export type EnumIssueTypeFilter<$PrismaModel = never> = {
      equals?: $Enums.IssueType | EnumIssueTypeFieldRefInput<$PrismaModel>;
      in?: $Enums.IssueType[];
      notIn?: $Enums.IssueType[];
      not?: NestedEnumIssueTypeFilter<$PrismaModel> | $Enums.IssueType;
   };

   export type ProjectNullableScalarRelationFilter = {
      is?: ProjectWhereInput | null;
      isNot?: ProjectWhereInput | null;
   };

   export type CycleNullableScalarRelationFilter = {
      is?: CycleWhereInput | null;
      isNot?: CycleWhereInput | null;
   };

   export type TaskNullableScalarRelationFilter = {
      is?: TaskWhereInput | null;
      isNot?: TaskWhereInput | null;
   };

   export type IssueStatusNullableScalarRelationFilter = {
      is?: IssueStatusWhereInput | null;
      isNot?: IssueStatusWhereInput | null;
   };

   export type IssuePriorityNullableScalarRelationFilter = {
      is?: IssuePriorityWhereInput | null;
      isNot?: IssuePriorityWhereInput | null;
   };

   export type IssueCountOrderByAggregateInput = {
      id?: SortOrder;
      identifier?: SortOrder;
      title?: SortOrder;
      description?: SortOrder;
      statusId?: SortOrder;
      priorityId?: SortOrder;
      status?: SortOrder;
      priority?: SortOrder;
      rank?: SortOrder;
      cycleId?: SortOrder;
      dueDate?: SortOrder;
      taskId?: SortOrder;
      subtaskId?: SortOrder;
      issueType?: SortOrder;
      assigneeId?: SortOrder;
      projectId?: SortOrder;
      subissues?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type IssueAvgOrderByAggregateInput = {
      taskId?: SortOrder;
   };

   export type IssueMaxOrderByAggregateInput = {
      id?: SortOrder;
      identifier?: SortOrder;
      title?: SortOrder;
      description?: SortOrder;
      statusId?: SortOrder;
      priorityId?: SortOrder;
      status?: SortOrder;
      priority?: SortOrder;
      rank?: SortOrder;
      cycleId?: SortOrder;
      dueDate?: SortOrder;
      taskId?: SortOrder;
      subtaskId?: SortOrder;
      issueType?: SortOrder;
      assigneeId?: SortOrder;
      projectId?: SortOrder;
      subissues?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type IssueMinOrderByAggregateInput = {
      id?: SortOrder;
      identifier?: SortOrder;
      title?: SortOrder;
      description?: SortOrder;
      statusId?: SortOrder;
      priorityId?: SortOrder;
      status?: SortOrder;
      priority?: SortOrder;
      rank?: SortOrder;
      cycleId?: SortOrder;
      dueDate?: SortOrder;
      taskId?: SortOrder;
      subtaskId?: SortOrder;
      issueType?: SortOrder;
      assigneeId?: SortOrder;
      projectId?: SortOrder;
      subissues?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type IssueSumOrderByAggregateInput = {
      taskId?: SortOrder;
   };

   export type EnumIssueTypeWithAggregatesFilter<$PrismaModel = never> = {
      equals?: $Enums.IssueType | EnumIssueTypeFieldRefInput<$PrismaModel>;
      in?: $Enums.IssueType[];
      notIn?: $Enums.IssueType[];
      not?: NestedEnumIssueTypeWithAggregatesFilter<$PrismaModel> | $Enums.IssueType;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumIssueTypeFilter<$PrismaModel>;
      _max?: NestedEnumIssueTypeFilter<$PrismaModel>;
   };

   export type IssueScalarRelationFilter = {
      is?: IssueWhereInput;
      isNot?: IssueWhereInput;
   };

   export type LabelScalarRelationFilter = {
      is?: LabelWhereInput;
      isNot?: LabelWhereInput;
   };

   export type IssueLabelIssueIdLabelIdCompoundUniqueInput = {
      issueId: string;
      labelId: string;
   };

   export type IssueLabelCountOrderByAggregateInput = {
      id?: SortOrder;
      issueId?: SortOrder;
      labelId?: SortOrder;
   };

   export type IssueLabelMaxOrderByAggregateInput = {
      id?: SortOrder;
      issueId?: SortOrder;
      labelId?: SortOrder;
   };

   export type IssueLabelMinOrderByAggregateInput = {
      id?: SortOrder;
      issueId?: SortOrder;
      labelId?: SortOrder;
   };

   export type TeamScalarRelationFilter = {
      is?: TeamWhereInput;
      isNot?: TeamWhereInput;
   };

   export type CycleCountOrderByAggregateInput = {
      id?: SortOrder;
      number?: SortOrder;
      name?: SortOrder;
      teamId?: SortOrder;
      startDate?: SortOrder;
      endDate?: SortOrder;
      progress?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type CycleAvgOrderByAggregateInput = {
      number?: SortOrder;
      progress?: SortOrder;
   };

   export type CycleMaxOrderByAggregateInput = {
      id?: SortOrder;
      number?: SortOrder;
      name?: SortOrder;
      teamId?: SortOrder;
      startDate?: SortOrder;
      endDate?: SortOrder;
      progress?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type CycleMinOrderByAggregateInput = {
      id?: SortOrder;
      number?: SortOrder;
      name?: SortOrder;
      teamId?: SortOrder;
      startDate?: SortOrder;
      endDate?: SortOrder;
      progress?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type CycleSumOrderByAggregateInput = {
      number?: SortOrder;
      progress?: SortOrder;
   };

   export type CycleListRelationFilter = {
      every?: CycleWhereInput;
      some?: CycleWhereInput;
      none?: CycleWhereInput;
   };

   export type CycleOrderByRelationAggregateInput = {
      _count?: SortOrder;
   };

   export type TeamCountOrderByAggregateInput = {
      id?: SortOrder;
      name?: SortOrder;
      icon?: SortOrder;
      joined?: SortOrder;
      color?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type TeamMaxOrderByAggregateInput = {
      id?: SortOrder;
      name?: SortOrder;
      icon?: SortOrder;
      joined?: SortOrder;
      color?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type TeamMinOrderByAggregateInput = {
      id?: SortOrder;
      name?: SortOrder;
      icon?: SortOrder;
      joined?: SortOrder;
      color?: SortOrder;
      createdAt?: SortOrder;
      updatedAt?: SortOrder;
   };

   export type UserScalarRelationFilter = {
      is?: UserWhereInput;
      isNot?: UserWhereInput;
   };

   export type TeamMemberTeamIdUserIdCompoundUniqueInput = {
      teamId: string;
      userId: string;
   };

   export type TeamMemberCountOrderByAggregateInput = {
      id?: SortOrder;
      teamId?: SortOrder;
      userId?: SortOrder;
   };

   export type TeamMemberMaxOrderByAggregateInput = {
      id?: SortOrder;
      teamId?: SortOrder;
      userId?: SortOrder;
   };

   export type TeamMemberMinOrderByAggregateInput = {
      id?: SortOrder;
      teamId?: SortOrder;
      userId?: SortOrder;
   };

   export type ProjectScalarRelationFilter = {
      is?: ProjectWhereInput;
      isNot?: ProjectWhereInput;
   };

   export type TeamProjectTeamIdProjectIdCompoundUniqueInput = {
      teamId: string;
      projectId: string;
   };

   export type TeamProjectCountOrderByAggregateInput = {
      id?: SortOrder;
      teamId?: SortOrder;
      projectId?: SortOrder;
   };

   export type TeamProjectMaxOrderByAggregateInput = {
      id?: SortOrder;
      teamId?: SortOrder;
      projectId?: SortOrder;
   };

   export type TeamProjectMinOrderByAggregateInput = {
      id?: SortOrder;
      teamId?: SortOrder;
      projectId?: SortOrder;
   };

   export type SubtaskCreateNestedManyWithoutParentTaskInput = {
      create?:
         | XOR<SubtaskCreateWithoutParentTaskInput, SubtaskUncheckedCreateWithoutParentTaskInput>
         | SubtaskCreateWithoutParentTaskInput[]
         | SubtaskUncheckedCreateWithoutParentTaskInput[];
      connectOrCreate?:
         | SubtaskCreateOrConnectWithoutParentTaskInput
         | SubtaskCreateOrConnectWithoutParentTaskInput[];
      createMany?: SubtaskCreateManyParentTaskInputEnvelope;
      connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[];
   };

   export type TaskDependencyCreateNestedManyWithoutTaskInput = {
      create?:
         | XOR<TaskDependencyCreateWithoutTaskInput, TaskDependencyUncheckedCreateWithoutTaskInput>
         | TaskDependencyCreateWithoutTaskInput[]
         | TaskDependencyUncheckedCreateWithoutTaskInput[];
      connectOrCreate?:
         | TaskDependencyCreateOrConnectWithoutTaskInput
         | TaskDependencyCreateOrConnectWithoutTaskInput[];
      createMany?: TaskDependencyCreateManyTaskInputEnvelope;
      connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
   };

   export type TaskDependencyCreateNestedManyWithoutDependsOnInput = {
      create?:
         | XOR<
              TaskDependencyCreateWithoutDependsOnInput,
              TaskDependencyUncheckedCreateWithoutDependsOnInput
           >
         | TaskDependencyCreateWithoutDependsOnInput[]
         | TaskDependencyUncheckedCreateWithoutDependsOnInput[];
      connectOrCreate?:
         | TaskDependencyCreateOrConnectWithoutDependsOnInput
         | TaskDependencyCreateOrConnectWithoutDependsOnInput[];
      createMany?: TaskDependencyCreateManyDependsOnInputEnvelope;
      connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
   };

   export type IssueCreateNestedManyWithoutTaskInput = {
      create?:
         | XOR<IssueCreateWithoutTaskInput, IssueUncheckedCreateWithoutTaskInput>
         | IssueCreateWithoutTaskInput[]
         | IssueUncheckedCreateWithoutTaskInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutTaskInput
         | IssueCreateOrConnectWithoutTaskInput[];
      createMany?: IssueCreateManyTaskInputEnvelope;
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
   };

   export type SubtaskUncheckedCreateNestedManyWithoutParentTaskInput = {
      create?:
         | XOR<SubtaskCreateWithoutParentTaskInput, SubtaskUncheckedCreateWithoutParentTaskInput>
         | SubtaskCreateWithoutParentTaskInput[]
         | SubtaskUncheckedCreateWithoutParentTaskInput[];
      connectOrCreate?:
         | SubtaskCreateOrConnectWithoutParentTaskInput
         | SubtaskCreateOrConnectWithoutParentTaskInput[];
      createMany?: SubtaskCreateManyParentTaskInputEnvelope;
      connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[];
   };

   export type TaskDependencyUncheckedCreateNestedManyWithoutTaskInput = {
      create?:
         | XOR<TaskDependencyCreateWithoutTaskInput, TaskDependencyUncheckedCreateWithoutTaskInput>
         | TaskDependencyCreateWithoutTaskInput[]
         | TaskDependencyUncheckedCreateWithoutTaskInput[];
      connectOrCreate?:
         | TaskDependencyCreateOrConnectWithoutTaskInput
         | TaskDependencyCreateOrConnectWithoutTaskInput[];
      createMany?: TaskDependencyCreateManyTaskInputEnvelope;
      connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
   };

   export type TaskDependencyUncheckedCreateNestedManyWithoutDependsOnInput = {
      create?:
         | XOR<
              TaskDependencyCreateWithoutDependsOnInput,
              TaskDependencyUncheckedCreateWithoutDependsOnInput
           >
         | TaskDependencyCreateWithoutDependsOnInput[]
         | TaskDependencyUncheckedCreateWithoutDependsOnInput[];
      connectOrCreate?:
         | TaskDependencyCreateOrConnectWithoutDependsOnInput
         | TaskDependencyCreateOrConnectWithoutDependsOnInput[];
      createMany?: TaskDependencyCreateManyDependsOnInputEnvelope;
      connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
   };

   export type IssueUncheckedCreateNestedManyWithoutTaskInput = {
      create?:
         | XOR<IssueCreateWithoutTaskInput, IssueUncheckedCreateWithoutTaskInput>
         | IssueCreateWithoutTaskInput[]
         | IssueUncheckedCreateWithoutTaskInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutTaskInput
         | IssueCreateOrConnectWithoutTaskInput[];
      createMany?: IssueCreateManyTaskInputEnvelope;
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
   };

   export type IntFieldUpdateOperationsInput = {
      set?: number;
      increment?: number;
      decrement?: number;
      multiply?: number;
      divide?: number;
   };

   export type StringFieldUpdateOperationsInput = {
      set?: string;
   };

   export type NullableStringFieldUpdateOperationsInput = {
      set?: string | null;
   };

   export type NullableIntFieldUpdateOperationsInput = {
      set?: number | null;
      increment?: number;
      decrement?: number;
      multiply?: number;
      divide?: number;
   };

   export type DateTimeFieldUpdateOperationsInput = {
      set?: Date | string;
   };

   export type SubtaskUpdateManyWithoutParentTaskNestedInput = {
      create?:
         | XOR<SubtaskCreateWithoutParentTaskInput, SubtaskUncheckedCreateWithoutParentTaskInput>
         | SubtaskCreateWithoutParentTaskInput[]
         | SubtaskUncheckedCreateWithoutParentTaskInput[];
      connectOrCreate?:
         | SubtaskCreateOrConnectWithoutParentTaskInput
         | SubtaskCreateOrConnectWithoutParentTaskInput[];
      upsert?:
         | SubtaskUpsertWithWhereUniqueWithoutParentTaskInput
         | SubtaskUpsertWithWhereUniqueWithoutParentTaskInput[];
      createMany?: SubtaskCreateManyParentTaskInputEnvelope;
      set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[];
      disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[];
      delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[];
      connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[];
      update?:
         | SubtaskUpdateWithWhereUniqueWithoutParentTaskInput
         | SubtaskUpdateWithWhereUniqueWithoutParentTaskInput[];
      updateMany?:
         | SubtaskUpdateManyWithWhereWithoutParentTaskInput
         | SubtaskUpdateManyWithWhereWithoutParentTaskInput[];
      deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[];
   };

   export type TaskDependencyUpdateManyWithoutTaskNestedInput = {
      create?:
         | XOR<TaskDependencyCreateWithoutTaskInput, TaskDependencyUncheckedCreateWithoutTaskInput>
         | TaskDependencyCreateWithoutTaskInput[]
         | TaskDependencyUncheckedCreateWithoutTaskInput[];
      connectOrCreate?:
         | TaskDependencyCreateOrConnectWithoutTaskInput
         | TaskDependencyCreateOrConnectWithoutTaskInput[];
      upsert?:
         | TaskDependencyUpsertWithWhereUniqueWithoutTaskInput
         | TaskDependencyUpsertWithWhereUniqueWithoutTaskInput[];
      createMany?: TaskDependencyCreateManyTaskInputEnvelope;
      set?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
      disconnect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
      delete?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
      connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
      update?:
         | TaskDependencyUpdateWithWhereUniqueWithoutTaskInput
         | TaskDependencyUpdateWithWhereUniqueWithoutTaskInput[];
      updateMany?:
         | TaskDependencyUpdateManyWithWhereWithoutTaskInput
         | TaskDependencyUpdateManyWithWhereWithoutTaskInput[];
      deleteMany?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[];
   };

   export type TaskDependencyUpdateManyWithoutDependsOnNestedInput = {
      create?:
         | XOR<
              TaskDependencyCreateWithoutDependsOnInput,
              TaskDependencyUncheckedCreateWithoutDependsOnInput
           >
         | TaskDependencyCreateWithoutDependsOnInput[]
         | TaskDependencyUncheckedCreateWithoutDependsOnInput[];
      connectOrCreate?:
         | TaskDependencyCreateOrConnectWithoutDependsOnInput
         | TaskDependencyCreateOrConnectWithoutDependsOnInput[];
      upsert?:
         | TaskDependencyUpsertWithWhereUniqueWithoutDependsOnInput
         | TaskDependencyUpsertWithWhereUniqueWithoutDependsOnInput[];
      createMany?: TaskDependencyCreateManyDependsOnInputEnvelope;
      set?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
      disconnect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
      delete?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
      connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
      update?:
         | TaskDependencyUpdateWithWhereUniqueWithoutDependsOnInput
         | TaskDependencyUpdateWithWhereUniqueWithoutDependsOnInput[];
      updateMany?:
         | TaskDependencyUpdateManyWithWhereWithoutDependsOnInput
         | TaskDependencyUpdateManyWithWhereWithoutDependsOnInput[];
      deleteMany?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[];
   };

   export type IssueUpdateManyWithoutTaskNestedInput = {
      create?:
         | XOR<IssueCreateWithoutTaskInput, IssueUncheckedCreateWithoutTaskInput>
         | IssueCreateWithoutTaskInput[]
         | IssueUncheckedCreateWithoutTaskInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutTaskInput
         | IssueCreateOrConnectWithoutTaskInput[];
      upsert?:
         | IssueUpsertWithWhereUniqueWithoutTaskInput
         | IssueUpsertWithWhereUniqueWithoutTaskInput[];
      createMany?: IssueCreateManyTaskInputEnvelope;
      set?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      update?:
         | IssueUpdateWithWhereUniqueWithoutTaskInput
         | IssueUpdateWithWhereUniqueWithoutTaskInput[];
      updateMany?:
         | IssueUpdateManyWithWhereWithoutTaskInput
         | IssueUpdateManyWithWhereWithoutTaskInput[];
      deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[];
   };

   export type SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput = {
      create?:
         | XOR<SubtaskCreateWithoutParentTaskInput, SubtaskUncheckedCreateWithoutParentTaskInput>
         | SubtaskCreateWithoutParentTaskInput[]
         | SubtaskUncheckedCreateWithoutParentTaskInput[];
      connectOrCreate?:
         | SubtaskCreateOrConnectWithoutParentTaskInput
         | SubtaskCreateOrConnectWithoutParentTaskInput[];
      upsert?:
         | SubtaskUpsertWithWhereUniqueWithoutParentTaskInput
         | SubtaskUpsertWithWhereUniqueWithoutParentTaskInput[];
      createMany?: SubtaskCreateManyParentTaskInputEnvelope;
      set?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[];
      disconnect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[];
      delete?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[];
      connect?: SubtaskWhereUniqueInput | SubtaskWhereUniqueInput[];
      update?:
         | SubtaskUpdateWithWhereUniqueWithoutParentTaskInput
         | SubtaskUpdateWithWhereUniqueWithoutParentTaskInput[];
      updateMany?:
         | SubtaskUpdateManyWithWhereWithoutParentTaskInput
         | SubtaskUpdateManyWithWhereWithoutParentTaskInput[];
      deleteMany?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[];
   };

   export type TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput = {
      create?:
         | XOR<TaskDependencyCreateWithoutTaskInput, TaskDependencyUncheckedCreateWithoutTaskInput>
         | TaskDependencyCreateWithoutTaskInput[]
         | TaskDependencyUncheckedCreateWithoutTaskInput[];
      connectOrCreate?:
         | TaskDependencyCreateOrConnectWithoutTaskInput
         | TaskDependencyCreateOrConnectWithoutTaskInput[];
      upsert?:
         | TaskDependencyUpsertWithWhereUniqueWithoutTaskInput
         | TaskDependencyUpsertWithWhereUniqueWithoutTaskInput[];
      createMany?: TaskDependencyCreateManyTaskInputEnvelope;
      set?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
      disconnect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
      delete?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
      connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
      update?:
         | TaskDependencyUpdateWithWhereUniqueWithoutTaskInput
         | TaskDependencyUpdateWithWhereUniqueWithoutTaskInput[];
      updateMany?:
         | TaskDependencyUpdateManyWithWhereWithoutTaskInput
         | TaskDependencyUpdateManyWithWhereWithoutTaskInput[];
      deleteMany?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[];
   };

   export type TaskDependencyUncheckedUpdateManyWithoutDependsOnNestedInput = {
      create?:
         | XOR<
              TaskDependencyCreateWithoutDependsOnInput,
              TaskDependencyUncheckedCreateWithoutDependsOnInput
           >
         | TaskDependencyCreateWithoutDependsOnInput[]
         | TaskDependencyUncheckedCreateWithoutDependsOnInput[];
      connectOrCreate?:
         | TaskDependencyCreateOrConnectWithoutDependsOnInput
         | TaskDependencyCreateOrConnectWithoutDependsOnInput[];
      upsert?:
         | TaskDependencyUpsertWithWhereUniqueWithoutDependsOnInput
         | TaskDependencyUpsertWithWhereUniqueWithoutDependsOnInput[];
      createMany?: TaskDependencyCreateManyDependsOnInputEnvelope;
      set?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
      disconnect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
      delete?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
      connect?: TaskDependencyWhereUniqueInput | TaskDependencyWhereUniqueInput[];
      update?:
         | TaskDependencyUpdateWithWhereUniqueWithoutDependsOnInput
         | TaskDependencyUpdateWithWhereUniqueWithoutDependsOnInput[];
      updateMany?:
         | TaskDependencyUpdateManyWithWhereWithoutDependsOnInput
         | TaskDependencyUpdateManyWithWhereWithoutDependsOnInput[];
      deleteMany?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[];
   };

   export type IssueUncheckedUpdateManyWithoutTaskNestedInput = {
      create?:
         | XOR<IssueCreateWithoutTaskInput, IssueUncheckedCreateWithoutTaskInput>
         | IssueCreateWithoutTaskInput[]
         | IssueUncheckedCreateWithoutTaskInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutTaskInput
         | IssueCreateOrConnectWithoutTaskInput[];
      upsert?:
         | IssueUpsertWithWhereUniqueWithoutTaskInput
         | IssueUpsertWithWhereUniqueWithoutTaskInput[];
      createMany?: IssueCreateManyTaskInputEnvelope;
      set?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      update?:
         | IssueUpdateWithWhereUniqueWithoutTaskInput
         | IssueUpdateWithWhereUniqueWithoutTaskInput[];
      updateMany?:
         | IssueUpdateManyWithWhereWithoutTaskInput
         | IssueUpdateManyWithWhereWithoutTaskInput[];
      deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[];
   };

   export type TaskCreateNestedOneWithoutSubtasksInput = {
      create?: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>;
      connectOrCreate?: TaskCreateOrConnectWithoutSubtasksInput;
      connect?: TaskWhereUniqueInput;
   };

   export type TaskUpdateOneRequiredWithoutSubtasksNestedInput = {
      create?: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>;
      connectOrCreate?: TaskCreateOrConnectWithoutSubtasksInput;
      upsert?: TaskUpsertWithoutSubtasksInput;
      connect?: TaskWhereUniqueInput;
      update?: XOR<
         XOR<TaskUpdateToOneWithWhereWithoutSubtasksInput, TaskUpdateWithoutSubtasksInput>,
         TaskUncheckedUpdateWithoutSubtasksInput
      >;
   };

   export type TaskCreateNestedOneWithoutDependenciesInput = {
      create?: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput>;
      connectOrCreate?: TaskCreateOrConnectWithoutDependenciesInput;
      connect?: TaskWhereUniqueInput;
   };

   export type TaskCreateNestedOneWithoutDependentsInput = {
      create?: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>;
      connectOrCreate?: TaskCreateOrConnectWithoutDependentsInput;
      connect?: TaskWhereUniqueInput;
   };

   export type TaskUpdateOneRequiredWithoutDependenciesNestedInput = {
      create?: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput>;
      connectOrCreate?: TaskCreateOrConnectWithoutDependenciesInput;
      upsert?: TaskUpsertWithoutDependenciesInput;
      connect?: TaskWhereUniqueInput;
      update?: XOR<
         XOR<TaskUpdateToOneWithWhereWithoutDependenciesInput, TaskUpdateWithoutDependenciesInput>,
         TaskUncheckedUpdateWithoutDependenciesInput
      >;
   };

   export type TaskUpdateOneRequiredWithoutDependentsNestedInput = {
      create?: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>;
      connectOrCreate?: TaskCreateOrConnectWithoutDependentsInput;
      upsert?: TaskUpsertWithoutDependentsInput;
      connect?: TaskWhereUniqueInput;
      update?: XOR<
         XOR<TaskUpdateToOneWithWhereWithoutDependentsInput, TaskUpdateWithoutDependentsInput>,
         TaskUncheckedUpdateWithoutDependentsInput
      >;
   };

   export type NullableDateTimeFieldUpdateOperationsInput = {
      set?: Date | string | null;
   };

   export type BoolFieldUpdateOperationsInput = {
      set?: boolean;
   };

   export type IssueCreateNestedManyWithoutAssigneeInput = {
      create?:
         | XOR<IssueCreateWithoutAssigneeInput, IssueUncheckedCreateWithoutAssigneeInput>
         | IssueCreateWithoutAssigneeInput[]
         | IssueUncheckedCreateWithoutAssigneeInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutAssigneeInput
         | IssueCreateOrConnectWithoutAssigneeInput[];
      createMany?: IssueCreateManyAssigneeInputEnvelope;
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
   };

   export type TeamMemberCreateNestedManyWithoutUserInput = {
      create?:
         | XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
         | TeamMemberCreateWithoutUserInput[]
         | TeamMemberUncheckedCreateWithoutUserInput[];
      connectOrCreate?:
         | TeamMemberCreateOrConnectWithoutUserInput
         | TeamMemberCreateOrConnectWithoutUserInput[];
      createMany?: TeamMemberCreateManyUserInputEnvelope;
      connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
   };

   export type ProjectCreateNestedManyWithoutLeadInput = {
      create?:
         | XOR<ProjectCreateWithoutLeadInput, ProjectUncheckedCreateWithoutLeadInput>
         | ProjectCreateWithoutLeadInput[]
         | ProjectUncheckedCreateWithoutLeadInput[];
      connectOrCreate?:
         | ProjectCreateOrConnectWithoutLeadInput
         | ProjectCreateOrConnectWithoutLeadInput[];
      createMany?: ProjectCreateManyLeadInputEnvelope;
      connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
   };

   export type IssueUncheckedCreateNestedManyWithoutAssigneeInput = {
      create?:
         | XOR<IssueCreateWithoutAssigneeInput, IssueUncheckedCreateWithoutAssigneeInput>
         | IssueCreateWithoutAssigneeInput[]
         | IssueUncheckedCreateWithoutAssigneeInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutAssigneeInput
         | IssueCreateOrConnectWithoutAssigneeInput[];
      createMany?: IssueCreateManyAssigneeInputEnvelope;
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
   };

   export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
      create?:
         | XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
         | TeamMemberCreateWithoutUserInput[]
         | TeamMemberUncheckedCreateWithoutUserInput[];
      connectOrCreate?:
         | TeamMemberCreateOrConnectWithoutUserInput
         | TeamMemberCreateOrConnectWithoutUserInput[];
      createMany?: TeamMemberCreateManyUserInputEnvelope;
      connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
   };

   export type ProjectUncheckedCreateNestedManyWithoutLeadInput = {
      create?:
         | XOR<ProjectCreateWithoutLeadInput, ProjectUncheckedCreateWithoutLeadInput>
         | ProjectCreateWithoutLeadInput[]
         | ProjectUncheckedCreateWithoutLeadInput[];
      connectOrCreate?:
         | ProjectCreateOrConnectWithoutLeadInput
         | ProjectCreateOrConnectWithoutLeadInput[];
      createMany?: ProjectCreateManyLeadInputEnvelope;
      connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
   };

   export type EnumUserStatusFieldUpdateOperationsInput = {
      set?: $Enums.UserStatus;
   };

   export type EnumUserRoleFieldUpdateOperationsInput = {
      set?: $Enums.UserRole;
   };

   export type IssueUpdateManyWithoutAssigneeNestedInput = {
      create?:
         | XOR<IssueCreateWithoutAssigneeInput, IssueUncheckedCreateWithoutAssigneeInput>
         | IssueCreateWithoutAssigneeInput[]
         | IssueUncheckedCreateWithoutAssigneeInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutAssigneeInput
         | IssueCreateOrConnectWithoutAssigneeInput[];
      upsert?:
         | IssueUpsertWithWhereUniqueWithoutAssigneeInput
         | IssueUpsertWithWhereUniqueWithoutAssigneeInput[];
      createMany?: IssueCreateManyAssigneeInputEnvelope;
      set?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      update?:
         | IssueUpdateWithWhereUniqueWithoutAssigneeInput
         | IssueUpdateWithWhereUniqueWithoutAssigneeInput[];
      updateMany?:
         | IssueUpdateManyWithWhereWithoutAssigneeInput
         | IssueUpdateManyWithWhereWithoutAssigneeInput[];
      deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[];
   };

   export type TeamMemberUpdateManyWithoutUserNestedInput = {
      create?:
         | XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
         | TeamMemberCreateWithoutUserInput[]
         | TeamMemberUncheckedCreateWithoutUserInput[];
      connectOrCreate?:
         | TeamMemberCreateOrConnectWithoutUserInput
         | TeamMemberCreateOrConnectWithoutUserInput[];
      upsert?:
         | TeamMemberUpsertWithWhereUniqueWithoutUserInput
         | TeamMemberUpsertWithWhereUniqueWithoutUserInput[];
      createMany?: TeamMemberCreateManyUserInputEnvelope;
      set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
      disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
      delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
      connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
      update?:
         | TeamMemberUpdateWithWhereUniqueWithoutUserInput
         | TeamMemberUpdateWithWhereUniqueWithoutUserInput[];
      updateMany?:
         | TeamMemberUpdateManyWithWhereWithoutUserInput
         | TeamMemberUpdateManyWithWhereWithoutUserInput[];
      deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
   };

   export type ProjectUpdateManyWithoutLeadNestedInput = {
      create?:
         | XOR<ProjectCreateWithoutLeadInput, ProjectUncheckedCreateWithoutLeadInput>
         | ProjectCreateWithoutLeadInput[]
         | ProjectUncheckedCreateWithoutLeadInput[];
      connectOrCreate?:
         | ProjectCreateOrConnectWithoutLeadInput
         | ProjectCreateOrConnectWithoutLeadInput[];
      upsert?:
         | ProjectUpsertWithWhereUniqueWithoutLeadInput
         | ProjectUpsertWithWhereUniqueWithoutLeadInput[];
      createMany?: ProjectCreateManyLeadInputEnvelope;
      set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
      disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
      delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
      connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
      update?:
         | ProjectUpdateWithWhereUniqueWithoutLeadInput
         | ProjectUpdateWithWhereUniqueWithoutLeadInput[];
      updateMany?:
         | ProjectUpdateManyWithWhereWithoutLeadInput
         | ProjectUpdateManyWithWhereWithoutLeadInput[];
      deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[];
   };

   export type IssueUncheckedUpdateManyWithoutAssigneeNestedInput = {
      create?:
         | XOR<IssueCreateWithoutAssigneeInput, IssueUncheckedCreateWithoutAssigneeInput>
         | IssueCreateWithoutAssigneeInput[]
         | IssueUncheckedCreateWithoutAssigneeInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutAssigneeInput
         | IssueCreateOrConnectWithoutAssigneeInput[];
      upsert?:
         | IssueUpsertWithWhereUniqueWithoutAssigneeInput
         | IssueUpsertWithWhereUniqueWithoutAssigneeInput[];
      createMany?: IssueCreateManyAssigneeInputEnvelope;
      set?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      update?:
         | IssueUpdateWithWhereUniqueWithoutAssigneeInput
         | IssueUpdateWithWhereUniqueWithoutAssigneeInput[];
      updateMany?:
         | IssueUpdateManyWithWhereWithoutAssigneeInput
         | IssueUpdateManyWithWhereWithoutAssigneeInput[];
      deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[];
   };

   export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
      create?:
         | XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
         | TeamMemberCreateWithoutUserInput[]
         | TeamMemberUncheckedCreateWithoutUserInput[];
      connectOrCreate?:
         | TeamMemberCreateOrConnectWithoutUserInput
         | TeamMemberCreateOrConnectWithoutUserInput[];
      upsert?:
         | TeamMemberUpsertWithWhereUniqueWithoutUserInput
         | TeamMemberUpsertWithWhereUniqueWithoutUserInput[];
      createMany?: TeamMemberCreateManyUserInputEnvelope;
      set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
      disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
      delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
      connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
      update?:
         | TeamMemberUpdateWithWhereUniqueWithoutUserInput
         | TeamMemberUpdateWithWhereUniqueWithoutUserInput[];
      updateMany?:
         | TeamMemberUpdateManyWithWhereWithoutUserInput
         | TeamMemberUpdateManyWithWhereWithoutUserInput[];
      deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
   };

   export type ProjectUncheckedUpdateManyWithoutLeadNestedInput = {
      create?:
         | XOR<ProjectCreateWithoutLeadInput, ProjectUncheckedCreateWithoutLeadInput>
         | ProjectCreateWithoutLeadInput[]
         | ProjectUncheckedCreateWithoutLeadInput[];
      connectOrCreate?:
         | ProjectCreateOrConnectWithoutLeadInput
         | ProjectCreateOrConnectWithoutLeadInput[];
      upsert?:
         | ProjectUpsertWithWhereUniqueWithoutLeadInput
         | ProjectUpsertWithWhereUniqueWithoutLeadInput[];
      createMany?: ProjectCreateManyLeadInputEnvelope;
      set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
      disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
      delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
      connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[];
      update?:
         | ProjectUpdateWithWhereUniqueWithoutLeadInput
         | ProjectUpdateWithWhereUniqueWithoutLeadInput[];
      updateMany?:
         | ProjectUpdateManyWithWhereWithoutLeadInput
         | ProjectUpdateManyWithWhereWithoutLeadInput[];
      deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[];
   };

   export type IssueCreateNestedManyWithoutProjectInput = {
      create?:
         | XOR<IssueCreateWithoutProjectInput, IssueUncheckedCreateWithoutProjectInput>
         | IssueCreateWithoutProjectInput[]
         | IssueUncheckedCreateWithoutProjectInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutProjectInput
         | IssueCreateOrConnectWithoutProjectInput[];
      createMany?: IssueCreateManyProjectInputEnvelope;
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
   };

   export type UserCreateNestedOneWithoutLedProjectsInput = {
      create?: XOR<UserCreateWithoutLedProjectsInput, UserUncheckedCreateWithoutLedProjectsInput>;
      connectOrCreate?: UserCreateOrConnectWithoutLedProjectsInput;
      connect?: UserWhereUniqueInput;
   };

   export type TeamProjectCreateNestedManyWithoutProjectInput = {
      create?:
         | XOR<TeamProjectCreateWithoutProjectInput, TeamProjectUncheckedCreateWithoutProjectInput>
         | TeamProjectCreateWithoutProjectInput[]
         | TeamProjectUncheckedCreateWithoutProjectInput[];
      connectOrCreate?:
         | TeamProjectCreateOrConnectWithoutProjectInput
         | TeamProjectCreateOrConnectWithoutProjectInput[];
      createMany?: TeamProjectCreateManyProjectInputEnvelope;
      connect?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
   };

   export type IssueUncheckedCreateNestedManyWithoutProjectInput = {
      create?:
         | XOR<IssueCreateWithoutProjectInput, IssueUncheckedCreateWithoutProjectInput>
         | IssueCreateWithoutProjectInput[]
         | IssueUncheckedCreateWithoutProjectInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutProjectInput
         | IssueCreateOrConnectWithoutProjectInput[];
      createMany?: IssueCreateManyProjectInputEnvelope;
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
   };

   export type TeamProjectUncheckedCreateNestedManyWithoutProjectInput = {
      create?:
         | XOR<TeamProjectCreateWithoutProjectInput, TeamProjectUncheckedCreateWithoutProjectInput>
         | TeamProjectCreateWithoutProjectInput[]
         | TeamProjectUncheckedCreateWithoutProjectInput[];
      connectOrCreate?:
         | TeamProjectCreateOrConnectWithoutProjectInput
         | TeamProjectCreateOrConnectWithoutProjectInput[];
      createMany?: TeamProjectCreateManyProjectInputEnvelope;
      connect?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
   };

   export type EnumProjectHealthFieldUpdateOperationsInput = {
      set?: $Enums.ProjectHealth;
   };

   export type IssueUpdateManyWithoutProjectNestedInput = {
      create?:
         | XOR<IssueCreateWithoutProjectInput, IssueUncheckedCreateWithoutProjectInput>
         | IssueCreateWithoutProjectInput[]
         | IssueUncheckedCreateWithoutProjectInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutProjectInput
         | IssueCreateOrConnectWithoutProjectInput[];
      upsert?:
         | IssueUpsertWithWhereUniqueWithoutProjectInput
         | IssueUpsertWithWhereUniqueWithoutProjectInput[];
      createMany?: IssueCreateManyProjectInputEnvelope;
      set?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      update?:
         | IssueUpdateWithWhereUniqueWithoutProjectInput
         | IssueUpdateWithWhereUniqueWithoutProjectInput[];
      updateMany?:
         | IssueUpdateManyWithWhereWithoutProjectInput
         | IssueUpdateManyWithWhereWithoutProjectInput[];
      deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[];
   };

   export type UserUpdateOneWithoutLedProjectsNestedInput = {
      create?: XOR<UserCreateWithoutLedProjectsInput, UserUncheckedCreateWithoutLedProjectsInput>;
      connectOrCreate?: UserCreateOrConnectWithoutLedProjectsInput;
      upsert?: UserUpsertWithoutLedProjectsInput;
      disconnect?: UserWhereInput | boolean;
      delete?: UserWhereInput | boolean;
      connect?: UserWhereUniqueInput;
      update?: XOR<
         XOR<UserUpdateToOneWithWhereWithoutLedProjectsInput, UserUpdateWithoutLedProjectsInput>,
         UserUncheckedUpdateWithoutLedProjectsInput
      >;
   };

   export type TeamProjectUpdateManyWithoutProjectNestedInput = {
      create?:
         | XOR<TeamProjectCreateWithoutProjectInput, TeamProjectUncheckedCreateWithoutProjectInput>
         | TeamProjectCreateWithoutProjectInput[]
         | TeamProjectUncheckedCreateWithoutProjectInput[];
      connectOrCreate?:
         | TeamProjectCreateOrConnectWithoutProjectInput
         | TeamProjectCreateOrConnectWithoutProjectInput[];
      upsert?:
         | TeamProjectUpsertWithWhereUniqueWithoutProjectInput
         | TeamProjectUpsertWithWhereUniqueWithoutProjectInput[];
      createMany?: TeamProjectCreateManyProjectInputEnvelope;
      set?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
      disconnect?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
      delete?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
      connect?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
      update?:
         | TeamProjectUpdateWithWhereUniqueWithoutProjectInput
         | TeamProjectUpdateWithWhereUniqueWithoutProjectInput[];
      updateMany?:
         | TeamProjectUpdateManyWithWhereWithoutProjectInput
         | TeamProjectUpdateManyWithWhereWithoutProjectInput[];
      deleteMany?: TeamProjectScalarWhereInput | TeamProjectScalarWhereInput[];
   };

   export type IssueUncheckedUpdateManyWithoutProjectNestedInput = {
      create?:
         | XOR<IssueCreateWithoutProjectInput, IssueUncheckedCreateWithoutProjectInput>
         | IssueCreateWithoutProjectInput[]
         | IssueUncheckedCreateWithoutProjectInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutProjectInput
         | IssueCreateOrConnectWithoutProjectInput[];
      upsert?:
         | IssueUpsertWithWhereUniqueWithoutProjectInput
         | IssueUpsertWithWhereUniqueWithoutProjectInput[];
      createMany?: IssueCreateManyProjectInputEnvelope;
      set?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      update?:
         | IssueUpdateWithWhereUniqueWithoutProjectInput
         | IssueUpdateWithWhereUniqueWithoutProjectInput[];
      updateMany?:
         | IssueUpdateManyWithWhereWithoutProjectInput
         | IssueUpdateManyWithWhereWithoutProjectInput[];
      deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[];
   };

   export type TeamProjectUncheckedUpdateManyWithoutProjectNestedInput = {
      create?:
         | XOR<TeamProjectCreateWithoutProjectInput, TeamProjectUncheckedCreateWithoutProjectInput>
         | TeamProjectCreateWithoutProjectInput[]
         | TeamProjectUncheckedCreateWithoutProjectInput[];
      connectOrCreate?:
         | TeamProjectCreateOrConnectWithoutProjectInput
         | TeamProjectCreateOrConnectWithoutProjectInput[];
      upsert?:
         | TeamProjectUpsertWithWhereUniqueWithoutProjectInput
         | TeamProjectUpsertWithWhereUniqueWithoutProjectInput[];
      createMany?: TeamProjectCreateManyProjectInputEnvelope;
      set?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
      disconnect?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
      delete?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
      connect?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
      update?:
         | TeamProjectUpdateWithWhereUniqueWithoutProjectInput
         | TeamProjectUpdateWithWhereUniqueWithoutProjectInput[];
      updateMany?:
         | TeamProjectUpdateManyWithWhereWithoutProjectInput
         | TeamProjectUpdateManyWithWhereWithoutProjectInput[];
      deleteMany?: TeamProjectScalarWhereInput | TeamProjectScalarWhereInput[];
   };

   export type IssueLabelCreateNestedManyWithoutLabelInput = {
      create?:
         | XOR<IssueLabelCreateWithoutLabelInput, IssueLabelUncheckedCreateWithoutLabelInput>
         | IssueLabelCreateWithoutLabelInput[]
         | IssueLabelUncheckedCreateWithoutLabelInput[];
      connectOrCreate?:
         | IssueLabelCreateOrConnectWithoutLabelInput
         | IssueLabelCreateOrConnectWithoutLabelInput[];
      createMany?: IssueLabelCreateManyLabelInputEnvelope;
      connect?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
   };

   export type IssueLabelUncheckedCreateNestedManyWithoutLabelInput = {
      create?:
         | XOR<IssueLabelCreateWithoutLabelInput, IssueLabelUncheckedCreateWithoutLabelInput>
         | IssueLabelCreateWithoutLabelInput[]
         | IssueLabelUncheckedCreateWithoutLabelInput[];
      connectOrCreate?:
         | IssueLabelCreateOrConnectWithoutLabelInput
         | IssueLabelCreateOrConnectWithoutLabelInput[];
      createMany?: IssueLabelCreateManyLabelInputEnvelope;
      connect?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
   };

   export type IssueLabelUpdateManyWithoutLabelNestedInput = {
      create?:
         | XOR<IssueLabelCreateWithoutLabelInput, IssueLabelUncheckedCreateWithoutLabelInput>
         | IssueLabelCreateWithoutLabelInput[]
         | IssueLabelUncheckedCreateWithoutLabelInput[];
      connectOrCreate?:
         | IssueLabelCreateOrConnectWithoutLabelInput
         | IssueLabelCreateOrConnectWithoutLabelInput[];
      upsert?:
         | IssueLabelUpsertWithWhereUniqueWithoutLabelInput
         | IssueLabelUpsertWithWhereUniqueWithoutLabelInput[];
      createMany?: IssueLabelCreateManyLabelInputEnvelope;
      set?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
      disconnect?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
      delete?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
      connect?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
      update?:
         | IssueLabelUpdateWithWhereUniqueWithoutLabelInput
         | IssueLabelUpdateWithWhereUniqueWithoutLabelInput[];
      updateMany?:
         | IssueLabelUpdateManyWithWhereWithoutLabelInput
         | IssueLabelUpdateManyWithWhereWithoutLabelInput[];
      deleteMany?: IssueLabelScalarWhereInput | IssueLabelScalarWhereInput[];
   };

   export type IssueLabelUncheckedUpdateManyWithoutLabelNestedInput = {
      create?:
         | XOR<IssueLabelCreateWithoutLabelInput, IssueLabelUncheckedCreateWithoutLabelInput>
         | IssueLabelCreateWithoutLabelInput[]
         | IssueLabelUncheckedCreateWithoutLabelInput[];
      connectOrCreate?:
         | IssueLabelCreateOrConnectWithoutLabelInput
         | IssueLabelCreateOrConnectWithoutLabelInput[];
      upsert?:
         | IssueLabelUpsertWithWhereUniqueWithoutLabelInput
         | IssueLabelUpsertWithWhereUniqueWithoutLabelInput[];
      createMany?: IssueLabelCreateManyLabelInputEnvelope;
      set?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
      disconnect?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
      delete?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
      connect?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
      update?:
         | IssueLabelUpdateWithWhereUniqueWithoutLabelInput
         | IssueLabelUpdateWithWhereUniqueWithoutLabelInput[];
      updateMany?:
         | IssueLabelUpdateManyWithWhereWithoutLabelInput
         | IssueLabelUpdateManyWithWhereWithoutLabelInput[];
      deleteMany?: IssueLabelScalarWhereInput | IssueLabelScalarWhereInput[];
   };

   export type IssueCreateNestedManyWithoutIssueStatusInput = {
      create?:
         | XOR<IssueCreateWithoutIssueStatusInput, IssueUncheckedCreateWithoutIssueStatusInput>
         | IssueCreateWithoutIssueStatusInput[]
         | IssueUncheckedCreateWithoutIssueStatusInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutIssueStatusInput
         | IssueCreateOrConnectWithoutIssueStatusInput[];
      createMany?: IssueCreateManyIssueStatusInputEnvelope;
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
   };

   export type IssueUncheckedCreateNestedManyWithoutIssueStatusInput = {
      create?:
         | XOR<IssueCreateWithoutIssueStatusInput, IssueUncheckedCreateWithoutIssueStatusInput>
         | IssueCreateWithoutIssueStatusInput[]
         | IssueUncheckedCreateWithoutIssueStatusInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutIssueStatusInput
         | IssueCreateOrConnectWithoutIssueStatusInput[];
      createMany?: IssueCreateManyIssueStatusInputEnvelope;
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
   };

   export type IssueUpdateManyWithoutIssueStatusNestedInput = {
      create?:
         | XOR<IssueCreateWithoutIssueStatusInput, IssueUncheckedCreateWithoutIssueStatusInput>
         | IssueCreateWithoutIssueStatusInput[]
         | IssueUncheckedCreateWithoutIssueStatusInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutIssueStatusInput
         | IssueCreateOrConnectWithoutIssueStatusInput[];
      upsert?:
         | IssueUpsertWithWhereUniqueWithoutIssueStatusInput
         | IssueUpsertWithWhereUniqueWithoutIssueStatusInput[];
      createMany?: IssueCreateManyIssueStatusInputEnvelope;
      set?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      update?:
         | IssueUpdateWithWhereUniqueWithoutIssueStatusInput
         | IssueUpdateWithWhereUniqueWithoutIssueStatusInput[];
      updateMany?:
         | IssueUpdateManyWithWhereWithoutIssueStatusInput
         | IssueUpdateManyWithWhereWithoutIssueStatusInput[];
      deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[];
   };

   export type IssueUncheckedUpdateManyWithoutIssueStatusNestedInput = {
      create?:
         | XOR<IssueCreateWithoutIssueStatusInput, IssueUncheckedCreateWithoutIssueStatusInput>
         | IssueCreateWithoutIssueStatusInput[]
         | IssueUncheckedCreateWithoutIssueStatusInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutIssueStatusInput
         | IssueCreateOrConnectWithoutIssueStatusInput[];
      upsert?:
         | IssueUpsertWithWhereUniqueWithoutIssueStatusInput
         | IssueUpsertWithWhereUniqueWithoutIssueStatusInput[];
      createMany?: IssueCreateManyIssueStatusInputEnvelope;
      set?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      update?:
         | IssueUpdateWithWhereUniqueWithoutIssueStatusInput
         | IssueUpdateWithWhereUniqueWithoutIssueStatusInput[];
      updateMany?:
         | IssueUpdateManyWithWhereWithoutIssueStatusInput
         | IssueUpdateManyWithWhereWithoutIssueStatusInput[];
      deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[];
   };

   export type IssueCreateNestedManyWithoutIssuePriorityInput = {
      create?:
         | XOR<IssueCreateWithoutIssuePriorityInput, IssueUncheckedCreateWithoutIssuePriorityInput>
         | IssueCreateWithoutIssuePriorityInput[]
         | IssueUncheckedCreateWithoutIssuePriorityInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutIssuePriorityInput
         | IssueCreateOrConnectWithoutIssuePriorityInput[];
      createMany?: IssueCreateManyIssuePriorityInputEnvelope;
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
   };

   export type IssueUncheckedCreateNestedManyWithoutIssuePriorityInput = {
      create?:
         | XOR<IssueCreateWithoutIssuePriorityInput, IssueUncheckedCreateWithoutIssuePriorityInput>
         | IssueCreateWithoutIssuePriorityInput[]
         | IssueUncheckedCreateWithoutIssuePriorityInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutIssuePriorityInput
         | IssueCreateOrConnectWithoutIssuePriorityInput[];
      createMany?: IssueCreateManyIssuePriorityInputEnvelope;
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
   };

   export type IssueUpdateManyWithoutIssuePriorityNestedInput = {
      create?:
         | XOR<IssueCreateWithoutIssuePriorityInput, IssueUncheckedCreateWithoutIssuePriorityInput>
         | IssueCreateWithoutIssuePriorityInput[]
         | IssueUncheckedCreateWithoutIssuePriorityInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutIssuePriorityInput
         | IssueCreateOrConnectWithoutIssuePriorityInput[];
      upsert?:
         | IssueUpsertWithWhereUniqueWithoutIssuePriorityInput
         | IssueUpsertWithWhereUniqueWithoutIssuePriorityInput[];
      createMany?: IssueCreateManyIssuePriorityInputEnvelope;
      set?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      update?:
         | IssueUpdateWithWhereUniqueWithoutIssuePriorityInput
         | IssueUpdateWithWhereUniqueWithoutIssuePriorityInput[];
      updateMany?:
         | IssueUpdateManyWithWhereWithoutIssuePriorityInput
         | IssueUpdateManyWithWhereWithoutIssuePriorityInput[];
      deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[];
   };

   export type IssueUncheckedUpdateManyWithoutIssuePriorityNestedInput = {
      create?:
         | XOR<IssueCreateWithoutIssuePriorityInput, IssueUncheckedCreateWithoutIssuePriorityInput>
         | IssueCreateWithoutIssuePriorityInput[]
         | IssueUncheckedCreateWithoutIssuePriorityInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutIssuePriorityInput
         | IssueCreateOrConnectWithoutIssuePriorityInput[];
      upsert?:
         | IssueUpsertWithWhereUniqueWithoutIssuePriorityInput
         | IssueUpsertWithWhereUniqueWithoutIssuePriorityInput[];
      createMany?: IssueCreateManyIssuePriorityInputEnvelope;
      set?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      update?:
         | IssueUpdateWithWhereUniqueWithoutIssuePriorityInput
         | IssueUpdateWithWhereUniqueWithoutIssuePriorityInput[];
      updateMany?:
         | IssueUpdateManyWithWhereWithoutIssuePriorityInput
         | IssueUpdateManyWithWhereWithoutIssuePriorityInput[];
      deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[];
   };

   export type UserCreateNestedOneWithoutAssignedIssuesInput = {
      create?: XOR<
         UserCreateWithoutAssignedIssuesInput,
         UserUncheckedCreateWithoutAssignedIssuesInput
      >;
      connectOrCreate?: UserCreateOrConnectWithoutAssignedIssuesInput;
      connect?: UserWhereUniqueInput;
   };

   export type ProjectCreateNestedOneWithoutIssuesInput = {
      create?: XOR<ProjectCreateWithoutIssuesInput, ProjectUncheckedCreateWithoutIssuesInput>;
      connectOrCreate?: ProjectCreateOrConnectWithoutIssuesInput;
      connect?: ProjectWhereUniqueInput;
   };

   export type CycleCreateNestedOneWithoutIssuesInput = {
      create?: XOR<CycleCreateWithoutIssuesInput, CycleUncheckedCreateWithoutIssuesInput>;
      connectOrCreate?: CycleCreateOrConnectWithoutIssuesInput;
      connect?: CycleWhereUniqueInput;
   };

   export type TaskCreateNestedOneWithoutIssuesInput = {
      create?: XOR<TaskCreateWithoutIssuesInput, TaskUncheckedCreateWithoutIssuesInput>;
      connectOrCreate?: TaskCreateOrConnectWithoutIssuesInput;
      connect?: TaskWhereUniqueInput;
   };

   export type IssueStatusCreateNestedOneWithoutIssuesInput = {
      create?: XOR<
         IssueStatusCreateWithoutIssuesInput,
         IssueStatusUncheckedCreateWithoutIssuesInput
      >;
      connectOrCreate?: IssueStatusCreateOrConnectWithoutIssuesInput;
      connect?: IssueStatusWhereUniqueInput;
   };

   export type IssuePriorityCreateNestedOneWithoutIssuesInput = {
      create?: XOR<
         IssuePriorityCreateWithoutIssuesInput,
         IssuePriorityUncheckedCreateWithoutIssuesInput
      >;
      connectOrCreate?: IssuePriorityCreateOrConnectWithoutIssuesInput;
      connect?: IssuePriorityWhereUniqueInput;
   };

   export type IssueLabelCreateNestedManyWithoutIssueInput = {
      create?:
         | XOR<IssueLabelCreateWithoutIssueInput, IssueLabelUncheckedCreateWithoutIssueInput>
         | IssueLabelCreateWithoutIssueInput[]
         | IssueLabelUncheckedCreateWithoutIssueInput[];
      connectOrCreate?:
         | IssueLabelCreateOrConnectWithoutIssueInput
         | IssueLabelCreateOrConnectWithoutIssueInput[];
      createMany?: IssueLabelCreateManyIssueInputEnvelope;
      connect?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
   };

   export type IssueLabelUncheckedCreateNestedManyWithoutIssueInput = {
      create?:
         | XOR<IssueLabelCreateWithoutIssueInput, IssueLabelUncheckedCreateWithoutIssueInput>
         | IssueLabelCreateWithoutIssueInput[]
         | IssueLabelUncheckedCreateWithoutIssueInput[];
      connectOrCreate?:
         | IssueLabelCreateOrConnectWithoutIssueInput
         | IssueLabelCreateOrConnectWithoutIssueInput[];
      createMany?: IssueLabelCreateManyIssueInputEnvelope;
      connect?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
   };

   export type EnumIssueTypeFieldUpdateOperationsInput = {
      set?: $Enums.IssueType;
   };

   export type UserUpdateOneWithoutAssignedIssuesNestedInput = {
      create?: XOR<
         UserCreateWithoutAssignedIssuesInput,
         UserUncheckedCreateWithoutAssignedIssuesInput
      >;
      connectOrCreate?: UserCreateOrConnectWithoutAssignedIssuesInput;
      upsert?: UserUpsertWithoutAssignedIssuesInput;
      disconnect?: UserWhereInput | boolean;
      delete?: UserWhereInput | boolean;
      connect?: UserWhereUniqueInput;
      update?: XOR<
         XOR<
            UserUpdateToOneWithWhereWithoutAssignedIssuesInput,
            UserUpdateWithoutAssignedIssuesInput
         >,
         UserUncheckedUpdateWithoutAssignedIssuesInput
      >;
   };

   export type ProjectUpdateOneWithoutIssuesNestedInput = {
      create?: XOR<ProjectCreateWithoutIssuesInput, ProjectUncheckedCreateWithoutIssuesInput>;
      connectOrCreate?: ProjectCreateOrConnectWithoutIssuesInput;
      upsert?: ProjectUpsertWithoutIssuesInput;
      disconnect?: ProjectWhereInput | boolean;
      delete?: ProjectWhereInput | boolean;
      connect?: ProjectWhereUniqueInput;
      update?: XOR<
         XOR<ProjectUpdateToOneWithWhereWithoutIssuesInput, ProjectUpdateWithoutIssuesInput>,
         ProjectUncheckedUpdateWithoutIssuesInput
      >;
   };

   export type CycleUpdateOneWithoutIssuesNestedInput = {
      create?: XOR<CycleCreateWithoutIssuesInput, CycleUncheckedCreateWithoutIssuesInput>;
      connectOrCreate?: CycleCreateOrConnectWithoutIssuesInput;
      upsert?: CycleUpsertWithoutIssuesInput;
      disconnect?: CycleWhereInput | boolean;
      delete?: CycleWhereInput | boolean;
      connect?: CycleWhereUniqueInput;
      update?: XOR<
         XOR<CycleUpdateToOneWithWhereWithoutIssuesInput, CycleUpdateWithoutIssuesInput>,
         CycleUncheckedUpdateWithoutIssuesInput
      >;
   };

   export type TaskUpdateOneWithoutIssuesNestedInput = {
      create?: XOR<TaskCreateWithoutIssuesInput, TaskUncheckedCreateWithoutIssuesInput>;
      connectOrCreate?: TaskCreateOrConnectWithoutIssuesInput;
      upsert?: TaskUpsertWithoutIssuesInput;
      disconnect?: TaskWhereInput | boolean;
      delete?: TaskWhereInput | boolean;
      connect?: TaskWhereUniqueInput;
      update?: XOR<
         XOR<TaskUpdateToOneWithWhereWithoutIssuesInput, TaskUpdateWithoutIssuesInput>,
         TaskUncheckedUpdateWithoutIssuesInput
      >;
   };

   export type IssueStatusUpdateOneWithoutIssuesNestedInput = {
      create?: XOR<
         IssueStatusCreateWithoutIssuesInput,
         IssueStatusUncheckedCreateWithoutIssuesInput
      >;
      connectOrCreate?: IssueStatusCreateOrConnectWithoutIssuesInput;
      upsert?: IssueStatusUpsertWithoutIssuesInput;
      disconnect?: IssueStatusWhereInput | boolean;
      delete?: IssueStatusWhereInput | boolean;
      connect?: IssueStatusWhereUniqueInput;
      update?: XOR<
         XOR<
            IssueStatusUpdateToOneWithWhereWithoutIssuesInput,
            IssueStatusUpdateWithoutIssuesInput
         >,
         IssueStatusUncheckedUpdateWithoutIssuesInput
      >;
   };

   export type IssuePriorityUpdateOneWithoutIssuesNestedInput = {
      create?: XOR<
         IssuePriorityCreateWithoutIssuesInput,
         IssuePriorityUncheckedCreateWithoutIssuesInput
      >;
      connectOrCreate?: IssuePriorityCreateOrConnectWithoutIssuesInput;
      upsert?: IssuePriorityUpsertWithoutIssuesInput;
      disconnect?: IssuePriorityWhereInput | boolean;
      delete?: IssuePriorityWhereInput | boolean;
      connect?: IssuePriorityWhereUniqueInput;
      update?: XOR<
         XOR<
            IssuePriorityUpdateToOneWithWhereWithoutIssuesInput,
            IssuePriorityUpdateWithoutIssuesInput
         >,
         IssuePriorityUncheckedUpdateWithoutIssuesInput
      >;
   };

   export type IssueLabelUpdateManyWithoutIssueNestedInput = {
      create?:
         | XOR<IssueLabelCreateWithoutIssueInput, IssueLabelUncheckedCreateWithoutIssueInput>
         | IssueLabelCreateWithoutIssueInput[]
         | IssueLabelUncheckedCreateWithoutIssueInput[];
      connectOrCreate?:
         | IssueLabelCreateOrConnectWithoutIssueInput
         | IssueLabelCreateOrConnectWithoutIssueInput[];
      upsert?:
         | IssueLabelUpsertWithWhereUniqueWithoutIssueInput
         | IssueLabelUpsertWithWhereUniqueWithoutIssueInput[];
      createMany?: IssueLabelCreateManyIssueInputEnvelope;
      set?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
      disconnect?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
      delete?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
      connect?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
      update?:
         | IssueLabelUpdateWithWhereUniqueWithoutIssueInput
         | IssueLabelUpdateWithWhereUniqueWithoutIssueInput[];
      updateMany?:
         | IssueLabelUpdateManyWithWhereWithoutIssueInput
         | IssueLabelUpdateManyWithWhereWithoutIssueInput[];
      deleteMany?: IssueLabelScalarWhereInput | IssueLabelScalarWhereInput[];
   };

   export type IssueLabelUncheckedUpdateManyWithoutIssueNestedInput = {
      create?:
         | XOR<IssueLabelCreateWithoutIssueInput, IssueLabelUncheckedCreateWithoutIssueInput>
         | IssueLabelCreateWithoutIssueInput[]
         | IssueLabelUncheckedCreateWithoutIssueInput[];
      connectOrCreate?:
         | IssueLabelCreateOrConnectWithoutIssueInput
         | IssueLabelCreateOrConnectWithoutIssueInput[];
      upsert?:
         | IssueLabelUpsertWithWhereUniqueWithoutIssueInput
         | IssueLabelUpsertWithWhereUniqueWithoutIssueInput[];
      createMany?: IssueLabelCreateManyIssueInputEnvelope;
      set?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
      disconnect?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
      delete?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
      connect?: IssueLabelWhereUniqueInput | IssueLabelWhereUniqueInput[];
      update?:
         | IssueLabelUpdateWithWhereUniqueWithoutIssueInput
         | IssueLabelUpdateWithWhereUniqueWithoutIssueInput[];
      updateMany?:
         | IssueLabelUpdateManyWithWhereWithoutIssueInput
         | IssueLabelUpdateManyWithWhereWithoutIssueInput[];
      deleteMany?: IssueLabelScalarWhereInput | IssueLabelScalarWhereInput[];
   };

   export type IssueCreateNestedOneWithoutLabelsInput = {
      create?: XOR<IssueCreateWithoutLabelsInput, IssueUncheckedCreateWithoutLabelsInput>;
      connectOrCreate?: IssueCreateOrConnectWithoutLabelsInput;
      connect?: IssueWhereUniqueInput;
   };

   export type LabelCreateNestedOneWithoutIssuesInput = {
      create?: XOR<LabelCreateWithoutIssuesInput, LabelUncheckedCreateWithoutIssuesInput>;
      connectOrCreate?: LabelCreateOrConnectWithoutIssuesInput;
      connect?: LabelWhereUniqueInput;
   };

   export type IssueUpdateOneRequiredWithoutLabelsNestedInput = {
      create?: XOR<IssueCreateWithoutLabelsInput, IssueUncheckedCreateWithoutLabelsInput>;
      connectOrCreate?: IssueCreateOrConnectWithoutLabelsInput;
      upsert?: IssueUpsertWithoutLabelsInput;
      connect?: IssueWhereUniqueInput;
      update?: XOR<
         XOR<IssueUpdateToOneWithWhereWithoutLabelsInput, IssueUpdateWithoutLabelsInput>,
         IssueUncheckedUpdateWithoutLabelsInput
      >;
   };

   export type LabelUpdateOneRequiredWithoutIssuesNestedInput = {
      create?: XOR<LabelCreateWithoutIssuesInput, LabelUncheckedCreateWithoutIssuesInput>;
      connectOrCreate?: LabelCreateOrConnectWithoutIssuesInput;
      upsert?: LabelUpsertWithoutIssuesInput;
      connect?: LabelWhereUniqueInput;
      update?: XOR<
         XOR<LabelUpdateToOneWithWhereWithoutIssuesInput, LabelUpdateWithoutIssuesInput>,
         LabelUncheckedUpdateWithoutIssuesInput
      >;
   };

   export type TeamCreateNestedOneWithoutCyclesInput = {
      create?: XOR<TeamCreateWithoutCyclesInput, TeamUncheckedCreateWithoutCyclesInput>;
      connectOrCreate?: TeamCreateOrConnectWithoutCyclesInput;
      connect?: TeamWhereUniqueInput;
   };

   export type IssueCreateNestedManyWithoutCycleInput = {
      create?:
         | XOR<IssueCreateWithoutCycleInput, IssueUncheckedCreateWithoutCycleInput>
         | IssueCreateWithoutCycleInput[]
         | IssueUncheckedCreateWithoutCycleInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutCycleInput
         | IssueCreateOrConnectWithoutCycleInput[];
      createMany?: IssueCreateManyCycleInputEnvelope;
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
   };

   export type IssueUncheckedCreateNestedManyWithoutCycleInput = {
      create?:
         | XOR<IssueCreateWithoutCycleInput, IssueUncheckedCreateWithoutCycleInput>
         | IssueCreateWithoutCycleInput[]
         | IssueUncheckedCreateWithoutCycleInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutCycleInput
         | IssueCreateOrConnectWithoutCycleInput[];
      createMany?: IssueCreateManyCycleInputEnvelope;
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
   };

   export type TeamUpdateOneRequiredWithoutCyclesNestedInput = {
      create?: XOR<TeamCreateWithoutCyclesInput, TeamUncheckedCreateWithoutCyclesInput>;
      connectOrCreate?: TeamCreateOrConnectWithoutCyclesInput;
      upsert?: TeamUpsertWithoutCyclesInput;
      connect?: TeamWhereUniqueInput;
      update?: XOR<
         XOR<TeamUpdateToOneWithWhereWithoutCyclesInput, TeamUpdateWithoutCyclesInput>,
         TeamUncheckedUpdateWithoutCyclesInput
      >;
   };

   export type IssueUpdateManyWithoutCycleNestedInput = {
      create?:
         | XOR<IssueCreateWithoutCycleInput, IssueUncheckedCreateWithoutCycleInput>
         | IssueCreateWithoutCycleInput[]
         | IssueUncheckedCreateWithoutCycleInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutCycleInput
         | IssueCreateOrConnectWithoutCycleInput[];
      upsert?:
         | IssueUpsertWithWhereUniqueWithoutCycleInput
         | IssueUpsertWithWhereUniqueWithoutCycleInput[];
      createMany?: IssueCreateManyCycleInputEnvelope;
      set?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      update?:
         | IssueUpdateWithWhereUniqueWithoutCycleInput
         | IssueUpdateWithWhereUniqueWithoutCycleInput[];
      updateMany?:
         | IssueUpdateManyWithWhereWithoutCycleInput
         | IssueUpdateManyWithWhereWithoutCycleInput[];
      deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[];
   };

   export type IssueUncheckedUpdateManyWithoutCycleNestedInput = {
      create?:
         | XOR<IssueCreateWithoutCycleInput, IssueUncheckedCreateWithoutCycleInput>
         | IssueCreateWithoutCycleInput[]
         | IssueUncheckedCreateWithoutCycleInput[];
      connectOrCreate?:
         | IssueCreateOrConnectWithoutCycleInput
         | IssueCreateOrConnectWithoutCycleInput[];
      upsert?:
         | IssueUpsertWithWhereUniqueWithoutCycleInput
         | IssueUpsertWithWhereUniqueWithoutCycleInput[];
      createMany?: IssueCreateManyCycleInputEnvelope;
      set?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      disconnect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      delete?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      connect?: IssueWhereUniqueInput | IssueWhereUniqueInput[];
      update?:
         | IssueUpdateWithWhereUniqueWithoutCycleInput
         | IssueUpdateWithWhereUniqueWithoutCycleInput[];
      updateMany?:
         | IssueUpdateManyWithWhereWithoutCycleInput
         | IssueUpdateManyWithWhereWithoutCycleInput[];
      deleteMany?: IssueScalarWhereInput | IssueScalarWhereInput[];
   };

   export type TeamMemberCreateNestedManyWithoutTeamInput = {
      create?:
         | XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
         | TeamMemberCreateWithoutTeamInput[]
         | TeamMemberUncheckedCreateWithoutTeamInput[];
      connectOrCreate?:
         | TeamMemberCreateOrConnectWithoutTeamInput
         | TeamMemberCreateOrConnectWithoutTeamInput[];
      createMany?: TeamMemberCreateManyTeamInputEnvelope;
      connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
   };

   export type TeamProjectCreateNestedManyWithoutTeamInput = {
      create?:
         | XOR<TeamProjectCreateWithoutTeamInput, TeamProjectUncheckedCreateWithoutTeamInput>
         | TeamProjectCreateWithoutTeamInput[]
         | TeamProjectUncheckedCreateWithoutTeamInput[];
      connectOrCreate?:
         | TeamProjectCreateOrConnectWithoutTeamInput
         | TeamProjectCreateOrConnectWithoutTeamInput[];
      createMany?: TeamProjectCreateManyTeamInputEnvelope;
      connect?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
   };

   export type CycleCreateNestedManyWithoutTeamInput = {
      create?:
         | XOR<CycleCreateWithoutTeamInput, CycleUncheckedCreateWithoutTeamInput>
         | CycleCreateWithoutTeamInput[]
         | CycleUncheckedCreateWithoutTeamInput[];
      connectOrCreate?:
         | CycleCreateOrConnectWithoutTeamInput
         | CycleCreateOrConnectWithoutTeamInput[];
      createMany?: CycleCreateManyTeamInputEnvelope;
      connect?: CycleWhereUniqueInput | CycleWhereUniqueInput[];
   };

   export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
      create?:
         | XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
         | TeamMemberCreateWithoutTeamInput[]
         | TeamMemberUncheckedCreateWithoutTeamInput[];
      connectOrCreate?:
         | TeamMemberCreateOrConnectWithoutTeamInput
         | TeamMemberCreateOrConnectWithoutTeamInput[];
      createMany?: TeamMemberCreateManyTeamInputEnvelope;
      connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
   };

   export type TeamProjectUncheckedCreateNestedManyWithoutTeamInput = {
      create?:
         | XOR<TeamProjectCreateWithoutTeamInput, TeamProjectUncheckedCreateWithoutTeamInput>
         | TeamProjectCreateWithoutTeamInput[]
         | TeamProjectUncheckedCreateWithoutTeamInput[];
      connectOrCreate?:
         | TeamProjectCreateOrConnectWithoutTeamInput
         | TeamProjectCreateOrConnectWithoutTeamInput[];
      createMany?: TeamProjectCreateManyTeamInputEnvelope;
      connect?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
   };

   export type CycleUncheckedCreateNestedManyWithoutTeamInput = {
      create?:
         | XOR<CycleCreateWithoutTeamInput, CycleUncheckedCreateWithoutTeamInput>
         | CycleCreateWithoutTeamInput[]
         | CycleUncheckedCreateWithoutTeamInput[];
      connectOrCreate?:
         | CycleCreateOrConnectWithoutTeamInput
         | CycleCreateOrConnectWithoutTeamInput[];
      createMany?: CycleCreateManyTeamInputEnvelope;
      connect?: CycleWhereUniqueInput | CycleWhereUniqueInput[];
   };

   export type TeamMemberUpdateManyWithoutTeamNestedInput = {
      create?:
         | XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
         | TeamMemberCreateWithoutTeamInput[]
         | TeamMemberUncheckedCreateWithoutTeamInput[];
      connectOrCreate?:
         | TeamMemberCreateOrConnectWithoutTeamInput
         | TeamMemberCreateOrConnectWithoutTeamInput[];
      upsert?:
         | TeamMemberUpsertWithWhereUniqueWithoutTeamInput
         | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[];
      createMany?: TeamMemberCreateManyTeamInputEnvelope;
      set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
      disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
      delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
      connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
      update?:
         | TeamMemberUpdateWithWhereUniqueWithoutTeamInput
         | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[];
      updateMany?:
         | TeamMemberUpdateManyWithWhereWithoutTeamInput
         | TeamMemberUpdateManyWithWhereWithoutTeamInput[];
      deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
   };

   export type TeamProjectUpdateManyWithoutTeamNestedInput = {
      create?:
         | XOR<TeamProjectCreateWithoutTeamInput, TeamProjectUncheckedCreateWithoutTeamInput>
         | TeamProjectCreateWithoutTeamInput[]
         | TeamProjectUncheckedCreateWithoutTeamInput[];
      connectOrCreate?:
         | TeamProjectCreateOrConnectWithoutTeamInput
         | TeamProjectCreateOrConnectWithoutTeamInput[];
      upsert?:
         | TeamProjectUpsertWithWhereUniqueWithoutTeamInput
         | TeamProjectUpsertWithWhereUniqueWithoutTeamInput[];
      createMany?: TeamProjectCreateManyTeamInputEnvelope;
      set?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
      disconnect?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
      delete?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
      connect?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
      update?:
         | TeamProjectUpdateWithWhereUniqueWithoutTeamInput
         | TeamProjectUpdateWithWhereUniqueWithoutTeamInput[];
      updateMany?:
         | TeamProjectUpdateManyWithWhereWithoutTeamInput
         | TeamProjectUpdateManyWithWhereWithoutTeamInput[];
      deleteMany?: TeamProjectScalarWhereInput | TeamProjectScalarWhereInput[];
   };

   export type CycleUpdateManyWithoutTeamNestedInput = {
      create?:
         | XOR<CycleCreateWithoutTeamInput, CycleUncheckedCreateWithoutTeamInput>
         | CycleCreateWithoutTeamInput[]
         | CycleUncheckedCreateWithoutTeamInput[];
      connectOrCreate?:
         | CycleCreateOrConnectWithoutTeamInput
         | CycleCreateOrConnectWithoutTeamInput[];
      upsert?:
         | CycleUpsertWithWhereUniqueWithoutTeamInput
         | CycleUpsertWithWhereUniqueWithoutTeamInput[];
      createMany?: CycleCreateManyTeamInputEnvelope;
      set?: CycleWhereUniqueInput | CycleWhereUniqueInput[];
      disconnect?: CycleWhereUniqueInput | CycleWhereUniqueInput[];
      delete?: CycleWhereUniqueInput | CycleWhereUniqueInput[];
      connect?: CycleWhereUniqueInput | CycleWhereUniqueInput[];
      update?:
         | CycleUpdateWithWhereUniqueWithoutTeamInput
         | CycleUpdateWithWhereUniqueWithoutTeamInput[];
      updateMany?:
         | CycleUpdateManyWithWhereWithoutTeamInput
         | CycleUpdateManyWithWhereWithoutTeamInput[];
      deleteMany?: CycleScalarWhereInput | CycleScalarWhereInput[];
   };

   export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
      create?:
         | XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
         | TeamMemberCreateWithoutTeamInput[]
         | TeamMemberUncheckedCreateWithoutTeamInput[];
      connectOrCreate?:
         | TeamMemberCreateOrConnectWithoutTeamInput
         | TeamMemberCreateOrConnectWithoutTeamInput[];
      upsert?:
         | TeamMemberUpsertWithWhereUniqueWithoutTeamInput
         | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[];
      createMany?: TeamMemberCreateManyTeamInputEnvelope;
      set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
      disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
      delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
      connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[];
      update?:
         | TeamMemberUpdateWithWhereUniqueWithoutTeamInput
         | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[];
      updateMany?:
         | TeamMemberUpdateManyWithWhereWithoutTeamInput
         | TeamMemberUpdateManyWithWhereWithoutTeamInput[];
      deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
   };

   export type TeamProjectUncheckedUpdateManyWithoutTeamNestedInput = {
      create?:
         | XOR<TeamProjectCreateWithoutTeamInput, TeamProjectUncheckedCreateWithoutTeamInput>
         | TeamProjectCreateWithoutTeamInput[]
         | TeamProjectUncheckedCreateWithoutTeamInput[];
      connectOrCreate?:
         | TeamProjectCreateOrConnectWithoutTeamInput
         | TeamProjectCreateOrConnectWithoutTeamInput[];
      upsert?:
         | TeamProjectUpsertWithWhereUniqueWithoutTeamInput
         | TeamProjectUpsertWithWhereUniqueWithoutTeamInput[];
      createMany?: TeamProjectCreateManyTeamInputEnvelope;
      set?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
      disconnect?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
      delete?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
      connect?: TeamProjectWhereUniqueInput | TeamProjectWhereUniqueInput[];
      update?:
         | TeamProjectUpdateWithWhereUniqueWithoutTeamInput
         | TeamProjectUpdateWithWhereUniqueWithoutTeamInput[];
      updateMany?:
         | TeamProjectUpdateManyWithWhereWithoutTeamInput
         | TeamProjectUpdateManyWithWhereWithoutTeamInput[];
      deleteMany?: TeamProjectScalarWhereInput | TeamProjectScalarWhereInput[];
   };

   export type CycleUncheckedUpdateManyWithoutTeamNestedInput = {
      create?:
         | XOR<CycleCreateWithoutTeamInput, CycleUncheckedCreateWithoutTeamInput>
         | CycleCreateWithoutTeamInput[]
         | CycleUncheckedCreateWithoutTeamInput[];
      connectOrCreate?:
         | CycleCreateOrConnectWithoutTeamInput
         | CycleCreateOrConnectWithoutTeamInput[];
      upsert?:
         | CycleUpsertWithWhereUniqueWithoutTeamInput
         | CycleUpsertWithWhereUniqueWithoutTeamInput[];
      createMany?: CycleCreateManyTeamInputEnvelope;
      set?: CycleWhereUniqueInput | CycleWhereUniqueInput[];
      disconnect?: CycleWhereUniqueInput | CycleWhereUniqueInput[];
      delete?: CycleWhereUniqueInput | CycleWhereUniqueInput[];
      connect?: CycleWhereUniqueInput | CycleWhereUniqueInput[];
      update?:
         | CycleUpdateWithWhereUniqueWithoutTeamInput
         | CycleUpdateWithWhereUniqueWithoutTeamInput[];
      updateMany?:
         | CycleUpdateManyWithWhereWithoutTeamInput
         | CycleUpdateManyWithWhereWithoutTeamInput[];
      deleteMany?: CycleScalarWhereInput | CycleScalarWhereInput[];
   };

   export type TeamCreateNestedOneWithoutMembersInput = {
      create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>;
      connectOrCreate?: TeamCreateOrConnectWithoutMembersInput;
      connect?: TeamWhereUniqueInput;
   };

   export type UserCreateNestedOneWithoutTeamsInput = {
      create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>;
      connectOrCreate?: UserCreateOrConnectWithoutTeamsInput;
      connect?: UserWhereUniqueInput;
   };

   export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
      create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>;
      connectOrCreate?: TeamCreateOrConnectWithoutMembersInput;
      upsert?: TeamUpsertWithoutMembersInput;
      connect?: TeamWhereUniqueInput;
      update?: XOR<
         XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>,
         TeamUncheckedUpdateWithoutMembersInput
      >;
   };

   export type UserUpdateOneRequiredWithoutTeamsNestedInput = {
      create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>;
      connectOrCreate?: UserCreateOrConnectWithoutTeamsInput;
      upsert?: UserUpsertWithoutTeamsInput;
      connect?: UserWhereUniqueInput;
      update?: XOR<
         XOR<UserUpdateToOneWithWhereWithoutTeamsInput, UserUpdateWithoutTeamsInput>,
         UserUncheckedUpdateWithoutTeamsInput
      >;
   };

   export type TeamCreateNestedOneWithoutProjectsInput = {
      create?: XOR<TeamCreateWithoutProjectsInput, TeamUncheckedCreateWithoutProjectsInput>;
      connectOrCreate?: TeamCreateOrConnectWithoutProjectsInput;
      connect?: TeamWhereUniqueInput;
   };

   export type ProjectCreateNestedOneWithoutTeamsInput = {
      create?: XOR<ProjectCreateWithoutTeamsInput, ProjectUncheckedCreateWithoutTeamsInput>;
      connectOrCreate?: ProjectCreateOrConnectWithoutTeamsInput;
      connect?: ProjectWhereUniqueInput;
   };

   export type TeamUpdateOneRequiredWithoutProjectsNestedInput = {
      create?: XOR<TeamCreateWithoutProjectsInput, TeamUncheckedCreateWithoutProjectsInput>;
      connectOrCreate?: TeamCreateOrConnectWithoutProjectsInput;
      upsert?: TeamUpsertWithoutProjectsInput;
      connect?: TeamWhereUniqueInput;
      update?: XOR<
         XOR<TeamUpdateToOneWithWhereWithoutProjectsInput, TeamUpdateWithoutProjectsInput>,
         TeamUncheckedUpdateWithoutProjectsInput
      >;
   };

   export type ProjectUpdateOneRequiredWithoutTeamsNestedInput = {
      create?: XOR<ProjectCreateWithoutTeamsInput, ProjectUncheckedCreateWithoutTeamsInput>;
      connectOrCreate?: ProjectCreateOrConnectWithoutTeamsInput;
      upsert?: ProjectUpsertWithoutTeamsInput;
      connect?: ProjectWhereUniqueInput;
      update?: XOR<
         XOR<ProjectUpdateToOneWithWhereWithoutTeamsInput, ProjectUpdateWithoutTeamsInput>,
         ProjectUncheckedUpdateWithoutTeamsInput
      >;
   };

   export type NestedIntFilter<$PrismaModel = never> = {
      equals?: number | IntFieldRefInput<$PrismaModel>;
      in?: number[];
      notIn?: number[];
      lt?: number | IntFieldRefInput<$PrismaModel>;
      lte?: number | IntFieldRefInput<$PrismaModel>;
      gt?: number | IntFieldRefInput<$PrismaModel>;
      gte?: number | IntFieldRefInput<$PrismaModel>;
      not?: NestedIntFilter<$PrismaModel> | number;
   };

   export type NestedStringFilter<$PrismaModel = never> = {
      equals?: string | StringFieldRefInput<$PrismaModel>;
      in?: string[];
      notIn?: string[];
      lt?: string | StringFieldRefInput<$PrismaModel>;
      lte?: string | StringFieldRefInput<$PrismaModel>;
      gt?: string | StringFieldRefInput<$PrismaModel>;
      gte?: string | StringFieldRefInput<$PrismaModel>;
      contains?: string | StringFieldRefInput<$PrismaModel>;
      startsWith?: string | StringFieldRefInput<$PrismaModel>;
      endsWith?: string | StringFieldRefInput<$PrismaModel>;
      not?: NestedStringFilter<$PrismaModel> | string;
   };

   export type NestedStringNullableFilter<$PrismaModel = never> = {
      equals?: string | StringFieldRefInput<$PrismaModel> | null;
      in?: string[] | null;
      notIn?: string[] | null;
      lt?: string | StringFieldRefInput<$PrismaModel>;
      lte?: string | StringFieldRefInput<$PrismaModel>;
      gt?: string | StringFieldRefInput<$PrismaModel>;
      gte?: string | StringFieldRefInput<$PrismaModel>;
      contains?: string | StringFieldRefInput<$PrismaModel>;
      startsWith?: string | StringFieldRefInput<$PrismaModel>;
      endsWith?: string | StringFieldRefInput<$PrismaModel>;
      not?: NestedStringNullableFilter<$PrismaModel> | string | null;
   };

   export type NestedIntNullableFilter<$PrismaModel = never> = {
      equals?: number | IntFieldRefInput<$PrismaModel> | null;
      in?: number[] | null;
      notIn?: number[] | null;
      lt?: number | IntFieldRefInput<$PrismaModel>;
      lte?: number | IntFieldRefInput<$PrismaModel>;
      gt?: number | IntFieldRefInput<$PrismaModel>;
      gte?: number | IntFieldRefInput<$PrismaModel>;
      not?: NestedIntNullableFilter<$PrismaModel> | number | null;
   };

   export type NestedDateTimeFilter<$PrismaModel = never> = {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      in?: Date[] | string[];
      notIn?: Date[] | string[];
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?: NestedDateTimeFilter<$PrismaModel> | Date | string;
   };

   export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
      equals?: number | IntFieldRefInput<$PrismaModel>;
      in?: number[];
      notIn?: number[];
      lt?: number | IntFieldRefInput<$PrismaModel>;
      lte?: number | IntFieldRefInput<$PrismaModel>;
      gt?: number | IntFieldRefInput<$PrismaModel>;
      gte?: number | IntFieldRefInput<$PrismaModel>;
      not?: NestedIntWithAggregatesFilter<$PrismaModel> | number;
      _count?: NestedIntFilter<$PrismaModel>;
      _avg?: NestedFloatFilter<$PrismaModel>;
      _sum?: NestedIntFilter<$PrismaModel>;
      _min?: NestedIntFilter<$PrismaModel>;
      _max?: NestedIntFilter<$PrismaModel>;
   };

   export type NestedFloatFilter<$PrismaModel = never> = {
      equals?: number | FloatFieldRefInput<$PrismaModel>;
      in?: number[];
      notIn?: number[];
      lt?: number | FloatFieldRefInput<$PrismaModel>;
      lte?: number | FloatFieldRefInput<$PrismaModel>;
      gt?: number | FloatFieldRefInput<$PrismaModel>;
      gte?: number | FloatFieldRefInput<$PrismaModel>;
      not?: NestedFloatFilter<$PrismaModel> | number;
   };

   export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
      equals?: string | StringFieldRefInput<$PrismaModel>;
      in?: string[];
      notIn?: string[];
      lt?: string | StringFieldRefInput<$PrismaModel>;
      lte?: string | StringFieldRefInput<$PrismaModel>;
      gt?: string | StringFieldRefInput<$PrismaModel>;
      gte?: string | StringFieldRefInput<$PrismaModel>;
      contains?: string | StringFieldRefInput<$PrismaModel>;
      startsWith?: string | StringFieldRefInput<$PrismaModel>;
      endsWith?: string | StringFieldRefInput<$PrismaModel>;
      not?: NestedStringWithAggregatesFilter<$PrismaModel> | string;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedStringFilter<$PrismaModel>;
      _max?: NestedStringFilter<$PrismaModel>;
   };

   export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
      equals?: string | StringFieldRefInput<$PrismaModel> | null;
      in?: string[] | null;
      notIn?: string[] | null;
      lt?: string | StringFieldRefInput<$PrismaModel>;
      lte?: string | StringFieldRefInput<$PrismaModel>;
      gt?: string | StringFieldRefInput<$PrismaModel>;
      gte?: string | StringFieldRefInput<$PrismaModel>;
      contains?: string | StringFieldRefInput<$PrismaModel>;
      startsWith?: string | StringFieldRefInput<$PrismaModel>;
      endsWith?: string | StringFieldRefInput<$PrismaModel>;
      not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedStringNullableFilter<$PrismaModel>;
      _max?: NestedStringNullableFilter<$PrismaModel>;
   };

   export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
      equals?: number | IntFieldRefInput<$PrismaModel> | null;
      in?: number[] | null;
      notIn?: number[] | null;
      lt?: number | IntFieldRefInput<$PrismaModel>;
      lte?: number | IntFieldRefInput<$PrismaModel>;
      gt?: number | IntFieldRefInput<$PrismaModel>;
      gte?: number | IntFieldRefInput<$PrismaModel>;
      not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _avg?: NestedFloatNullableFilter<$PrismaModel>;
      _sum?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedIntNullableFilter<$PrismaModel>;
      _max?: NestedIntNullableFilter<$PrismaModel>;
   };

   export type NestedFloatNullableFilter<$PrismaModel = never> = {
      equals?: number | FloatFieldRefInput<$PrismaModel> | null;
      in?: number[] | null;
      notIn?: number[] | null;
      lt?: number | FloatFieldRefInput<$PrismaModel>;
      lte?: number | FloatFieldRefInput<$PrismaModel>;
      gt?: number | FloatFieldRefInput<$PrismaModel>;
      gte?: number | FloatFieldRefInput<$PrismaModel>;
      not?: NestedFloatNullableFilter<$PrismaModel> | number | null;
   };

   export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      in?: Date[] | string[];
      notIn?: Date[] | string[];
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedDateTimeFilter<$PrismaModel>;
      _max?: NestedDateTimeFilter<$PrismaModel>;
   };

   export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | null;
      notIn?: Date[] | string[] | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null;
   };

   export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
      equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null;
      in?: Date[] | string[] | null;
      notIn?: Date[] | string[] | null;
      lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>;
      not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null;
      _count?: NestedIntNullableFilter<$PrismaModel>;
      _min?: NestedDateTimeNullableFilter<$PrismaModel>;
      _max?: NestedDateTimeNullableFilter<$PrismaModel>;
   };

   export type NestedBoolFilter<$PrismaModel = never> = {
      equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
      not?: NestedBoolFilter<$PrismaModel> | boolean;
   };

   export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
      equals?: boolean | BooleanFieldRefInput<$PrismaModel>;
      not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedBoolFilter<$PrismaModel>;
      _max?: NestedBoolFilter<$PrismaModel>;
   };

   export type NestedEnumUserStatusFilter<$PrismaModel = never> = {
      equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>;
      in?: $Enums.UserStatus[];
      notIn?: $Enums.UserStatus[];
      not?: NestedEnumUserStatusFilter<$PrismaModel> | $Enums.UserStatus;
   };

   export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
      equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
      in?: $Enums.UserRole[];
      notIn?: $Enums.UserRole[];
      not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole;
   };

   export type NestedEnumUserStatusWithAggregatesFilter<$PrismaModel = never> = {
      equals?: $Enums.UserStatus | EnumUserStatusFieldRefInput<$PrismaModel>;
      in?: $Enums.UserStatus[];
      notIn?: $Enums.UserStatus[];
      not?: NestedEnumUserStatusWithAggregatesFilter<$PrismaModel> | $Enums.UserStatus;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumUserStatusFilter<$PrismaModel>;
      _max?: NestedEnumUserStatusFilter<$PrismaModel>;
   };

   export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
      equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>;
      in?: $Enums.UserRole[];
      notIn?: $Enums.UserRole[];
      not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumUserRoleFilter<$PrismaModel>;
      _max?: NestedEnumUserRoleFilter<$PrismaModel>;
   };

   export type NestedEnumProjectHealthFilter<$PrismaModel = never> = {
      equals?: $Enums.ProjectHealth | EnumProjectHealthFieldRefInput<$PrismaModel>;
      in?: $Enums.ProjectHealth[];
      notIn?: $Enums.ProjectHealth[];
      not?: NestedEnumProjectHealthFilter<$PrismaModel> | $Enums.ProjectHealth;
   };

   export type NestedEnumProjectHealthWithAggregatesFilter<$PrismaModel = never> = {
      equals?: $Enums.ProjectHealth | EnumProjectHealthFieldRefInput<$PrismaModel>;
      in?: $Enums.ProjectHealth[];
      notIn?: $Enums.ProjectHealth[];
      not?: NestedEnumProjectHealthWithAggregatesFilter<$PrismaModel> | $Enums.ProjectHealth;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumProjectHealthFilter<$PrismaModel>;
      _max?: NestedEnumProjectHealthFilter<$PrismaModel>;
   };

   export type NestedEnumIssueTypeFilter<$PrismaModel = never> = {
      equals?: $Enums.IssueType | EnumIssueTypeFieldRefInput<$PrismaModel>;
      in?: $Enums.IssueType[];
      notIn?: $Enums.IssueType[];
      not?: NestedEnumIssueTypeFilter<$PrismaModel> | $Enums.IssueType;
   };

   export type NestedEnumIssueTypeWithAggregatesFilter<$PrismaModel = never> = {
      equals?: $Enums.IssueType | EnumIssueTypeFieldRefInput<$PrismaModel>;
      in?: $Enums.IssueType[];
      notIn?: $Enums.IssueType[];
      not?: NestedEnumIssueTypeWithAggregatesFilter<$PrismaModel> | $Enums.IssueType;
      _count?: NestedIntFilter<$PrismaModel>;
      _min?: NestedEnumIssueTypeFilter<$PrismaModel>;
      _max?: NestedEnumIssueTypeFilter<$PrismaModel>;
   };

   export type SubtaskCreateWithoutParentTaskInput = {
      id: string;
      title: string;
      description: string;
      details?: string | null;
      testStrategy?: string | null;
      status: string;
      dependencies?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type SubtaskUncheckedCreateWithoutParentTaskInput = {
      id: string;
      title: string;
      description: string;
      details?: string | null;
      testStrategy?: string | null;
      status: string;
      dependencies?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type SubtaskCreateOrConnectWithoutParentTaskInput = {
      where: SubtaskWhereUniqueInput;
      create: XOR<
         SubtaskCreateWithoutParentTaskInput,
         SubtaskUncheckedCreateWithoutParentTaskInput
      >;
   };

   export type SubtaskCreateManyParentTaskInputEnvelope = {
      data: SubtaskCreateManyParentTaskInput | SubtaskCreateManyParentTaskInput[];
   };

   export type TaskDependencyCreateWithoutTaskInput = {
      createdAt?: Date | string;
      dependsOn: TaskCreateNestedOneWithoutDependentsInput;
   };

   export type TaskDependencyUncheckedCreateWithoutTaskInput = {
      id?: number;
      dependsOnId: number;
      createdAt?: Date | string;
   };

   export type TaskDependencyCreateOrConnectWithoutTaskInput = {
      where: TaskDependencyWhereUniqueInput;
      create: XOR<
         TaskDependencyCreateWithoutTaskInput,
         TaskDependencyUncheckedCreateWithoutTaskInput
      >;
   };

   export type TaskDependencyCreateManyTaskInputEnvelope = {
      data: TaskDependencyCreateManyTaskInput | TaskDependencyCreateManyTaskInput[];
   };

   export type TaskDependencyCreateWithoutDependsOnInput = {
      createdAt?: Date | string;
      task: TaskCreateNestedOneWithoutDependenciesInput;
   };

   export type TaskDependencyUncheckedCreateWithoutDependsOnInput = {
      id?: number;
      taskId: number;
      createdAt?: Date | string;
   };

   export type TaskDependencyCreateOrConnectWithoutDependsOnInput = {
      where: TaskDependencyWhereUniqueInput;
      create: XOR<
         TaskDependencyCreateWithoutDependsOnInput,
         TaskDependencyUncheckedCreateWithoutDependsOnInput
      >;
   };

   export type TaskDependencyCreateManyDependsOnInputEnvelope = {
      data: TaskDependencyCreateManyDependsOnInput | TaskDependencyCreateManyDependsOnInput[];
   };

   export type IssueCreateWithoutTaskInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      status?: string | null;
      priority?: string | null;
      rank: string;
      dueDate?: Date | string | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      assignee?: UserCreateNestedOneWithoutAssignedIssuesInput;
      project?: ProjectCreateNestedOneWithoutIssuesInput;
      cycle?: CycleCreateNestedOneWithoutIssuesInput;
      issueStatus?: IssueStatusCreateNestedOneWithoutIssuesInput;
      issuePriority?: IssuePriorityCreateNestedOneWithoutIssuesInput;
      labels?: IssueLabelCreateNestedManyWithoutIssueInput;
   };

   export type IssueUncheckedCreateWithoutTaskInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      statusId?: string | null;
      priorityId?: string | null;
      status?: string | null;
      priority?: string | null;
      rank: string;
      cycleId?: string | null;
      dueDate?: Date | string | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      assigneeId?: string | null;
      projectId?: string | null;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      labels?: IssueLabelUncheckedCreateNestedManyWithoutIssueInput;
   };

   export type IssueCreateOrConnectWithoutTaskInput = {
      where: IssueWhereUniqueInput;
      create: XOR<IssueCreateWithoutTaskInput, IssueUncheckedCreateWithoutTaskInput>;
   };

   export type IssueCreateManyTaskInputEnvelope = {
      data: IssueCreateManyTaskInput | IssueCreateManyTaskInput[];
   };

   export type SubtaskUpsertWithWhereUniqueWithoutParentTaskInput = {
      where: SubtaskWhereUniqueInput;
      update: XOR<
         SubtaskUpdateWithoutParentTaskInput,
         SubtaskUncheckedUpdateWithoutParentTaskInput
      >;
      create: XOR<
         SubtaskCreateWithoutParentTaskInput,
         SubtaskUncheckedCreateWithoutParentTaskInput
      >;
   };

   export type SubtaskUpdateWithWhereUniqueWithoutParentTaskInput = {
      where: SubtaskWhereUniqueInput;
      data: XOR<SubtaskUpdateWithoutParentTaskInput, SubtaskUncheckedUpdateWithoutParentTaskInput>;
   };

   export type SubtaskUpdateManyWithWhereWithoutParentTaskInput = {
      where: SubtaskScalarWhereInput;
      data: XOR<SubtaskUpdateManyMutationInput, SubtaskUncheckedUpdateManyWithoutParentTaskInput>;
   };

   export type SubtaskScalarWhereInput = {
      AND?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[];
      OR?: SubtaskScalarWhereInput[];
      NOT?: SubtaskScalarWhereInput | SubtaskScalarWhereInput[];
      id?: StringFilter<'Subtask'> | string;
      title?: StringFilter<'Subtask'> | string;
      description?: StringFilter<'Subtask'> | string;
      details?: StringNullableFilter<'Subtask'> | string | null;
      testStrategy?: StringNullableFilter<'Subtask'> | string | null;
      status?: StringFilter<'Subtask'> | string;
      parentId?: IntFilter<'Subtask'> | number;
      dependencies?: StringFilter<'Subtask'> | string;
      createdAt?: DateTimeFilter<'Subtask'> | Date | string;
      updatedAt?: DateTimeFilter<'Subtask'> | Date | string;
   };

   export type TaskDependencyUpsertWithWhereUniqueWithoutTaskInput = {
      where: TaskDependencyWhereUniqueInput;
      update: XOR<
         TaskDependencyUpdateWithoutTaskInput,
         TaskDependencyUncheckedUpdateWithoutTaskInput
      >;
      create: XOR<
         TaskDependencyCreateWithoutTaskInput,
         TaskDependencyUncheckedCreateWithoutTaskInput
      >;
   };

   export type TaskDependencyUpdateWithWhereUniqueWithoutTaskInput = {
      where: TaskDependencyWhereUniqueInput;
      data: XOR<
         TaskDependencyUpdateWithoutTaskInput,
         TaskDependencyUncheckedUpdateWithoutTaskInput
      >;
   };

   export type TaskDependencyUpdateManyWithWhereWithoutTaskInput = {
      where: TaskDependencyScalarWhereInput;
      data: XOR<
         TaskDependencyUpdateManyMutationInput,
         TaskDependencyUncheckedUpdateManyWithoutTaskInput
      >;
   };

   export type TaskDependencyScalarWhereInput = {
      AND?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[];
      OR?: TaskDependencyScalarWhereInput[];
      NOT?: TaskDependencyScalarWhereInput | TaskDependencyScalarWhereInput[];
      id?: IntFilter<'TaskDependency'> | number;
      taskId?: IntFilter<'TaskDependency'> | number;
      dependsOnId?: IntFilter<'TaskDependency'> | number;
      createdAt?: DateTimeFilter<'TaskDependency'> | Date | string;
   };

   export type TaskDependencyUpsertWithWhereUniqueWithoutDependsOnInput = {
      where: TaskDependencyWhereUniqueInput;
      update: XOR<
         TaskDependencyUpdateWithoutDependsOnInput,
         TaskDependencyUncheckedUpdateWithoutDependsOnInput
      >;
      create: XOR<
         TaskDependencyCreateWithoutDependsOnInput,
         TaskDependencyUncheckedCreateWithoutDependsOnInput
      >;
   };

   export type TaskDependencyUpdateWithWhereUniqueWithoutDependsOnInput = {
      where: TaskDependencyWhereUniqueInput;
      data: XOR<
         TaskDependencyUpdateWithoutDependsOnInput,
         TaskDependencyUncheckedUpdateWithoutDependsOnInput
      >;
   };

   export type TaskDependencyUpdateManyWithWhereWithoutDependsOnInput = {
      where: TaskDependencyScalarWhereInput;
      data: XOR<
         TaskDependencyUpdateManyMutationInput,
         TaskDependencyUncheckedUpdateManyWithoutDependsOnInput
      >;
   };

   export type IssueUpsertWithWhereUniqueWithoutTaskInput = {
      where: IssueWhereUniqueInput;
      update: XOR<IssueUpdateWithoutTaskInput, IssueUncheckedUpdateWithoutTaskInput>;
      create: XOR<IssueCreateWithoutTaskInput, IssueUncheckedCreateWithoutTaskInput>;
   };

   export type IssueUpdateWithWhereUniqueWithoutTaskInput = {
      where: IssueWhereUniqueInput;
      data: XOR<IssueUpdateWithoutTaskInput, IssueUncheckedUpdateWithoutTaskInput>;
   };

   export type IssueUpdateManyWithWhereWithoutTaskInput = {
      where: IssueScalarWhereInput;
      data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyWithoutTaskInput>;
   };

   export type IssueScalarWhereInput = {
      AND?: IssueScalarWhereInput | IssueScalarWhereInput[];
      OR?: IssueScalarWhereInput[];
      NOT?: IssueScalarWhereInput | IssueScalarWhereInput[];
      id?: StringFilter<'Issue'> | string;
      identifier?: StringFilter<'Issue'> | string;
      title?: StringFilter<'Issue'> | string;
      description?: StringFilter<'Issue'> | string;
      statusId?: StringNullableFilter<'Issue'> | string | null;
      priorityId?: StringNullableFilter<'Issue'> | string | null;
      status?: StringNullableFilter<'Issue'> | string | null;
      priority?: StringNullableFilter<'Issue'> | string | null;
      rank?: StringFilter<'Issue'> | string;
      cycleId?: StringNullableFilter<'Issue'> | string | null;
      dueDate?: DateTimeNullableFilter<'Issue'> | Date | string | null;
      taskId?: IntNullableFilter<'Issue'> | number | null;
      subtaskId?: StringNullableFilter<'Issue'> | string | null;
      issueType?: EnumIssueTypeFilter<'Issue'> | $Enums.IssueType;
      assigneeId?: StringNullableFilter<'Issue'> | string | null;
      projectId?: StringNullableFilter<'Issue'> | string | null;
      subissues?: StringFilter<'Issue'> | string;
      createdAt?: DateTimeFilter<'Issue'> | Date | string;
      updatedAt?: DateTimeFilter<'Issue'> | Date | string;
   };

   export type TaskCreateWithoutSubtasksInput = {
      id: number;
      title: string;
      description: string;
      details?: string | null;
      testStrategy?: string | null;
      priority: string;
      status: string;
      complexity?: number | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput;
      dependents?: TaskDependencyCreateNestedManyWithoutDependsOnInput;
      issues?: IssueCreateNestedManyWithoutTaskInput;
   };

   export type TaskUncheckedCreateWithoutSubtasksInput = {
      id: number;
      title: string;
      description: string;
      details?: string | null;
      testStrategy?: string | null;
      priority: string;
      status: string;
      complexity?: number | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput;
      dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDependsOnInput;
      issues?: IssueUncheckedCreateNestedManyWithoutTaskInput;
   };

   export type TaskCreateOrConnectWithoutSubtasksInput = {
      where: TaskWhereUniqueInput;
      create: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>;
   };

   export type TaskUpsertWithoutSubtasksInput = {
      update: XOR<TaskUpdateWithoutSubtasksInput, TaskUncheckedUpdateWithoutSubtasksInput>;
      create: XOR<TaskCreateWithoutSubtasksInput, TaskUncheckedCreateWithoutSubtasksInput>;
      where?: TaskWhereInput;
   };

   export type TaskUpdateToOneWithWhereWithoutSubtasksInput = {
      where?: TaskWhereInput;
      data: XOR<TaskUpdateWithoutSubtasksInput, TaskUncheckedUpdateWithoutSubtasksInput>;
   };

   export type TaskUpdateWithoutSubtasksInput = {
      id?: IntFieldUpdateOperationsInput | number;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: StringFieldUpdateOperationsInput | string;
      status?: StringFieldUpdateOperationsInput | string;
      complexity?: NullableIntFieldUpdateOperationsInput | number | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput;
      dependents?: TaskDependencyUpdateManyWithoutDependsOnNestedInput;
      issues?: IssueUpdateManyWithoutTaskNestedInput;
   };

   export type TaskUncheckedUpdateWithoutSubtasksInput = {
      id?: IntFieldUpdateOperationsInput | number;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: StringFieldUpdateOperationsInput | string;
      status?: StringFieldUpdateOperationsInput | string;
      complexity?: NullableIntFieldUpdateOperationsInput | number | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput;
      dependents?: TaskDependencyUncheckedUpdateManyWithoutDependsOnNestedInput;
      issues?: IssueUncheckedUpdateManyWithoutTaskNestedInput;
   };

   export type TaskCreateWithoutDependenciesInput = {
      id: number;
      title: string;
      description: string;
      details?: string | null;
      testStrategy?: string | null;
      priority: string;
      status: string;
      complexity?: number | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      subtasks?: SubtaskCreateNestedManyWithoutParentTaskInput;
      dependents?: TaskDependencyCreateNestedManyWithoutDependsOnInput;
      issues?: IssueCreateNestedManyWithoutTaskInput;
   };

   export type TaskUncheckedCreateWithoutDependenciesInput = {
      id: number;
      title: string;
      description: string;
      details?: string | null;
      testStrategy?: string | null;
      priority: string;
      status: string;
      complexity?: number | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      subtasks?: SubtaskUncheckedCreateNestedManyWithoutParentTaskInput;
      dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDependsOnInput;
      issues?: IssueUncheckedCreateNestedManyWithoutTaskInput;
   };

   export type TaskCreateOrConnectWithoutDependenciesInput = {
      where: TaskWhereUniqueInput;
      create: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput>;
   };

   export type TaskCreateWithoutDependentsInput = {
      id: number;
      title: string;
      description: string;
      details?: string | null;
      testStrategy?: string | null;
      priority: string;
      status: string;
      complexity?: number | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      subtasks?: SubtaskCreateNestedManyWithoutParentTaskInput;
      dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput;
      issues?: IssueCreateNestedManyWithoutTaskInput;
   };

   export type TaskUncheckedCreateWithoutDependentsInput = {
      id: number;
      title: string;
      description: string;
      details?: string | null;
      testStrategy?: string | null;
      priority: string;
      status: string;
      complexity?: number | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      subtasks?: SubtaskUncheckedCreateNestedManyWithoutParentTaskInput;
      dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput;
      issues?: IssueUncheckedCreateNestedManyWithoutTaskInput;
   };

   export type TaskCreateOrConnectWithoutDependentsInput = {
      where: TaskWhereUniqueInput;
      create: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>;
   };

   export type TaskUpsertWithoutDependenciesInput = {
      update: XOR<TaskUpdateWithoutDependenciesInput, TaskUncheckedUpdateWithoutDependenciesInput>;
      create: XOR<TaskCreateWithoutDependenciesInput, TaskUncheckedCreateWithoutDependenciesInput>;
      where?: TaskWhereInput;
   };

   export type TaskUpdateToOneWithWhereWithoutDependenciesInput = {
      where?: TaskWhereInput;
      data: XOR<TaskUpdateWithoutDependenciesInput, TaskUncheckedUpdateWithoutDependenciesInput>;
   };

   export type TaskUpdateWithoutDependenciesInput = {
      id?: IntFieldUpdateOperationsInput | number;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: StringFieldUpdateOperationsInput | string;
      status?: StringFieldUpdateOperationsInput | string;
      complexity?: NullableIntFieldUpdateOperationsInput | number | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      subtasks?: SubtaskUpdateManyWithoutParentTaskNestedInput;
      dependents?: TaskDependencyUpdateManyWithoutDependsOnNestedInput;
      issues?: IssueUpdateManyWithoutTaskNestedInput;
   };

   export type TaskUncheckedUpdateWithoutDependenciesInput = {
      id?: IntFieldUpdateOperationsInput | number;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: StringFieldUpdateOperationsInput | string;
      status?: StringFieldUpdateOperationsInput | string;
      complexity?: NullableIntFieldUpdateOperationsInput | number | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      subtasks?: SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput;
      dependents?: TaskDependencyUncheckedUpdateManyWithoutDependsOnNestedInput;
      issues?: IssueUncheckedUpdateManyWithoutTaskNestedInput;
   };

   export type TaskUpsertWithoutDependentsInput = {
      update: XOR<TaskUpdateWithoutDependentsInput, TaskUncheckedUpdateWithoutDependentsInput>;
      create: XOR<TaskCreateWithoutDependentsInput, TaskUncheckedCreateWithoutDependentsInput>;
      where?: TaskWhereInput;
   };

   export type TaskUpdateToOneWithWhereWithoutDependentsInput = {
      where?: TaskWhereInput;
      data: XOR<TaskUpdateWithoutDependentsInput, TaskUncheckedUpdateWithoutDependentsInput>;
   };

   export type TaskUpdateWithoutDependentsInput = {
      id?: IntFieldUpdateOperationsInput | number;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: StringFieldUpdateOperationsInput | string;
      status?: StringFieldUpdateOperationsInput | string;
      complexity?: NullableIntFieldUpdateOperationsInput | number | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      subtasks?: SubtaskUpdateManyWithoutParentTaskNestedInput;
      dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput;
      issues?: IssueUpdateManyWithoutTaskNestedInput;
   };

   export type TaskUncheckedUpdateWithoutDependentsInput = {
      id?: IntFieldUpdateOperationsInput | number;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: StringFieldUpdateOperationsInput | string;
      status?: StringFieldUpdateOperationsInput | string;
      complexity?: NullableIntFieldUpdateOperationsInput | number | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      subtasks?: SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput;
      dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput;
      issues?: IssueUncheckedUpdateManyWithoutTaskNestedInput;
   };

   export type IssueCreateWithoutAssigneeInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      status?: string | null;
      priority?: string | null;
      rank: string;
      dueDate?: Date | string | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      project?: ProjectCreateNestedOneWithoutIssuesInput;
      cycle?: CycleCreateNestedOneWithoutIssuesInput;
      task?: TaskCreateNestedOneWithoutIssuesInput;
      issueStatus?: IssueStatusCreateNestedOneWithoutIssuesInput;
      issuePriority?: IssuePriorityCreateNestedOneWithoutIssuesInput;
      labels?: IssueLabelCreateNestedManyWithoutIssueInput;
   };

   export type IssueUncheckedCreateWithoutAssigneeInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      statusId?: string | null;
      priorityId?: string | null;
      status?: string | null;
      priority?: string | null;
      rank: string;
      cycleId?: string | null;
      dueDate?: Date | string | null;
      taskId?: number | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      projectId?: string | null;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      labels?: IssueLabelUncheckedCreateNestedManyWithoutIssueInput;
   };

   export type IssueCreateOrConnectWithoutAssigneeInput = {
      where: IssueWhereUniqueInput;
      create: XOR<IssueCreateWithoutAssigneeInput, IssueUncheckedCreateWithoutAssigneeInput>;
   };

   export type IssueCreateManyAssigneeInputEnvelope = {
      data: IssueCreateManyAssigneeInput | IssueCreateManyAssigneeInput[];
   };

   export type TeamMemberCreateWithoutUserInput = {
      id?: string;
      team: TeamCreateNestedOneWithoutMembersInput;
   };

   export type TeamMemberUncheckedCreateWithoutUserInput = {
      id?: string;
      teamId: string;
   };

   export type TeamMemberCreateOrConnectWithoutUserInput = {
      where: TeamMemberWhereUniqueInput;
      create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>;
   };

   export type TeamMemberCreateManyUserInputEnvelope = {
      data: TeamMemberCreateManyUserInput | TeamMemberCreateManyUserInput[];
   };

   export type ProjectCreateWithoutLeadInput = {
      id?: string;
      name: string;
      description?: string | null;
      color?: string | null;
      identifier?: string | null;
      icon?: string | null;
      percentComplete?: number;
      startDate?: Date | string | null;
      health?: $Enums.ProjectHealth;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      issues?: IssueCreateNestedManyWithoutProjectInput;
      teams?: TeamProjectCreateNestedManyWithoutProjectInput;
   };

   export type ProjectUncheckedCreateWithoutLeadInput = {
      id?: string;
      name: string;
      description?: string | null;
      color?: string | null;
      identifier?: string | null;
      icon?: string | null;
      percentComplete?: number;
      startDate?: Date | string | null;
      health?: $Enums.ProjectHealth;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      issues?: IssueUncheckedCreateNestedManyWithoutProjectInput;
      teams?: TeamProjectUncheckedCreateNestedManyWithoutProjectInput;
   };

   export type ProjectCreateOrConnectWithoutLeadInput = {
      where: ProjectWhereUniqueInput;
      create: XOR<ProjectCreateWithoutLeadInput, ProjectUncheckedCreateWithoutLeadInput>;
   };

   export type ProjectCreateManyLeadInputEnvelope = {
      data: ProjectCreateManyLeadInput | ProjectCreateManyLeadInput[];
   };

   export type IssueUpsertWithWhereUniqueWithoutAssigneeInput = {
      where: IssueWhereUniqueInput;
      update: XOR<IssueUpdateWithoutAssigneeInput, IssueUncheckedUpdateWithoutAssigneeInput>;
      create: XOR<IssueCreateWithoutAssigneeInput, IssueUncheckedCreateWithoutAssigneeInput>;
   };

   export type IssueUpdateWithWhereUniqueWithoutAssigneeInput = {
      where: IssueWhereUniqueInput;
      data: XOR<IssueUpdateWithoutAssigneeInput, IssueUncheckedUpdateWithoutAssigneeInput>;
   };

   export type IssueUpdateManyWithWhereWithoutAssigneeInput = {
      where: IssueScalarWhereInput;
      data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyWithoutAssigneeInput>;
   };

   export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
      where: TeamMemberWhereUniqueInput;
      update: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>;
      create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>;
   };

   export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
      where: TeamMemberWhereUniqueInput;
      data: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>;
   };

   export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
      where: TeamMemberScalarWhereInput;
      data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutUserInput>;
   };

   export type TeamMemberScalarWhereInput = {
      AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
      OR?: TeamMemberScalarWhereInput[];
      NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[];
      id?: StringFilter<'TeamMember'> | string;
      teamId?: StringFilter<'TeamMember'> | string;
      userId?: StringFilter<'TeamMember'> | string;
   };

   export type ProjectUpsertWithWhereUniqueWithoutLeadInput = {
      where: ProjectWhereUniqueInput;
      update: XOR<ProjectUpdateWithoutLeadInput, ProjectUncheckedUpdateWithoutLeadInput>;
      create: XOR<ProjectCreateWithoutLeadInput, ProjectUncheckedCreateWithoutLeadInput>;
   };

   export type ProjectUpdateWithWhereUniqueWithoutLeadInput = {
      where: ProjectWhereUniqueInput;
      data: XOR<ProjectUpdateWithoutLeadInput, ProjectUncheckedUpdateWithoutLeadInput>;
   };

   export type ProjectUpdateManyWithWhereWithoutLeadInput = {
      where: ProjectScalarWhereInput;
      data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutLeadInput>;
   };

   export type ProjectScalarWhereInput = {
      AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[];
      OR?: ProjectScalarWhereInput[];
      NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[];
      id?: StringFilter<'Project'> | string;
      name?: StringFilter<'Project'> | string;
      description?: StringNullableFilter<'Project'> | string | null;
      color?: StringNullableFilter<'Project'> | string | null;
      identifier?: StringNullableFilter<'Project'> | string | null;
      icon?: StringNullableFilter<'Project'> | string | null;
      percentComplete?: IntFilter<'Project'> | number;
      startDate?: DateTimeNullableFilter<'Project'> | Date | string | null;
      health?: EnumProjectHealthFilter<'Project'> | $Enums.ProjectHealth;
      leadId?: StringNullableFilter<'Project'> | string | null;
      createdAt?: DateTimeFilter<'Project'> | Date | string;
      updatedAt?: DateTimeFilter<'Project'> | Date | string;
   };

   export type IssueCreateWithoutProjectInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      status?: string | null;
      priority?: string | null;
      rank: string;
      dueDate?: Date | string | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      assignee?: UserCreateNestedOneWithoutAssignedIssuesInput;
      cycle?: CycleCreateNestedOneWithoutIssuesInput;
      task?: TaskCreateNestedOneWithoutIssuesInput;
      issueStatus?: IssueStatusCreateNestedOneWithoutIssuesInput;
      issuePriority?: IssuePriorityCreateNestedOneWithoutIssuesInput;
      labels?: IssueLabelCreateNestedManyWithoutIssueInput;
   };

   export type IssueUncheckedCreateWithoutProjectInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      statusId?: string | null;
      priorityId?: string | null;
      status?: string | null;
      priority?: string | null;
      rank: string;
      cycleId?: string | null;
      dueDate?: Date | string | null;
      taskId?: number | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      assigneeId?: string | null;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      labels?: IssueLabelUncheckedCreateNestedManyWithoutIssueInput;
   };

   export type IssueCreateOrConnectWithoutProjectInput = {
      where: IssueWhereUniqueInput;
      create: XOR<IssueCreateWithoutProjectInput, IssueUncheckedCreateWithoutProjectInput>;
   };

   export type IssueCreateManyProjectInputEnvelope = {
      data: IssueCreateManyProjectInput | IssueCreateManyProjectInput[];
   };

   export type UserCreateWithoutLedProjectsInput = {
      id?: string;
      name: string;
      email: string;
      avatarUrl?: string | null;
      status?: $Enums.UserStatus;
      role?: $Enums.UserRole;
      joinedDate: Date | string;
      teamIds?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      assignedIssues?: IssueCreateNestedManyWithoutAssigneeInput;
      teams?: TeamMemberCreateNestedManyWithoutUserInput;
   };

   export type UserUncheckedCreateWithoutLedProjectsInput = {
      id?: string;
      name: string;
      email: string;
      avatarUrl?: string | null;
      status?: $Enums.UserStatus;
      role?: $Enums.UserRole;
      joinedDate: Date | string;
      teamIds?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      assignedIssues?: IssueUncheckedCreateNestedManyWithoutAssigneeInput;
      teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
   };

   export type UserCreateOrConnectWithoutLedProjectsInput = {
      where: UserWhereUniqueInput;
      create: XOR<UserCreateWithoutLedProjectsInput, UserUncheckedCreateWithoutLedProjectsInput>;
   };

   export type TeamProjectCreateWithoutProjectInput = {
      id?: string;
      team: TeamCreateNestedOneWithoutProjectsInput;
   };

   export type TeamProjectUncheckedCreateWithoutProjectInput = {
      id?: string;
      teamId: string;
   };

   export type TeamProjectCreateOrConnectWithoutProjectInput = {
      where: TeamProjectWhereUniqueInput;
      create: XOR<
         TeamProjectCreateWithoutProjectInput,
         TeamProjectUncheckedCreateWithoutProjectInput
      >;
   };

   export type TeamProjectCreateManyProjectInputEnvelope = {
      data: TeamProjectCreateManyProjectInput | TeamProjectCreateManyProjectInput[];
   };

   export type IssueUpsertWithWhereUniqueWithoutProjectInput = {
      where: IssueWhereUniqueInput;
      update: XOR<IssueUpdateWithoutProjectInput, IssueUncheckedUpdateWithoutProjectInput>;
      create: XOR<IssueCreateWithoutProjectInput, IssueUncheckedCreateWithoutProjectInput>;
   };

   export type IssueUpdateWithWhereUniqueWithoutProjectInput = {
      where: IssueWhereUniqueInput;
      data: XOR<IssueUpdateWithoutProjectInput, IssueUncheckedUpdateWithoutProjectInput>;
   };

   export type IssueUpdateManyWithWhereWithoutProjectInput = {
      where: IssueScalarWhereInput;
      data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyWithoutProjectInput>;
   };

   export type UserUpsertWithoutLedProjectsInput = {
      update: XOR<UserUpdateWithoutLedProjectsInput, UserUncheckedUpdateWithoutLedProjectsInput>;
      create: XOR<UserCreateWithoutLedProjectsInput, UserUncheckedCreateWithoutLedProjectsInput>;
      where?: UserWhereInput;
   };

   export type UserUpdateToOneWithWhereWithoutLedProjectsInput = {
      where?: UserWhereInput;
      data: XOR<UserUpdateWithoutLedProjectsInput, UserUncheckedUpdateWithoutLedProjectsInput>;
   };

   export type UserUpdateWithoutLedProjectsInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      email?: StringFieldUpdateOperationsInput | string;
      avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
      role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
      joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      teamIds?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      assignedIssues?: IssueUpdateManyWithoutAssigneeNestedInput;
      teams?: TeamMemberUpdateManyWithoutUserNestedInput;
   };

   export type UserUncheckedUpdateWithoutLedProjectsInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      email?: StringFieldUpdateOperationsInput | string;
      avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
      role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
      joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      teamIds?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      assignedIssues?: IssueUncheckedUpdateManyWithoutAssigneeNestedInput;
      teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
   };

   export type TeamProjectUpsertWithWhereUniqueWithoutProjectInput = {
      where: TeamProjectWhereUniqueInput;
      update: XOR<
         TeamProjectUpdateWithoutProjectInput,
         TeamProjectUncheckedUpdateWithoutProjectInput
      >;
      create: XOR<
         TeamProjectCreateWithoutProjectInput,
         TeamProjectUncheckedCreateWithoutProjectInput
      >;
   };

   export type TeamProjectUpdateWithWhereUniqueWithoutProjectInput = {
      where: TeamProjectWhereUniqueInput;
      data: XOR<
         TeamProjectUpdateWithoutProjectInput,
         TeamProjectUncheckedUpdateWithoutProjectInput
      >;
   };

   export type TeamProjectUpdateManyWithWhereWithoutProjectInput = {
      where: TeamProjectScalarWhereInput;
      data: XOR<
         TeamProjectUpdateManyMutationInput,
         TeamProjectUncheckedUpdateManyWithoutProjectInput
      >;
   };

   export type TeamProjectScalarWhereInput = {
      AND?: TeamProjectScalarWhereInput | TeamProjectScalarWhereInput[];
      OR?: TeamProjectScalarWhereInput[];
      NOT?: TeamProjectScalarWhereInput | TeamProjectScalarWhereInput[];
      id?: StringFilter<'TeamProject'> | string;
      teamId?: StringFilter<'TeamProject'> | string;
      projectId?: StringFilter<'TeamProject'> | string;
   };

   export type IssueLabelCreateWithoutLabelInput = {
      id?: string;
      issue: IssueCreateNestedOneWithoutLabelsInput;
   };

   export type IssueLabelUncheckedCreateWithoutLabelInput = {
      id?: string;
      issueId: string;
   };

   export type IssueLabelCreateOrConnectWithoutLabelInput = {
      where: IssueLabelWhereUniqueInput;
      create: XOR<IssueLabelCreateWithoutLabelInput, IssueLabelUncheckedCreateWithoutLabelInput>;
   };

   export type IssueLabelCreateManyLabelInputEnvelope = {
      data: IssueLabelCreateManyLabelInput | IssueLabelCreateManyLabelInput[];
   };

   export type IssueLabelUpsertWithWhereUniqueWithoutLabelInput = {
      where: IssueLabelWhereUniqueInput;
      update: XOR<IssueLabelUpdateWithoutLabelInput, IssueLabelUncheckedUpdateWithoutLabelInput>;
      create: XOR<IssueLabelCreateWithoutLabelInput, IssueLabelUncheckedCreateWithoutLabelInput>;
   };

   export type IssueLabelUpdateWithWhereUniqueWithoutLabelInput = {
      where: IssueLabelWhereUniqueInput;
      data: XOR<IssueLabelUpdateWithoutLabelInput, IssueLabelUncheckedUpdateWithoutLabelInput>;
   };

   export type IssueLabelUpdateManyWithWhereWithoutLabelInput = {
      where: IssueLabelScalarWhereInput;
      data: XOR<IssueLabelUpdateManyMutationInput, IssueLabelUncheckedUpdateManyWithoutLabelInput>;
   };

   export type IssueLabelScalarWhereInput = {
      AND?: IssueLabelScalarWhereInput | IssueLabelScalarWhereInput[];
      OR?: IssueLabelScalarWhereInput[];
      NOT?: IssueLabelScalarWhereInput | IssueLabelScalarWhereInput[];
      id?: StringFilter<'IssueLabel'> | string;
      issueId?: StringFilter<'IssueLabel'> | string;
      labelId?: StringFilter<'IssueLabel'> | string;
   };

   export type IssueCreateWithoutIssueStatusInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      status?: string | null;
      priority?: string | null;
      rank: string;
      dueDate?: Date | string | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      assignee?: UserCreateNestedOneWithoutAssignedIssuesInput;
      project?: ProjectCreateNestedOneWithoutIssuesInput;
      cycle?: CycleCreateNestedOneWithoutIssuesInput;
      task?: TaskCreateNestedOneWithoutIssuesInput;
      issuePriority?: IssuePriorityCreateNestedOneWithoutIssuesInput;
      labels?: IssueLabelCreateNestedManyWithoutIssueInput;
   };

   export type IssueUncheckedCreateWithoutIssueStatusInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      priorityId?: string | null;
      status?: string | null;
      priority?: string | null;
      rank: string;
      cycleId?: string | null;
      dueDate?: Date | string | null;
      taskId?: number | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      assigneeId?: string | null;
      projectId?: string | null;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      labels?: IssueLabelUncheckedCreateNestedManyWithoutIssueInput;
   };

   export type IssueCreateOrConnectWithoutIssueStatusInput = {
      where: IssueWhereUniqueInput;
      create: XOR<IssueCreateWithoutIssueStatusInput, IssueUncheckedCreateWithoutIssueStatusInput>;
   };

   export type IssueCreateManyIssueStatusInputEnvelope = {
      data: IssueCreateManyIssueStatusInput | IssueCreateManyIssueStatusInput[];
   };

   export type IssueUpsertWithWhereUniqueWithoutIssueStatusInput = {
      where: IssueWhereUniqueInput;
      update: XOR<IssueUpdateWithoutIssueStatusInput, IssueUncheckedUpdateWithoutIssueStatusInput>;
      create: XOR<IssueCreateWithoutIssueStatusInput, IssueUncheckedCreateWithoutIssueStatusInput>;
   };

   export type IssueUpdateWithWhereUniqueWithoutIssueStatusInput = {
      where: IssueWhereUniqueInput;
      data: XOR<IssueUpdateWithoutIssueStatusInput, IssueUncheckedUpdateWithoutIssueStatusInput>;
   };

   export type IssueUpdateManyWithWhereWithoutIssueStatusInput = {
      where: IssueScalarWhereInput;
      data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyWithoutIssueStatusInput>;
   };

   export type IssueCreateWithoutIssuePriorityInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      status?: string | null;
      priority?: string | null;
      rank: string;
      dueDate?: Date | string | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      assignee?: UserCreateNestedOneWithoutAssignedIssuesInput;
      project?: ProjectCreateNestedOneWithoutIssuesInput;
      cycle?: CycleCreateNestedOneWithoutIssuesInput;
      task?: TaskCreateNestedOneWithoutIssuesInput;
      issueStatus?: IssueStatusCreateNestedOneWithoutIssuesInput;
      labels?: IssueLabelCreateNestedManyWithoutIssueInput;
   };

   export type IssueUncheckedCreateWithoutIssuePriorityInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      statusId?: string | null;
      status?: string | null;
      priority?: string | null;
      rank: string;
      cycleId?: string | null;
      dueDate?: Date | string | null;
      taskId?: number | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      assigneeId?: string | null;
      projectId?: string | null;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      labels?: IssueLabelUncheckedCreateNestedManyWithoutIssueInput;
   };

   export type IssueCreateOrConnectWithoutIssuePriorityInput = {
      where: IssueWhereUniqueInput;
      create: XOR<
         IssueCreateWithoutIssuePriorityInput,
         IssueUncheckedCreateWithoutIssuePriorityInput
      >;
   };

   export type IssueCreateManyIssuePriorityInputEnvelope = {
      data: IssueCreateManyIssuePriorityInput | IssueCreateManyIssuePriorityInput[];
   };

   export type IssueUpsertWithWhereUniqueWithoutIssuePriorityInput = {
      where: IssueWhereUniqueInput;
      update: XOR<
         IssueUpdateWithoutIssuePriorityInput,
         IssueUncheckedUpdateWithoutIssuePriorityInput
      >;
      create: XOR<
         IssueCreateWithoutIssuePriorityInput,
         IssueUncheckedCreateWithoutIssuePriorityInput
      >;
   };

   export type IssueUpdateWithWhereUniqueWithoutIssuePriorityInput = {
      where: IssueWhereUniqueInput;
      data: XOR<
         IssueUpdateWithoutIssuePriorityInput,
         IssueUncheckedUpdateWithoutIssuePriorityInput
      >;
   };

   export type IssueUpdateManyWithWhereWithoutIssuePriorityInput = {
      where: IssueScalarWhereInput;
      data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyWithoutIssuePriorityInput>;
   };

   export type UserCreateWithoutAssignedIssuesInput = {
      id?: string;
      name: string;
      email: string;
      avatarUrl?: string | null;
      status?: $Enums.UserStatus;
      role?: $Enums.UserRole;
      joinedDate: Date | string;
      teamIds?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      teams?: TeamMemberCreateNestedManyWithoutUserInput;
      ledProjects?: ProjectCreateNestedManyWithoutLeadInput;
   };

   export type UserUncheckedCreateWithoutAssignedIssuesInput = {
      id?: string;
      name: string;
      email: string;
      avatarUrl?: string | null;
      status?: $Enums.UserStatus;
      role?: $Enums.UserRole;
      joinedDate: Date | string;
      teamIds?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      teams?: TeamMemberUncheckedCreateNestedManyWithoutUserInput;
      ledProjects?: ProjectUncheckedCreateNestedManyWithoutLeadInput;
   };

   export type UserCreateOrConnectWithoutAssignedIssuesInput = {
      where: UserWhereUniqueInput;
      create: XOR<
         UserCreateWithoutAssignedIssuesInput,
         UserUncheckedCreateWithoutAssignedIssuesInput
      >;
   };

   export type ProjectCreateWithoutIssuesInput = {
      id?: string;
      name: string;
      description?: string | null;
      color?: string | null;
      identifier?: string | null;
      icon?: string | null;
      percentComplete?: number;
      startDate?: Date | string | null;
      health?: $Enums.ProjectHealth;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      lead?: UserCreateNestedOneWithoutLedProjectsInput;
      teams?: TeamProjectCreateNestedManyWithoutProjectInput;
   };

   export type ProjectUncheckedCreateWithoutIssuesInput = {
      id?: string;
      name: string;
      description?: string | null;
      color?: string | null;
      identifier?: string | null;
      icon?: string | null;
      percentComplete?: number;
      startDate?: Date | string | null;
      health?: $Enums.ProjectHealth;
      leadId?: string | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      teams?: TeamProjectUncheckedCreateNestedManyWithoutProjectInput;
   };

   export type ProjectCreateOrConnectWithoutIssuesInput = {
      where: ProjectWhereUniqueInput;
      create: XOR<ProjectCreateWithoutIssuesInput, ProjectUncheckedCreateWithoutIssuesInput>;
   };

   export type CycleCreateWithoutIssuesInput = {
      id?: string;
      number: number;
      name: string;
      startDate: Date | string;
      endDate: Date | string;
      progress?: number;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      team: TeamCreateNestedOneWithoutCyclesInput;
   };

   export type CycleUncheckedCreateWithoutIssuesInput = {
      id?: string;
      number: number;
      name: string;
      teamId: string;
      startDate: Date | string;
      endDate: Date | string;
      progress?: number;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type CycleCreateOrConnectWithoutIssuesInput = {
      where: CycleWhereUniqueInput;
      create: XOR<CycleCreateWithoutIssuesInput, CycleUncheckedCreateWithoutIssuesInput>;
   };

   export type TaskCreateWithoutIssuesInput = {
      id: number;
      title: string;
      description: string;
      details?: string | null;
      testStrategy?: string | null;
      priority: string;
      status: string;
      complexity?: number | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      subtasks?: SubtaskCreateNestedManyWithoutParentTaskInput;
      dependencies?: TaskDependencyCreateNestedManyWithoutTaskInput;
      dependents?: TaskDependencyCreateNestedManyWithoutDependsOnInput;
   };

   export type TaskUncheckedCreateWithoutIssuesInput = {
      id: number;
      title: string;
      description: string;
      details?: string | null;
      testStrategy?: string | null;
      priority: string;
      status: string;
      complexity?: number | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      subtasks?: SubtaskUncheckedCreateNestedManyWithoutParentTaskInput;
      dependencies?: TaskDependencyUncheckedCreateNestedManyWithoutTaskInput;
      dependents?: TaskDependencyUncheckedCreateNestedManyWithoutDependsOnInput;
   };

   export type TaskCreateOrConnectWithoutIssuesInput = {
      where: TaskWhereUniqueInput;
      create: XOR<TaskCreateWithoutIssuesInput, TaskUncheckedCreateWithoutIssuesInput>;
   };

   export type IssueStatusCreateWithoutIssuesInput = {
      id: string;
      name: string;
      color: string;
      iconName: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type IssueStatusUncheckedCreateWithoutIssuesInput = {
      id: string;
      name: string;
      color: string;
      iconName: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type IssueStatusCreateOrConnectWithoutIssuesInput = {
      where: IssueStatusWhereUniqueInput;
      create: XOR<
         IssueStatusCreateWithoutIssuesInput,
         IssueStatusUncheckedCreateWithoutIssuesInput
      >;
   };

   export type IssuePriorityCreateWithoutIssuesInput = {
      id: string;
      name: string;
      iconName: string;
      order: number;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type IssuePriorityUncheckedCreateWithoutIssuesInput = {
      id: string;
      name: string;
      iconName: string;
      order: number;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type IssuePriorityCreateOrConnectWithoutIssuesInput = {
      where: IssuePriorityWhereUniqueInput;
      create: XOR<
         IssuePriorityCreateWithoutIssuesInput,
         IssuePriorityUncheckedCreateWithoutIssuesInput
      >;
   };

   export type IssueLabelCreateWithoutIssueInput = {
      id?: string;
      label: LabelCreateNestedOneWithoutIssuesInput;
   };

   export type IssueLabelUncheckedCreateWithoutIssueInput = {
      id?: string;
      labelId: string;
   };

   export type IssueLabelCreateOrConnectWithoutIssueInput = {
      where: IssueLabelWhereUniqueInput;
      create: XOR<IssueLabelCreateWithoutIssueInput, IssueLabelUncheckedCreateWithoutIssueInput>;
   };

   export type IssueLabelCreateManyIssueInputEnvelope = {
      data: IssueLabelCreateManyIssueInput | IssueLabelCreateManyIssueInput[];
   };

   export type UserUpsertWithoutAssignedIssuesInput = {
      update: XOR<
         UserUpdateWithoutAssignedIssuesInput,
         UserUncheckedUpdateWithoutAssignedIssuesInput
      >;
      create: XOR<
         UserCreateWithoutAssignedIssuesInput,
         UserUncheckedCreateWithoutAssignedIssuesInput
      >;
      where?: UserWhereInput;
   };

   export type UserUpdateToOneWithWhereWithoutAssignedIssuesInput = {
      where?: UserWhereInput;
      data: XOR<
         UserUpdateWithoutAssignedIssuesInput,
         UserUncheckedUpdateWithoutAssignedIssuesInput
      >;
   };

   export type UserUpdateWithoutAssignedIssuesInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      email?: StringFieldUpdateOperationsInput | string;
      avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
      role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
      joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      teamIds?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      teams?: TeamMemberUpdateManyWithoutUserNestedInput;
      ledProjects?: ProjectUpdateManyWithoutLeadNestedInput;
   };

   export type UserUncheckedUpdateWithoutAssignedIssuesInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      email?: StringFieldUpdateOperationsInput | string;
      avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
      role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
      joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      teamIds?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      teams?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput;
      ledProjects?: ProjectUncheckedUpdateManyWithoutLeadNestedInput;
   };

   export type ProjectUpsertWithoutIssuesInput = {
      update: XOR<ProjectUpdateWithoutIssuesInput, ProjectUncheckedUpdateWithoutIssuesInput>;
      create: XOR<ProjectCreateWithoutIssuesInput, ProjectUncheckedCreateWithoutIssuesInput>;
      where?: ProjectWhereInput;
   };

   export type ProjectUpdateToOneWithWhereWithoutIssuesInput = {
      where?: ProjectWhereInput;
      data: XOR<ProjectUpdateWithoutIssuesInput, ProjectUncheckedUpdateWithoutIssuesInput>;
   };

   export type ProjectUpdateWithoutIssuesInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      description?: NullableStringFieldUpdateOperationsInput | string | null;
      color?: NullableStringFieldUpdateOperationsInput | string | null;
      identifier?: NullableStringFieldUpdateOperationsInput | string | null;
      icon?: NullableStringFieldUpdateOperationsInput | string | null;
      percentComplete?: IntFieldUpdateOperationsInput | number;
      startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      health?: EnumProjectHealthFieldUpdateOperationsInput | $Enums.ProjectHealth;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      lead?: UserUpdateOneWithoutLedProjectsNestedInput;
      teams?: TeamProjectUpdateManyWithoutProjectNestedInput;
   };

   export type ProjectUncheckedUpdateWithoutIssuesInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      description?: NullableStringFieldUpdateOperationsInput | string | null;
      color?: NullableStringFieldUpdateOperationsInput | string | null;
      identifier?: NullableStringFieldUpdateOperationsInput | string | null;
      icon?: NullableStringFieldUpdateOperationsInput | string | null;
      percentComplete?: IntFieldUpdateOperationsInput | number;
      startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      health?: EnumProjectHealthFieldUpdateOperationsInput | $Enums.ProjectHealth;
      leadId?: NullableStringFieldUpdateOperationsInput | string | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      teams?: TeamProjectUncheckedUpdateManyWithoutProjectNestedInput;
   };

   export type CycleUpsertWithoutIssuesInput = {
      update: XOR<CycleUpdateWithoutIssuesInput, CycleUncheckedUpdateWithoutIssuesInput>;
      create: XOR<CycleCreateWithoutIssuesInput, CycleUncheckedCreateWithoutIssuesInput>;
      where?: CycleWhereInput;
   };

   export type CycleUpdateToOneWithWhereWithoutIssuesInput = {
      where?: CycleWhereInput;
      data: XOR<CycleUpdateWithoutIssuesInput, CycleUncheckedUpdateWithoutIssuesInput>;
   };

   export type CycleUpdateWithoutIssuesInput = {
      id?: StringFieldUpdateOperationsInput | string;
      number?: IntFieldUpdateOperationsInput | number;
      name?: StringFieldUpdateOperationsInput | string;
      startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      progress?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      team?: TeamUpdateOneRequiredWithoutCyclesNestedInput;
   };

   export type CycleUncheckedUpdateWithoutIssuesInput = {
      id?: StringFieldUpdateOperationsInput | string;
      number?: IntFieldUpdateOperationsInput | number;
      name?: StringFieldUpdateOperationsInput | string;
      teamId?: StringFieldUpdateOperationsInput | string;
      startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      progress?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type TaskUpsertWithoutIssuesInput = {
      update: XOR<TaskUpdateWithoutIssuesInput, TaskUncheckedUpdateWithoutIssuesInput>;
      create: XOR<TaskCreateWithoutIssuesInput, TaskUncheckedCreateWithoutIssuesInput>;
      where?: TaskWhereInput;
   };

   export type TaskUpdateToOneWithWhereWithoutIssuesInput = {
      where?: TaskWhereInput;
      data: XOR<TaskUpdateWithoutIssuesInput, TaskUncheckedUpdateWithoutIssuesInput>;
   };

   export type TaskUpdateWithoutIssuesInput = {
      id?: IntFieldUpdateOperationsInput | number;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: StringFieldUpdateOperationsInput | string;
      status?: StringFieldUpdateOperationsInput | string;
      complexity?: NullableIntFieldUpdateOperationsInput | number | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      subtasks?: SubtaskUpdateManyWithoutParentTaskNestedInput;
      dependencies?: TaskDependencyUpdateManyWithoutTaskNestedInput;
      dependents?: TaskDependencyUpdateManyWithoutDependsOnNestedInput;
   };

   export type TaskUncheckedUpdateWithoutIssuesInput = {
      id?: IntFieldUpdateOperationsInput | number;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: StringFieldUpdateOperationsInput | string;
      status?: StringFieldUpdateOperationsInput | string;
      complexity?: NullableIntFieldUpdateOperationsInput | number | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      subtasks?: SubtaskUncheckedUpdateManyWithoutParentTaskNestedInput;
      dependencies?: TaskDependencyUncheckedUpdateManyWithoutTaskNestedInput;
      dependents?: TaskDependencyUncheckedUpdateManyWithoutDependsOnNestedInput;
   };

   export type IssueStatusUpsertWithoutIssuesInput = {
      update: XOR<
         IssueStatusUpdateWithoutIssuesInput,
         IssueStatusUncheckedUpdateWithoutIssuesInput
      >;
      create: XOR<
         IssueStatusCreateWithoutIssuesInput,
         IssueStatusUncheckedCreateWithoutIssuesInput
      >;
      where?: IssueStatusWhereInput;
   };

   export type IssueStatusUpdateToOneWithWhereWithoutIssuesInput = {
      where?: IssueStatusWhereInput;
      data: XOR<IssueStatusUpdateWithoutIssuesInput, IssueStatusUncheckedUpdateWithoutIssuesInput>;
   };

   export type IssueStatusUpdateWithoutIssuesInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      color?: StringFieldUpdateOperationsInput | string;
      iconName?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type IssueStatusUncheckedUpdateWithoutIssuesInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      color?: StringFieldUpdateOperationsInput | string;
      iconName?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type IssuePriorityUpsertWithoutIssuesInput = {
      update: XOR<
         IssuePriorityUpdateWithoutIssuesInput,
         IssuePriorityUncheckedUpdateWithoutIssuesInput
      >;
      create: XOR<
         IssuePriorityCreateWithoutIssuesInput,
         IssuePriorityUncheckedCreateWithoutIssuesInput
      >;
      where?: IssuePriorityWhereInput;
   };

   export type IssuePriorityUpdateToOneWithWhereWithoutIssuesInput = {
      where?: IssuePriorityWhereInput;
      data: XOR<
         IssuePriorityUpdateWithoutIssuesInput,
         IssuePriorityUncheckedUpdateWithoutIssuesInput
      >;
   };

   export type IssuePriorityUpdateWithoutIssuesInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      iconName?: StringFieldUpdateOperationsInput | string;
      order?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type IssuePriorityUncheckedUpdateWithoutIssuesInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      iconName?: StringFieldUpdateOperationsInput | string;
      order?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type IssueLabelUpsertWithWhereUniqueWithoutIssueInput = {
      where: IssueLabelWhereUniqueInput;
      update: XOR<IssueLabelUpdateWithoutIssueInput, IssueLabelUncheckedUpdateWithoutIssueInput>;
      create: XOR<IssueLabelCreateWithoutIssueInput, IssueLabelUncheckedCreateWithoutIssueInput>;
   };

   export type IssueLabelUpdateWithWhereUniqueWithoutIssueInput = {
      where: IssueLabelWhereUniqueInput;
      data: XOR<IssueLabelUpdateWithoutIssueInput, IssueLabelUncheckedUpdateWithoutIssueInput>;
   };

   export type IssueLabelUpdateManyWithWhereWithoutIssueInput = {
      where: IssueLabelScalarWhereInput;
      data: XOR<IssueLabelUpdateManyMutationInput, IssueLabelUncheckedUpdateManyWithoutIssueInput>;
   };

   export type IssueCreateWithoutLabelsInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      status?: string | null;
      priority?: string | null;
      rank: string;
      dueDate?: Date | string | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      assignee?: UserCreateNestedOneWithoutAssignedIssuesInput;
      project?: ProjectCreateNestedOneWithoutIssuesInput;
      cycle?: CycleCreateNestedOneWithoutIssuesInput;
      task?: TaskCreateNestedOneWithoutIssuesInput;
      issueStatus?: IssueStatusCreateNestedOneWithoutIssuesInput;
      issuePriority?: IssuePriorityCreateNestedOneWithoutIssuesInput;
   };

   export type IssueUncheckedCreateWithoutLabelsInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      statusId?: string | null;
      priorityId?: string | null;
      status?: string | null;
      priority?: string | null;
      rank: string;
      cycleId?: string | null;
      dueDate?: Date | string | null;
      taskId?: number | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      assigneeId?: string | null;
      projectId?: string | null;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type IssueCreateOrConnectWithoutLabelsInput = {
      where: IssueWhereUniqueInput;
      create: XOR<IssueCreateWithoutLabelsInput, IssueUncheckedCreateWithoutLabelsInput>;
   };

   export type LabelCreateWithoutIssuesInput = {
      id?: string;
      name: string;
      color: string;
      description?: string | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type LabelUncheckedCreateWithoutIssuesInput = {
      id?: string;
      name: string;
      color: string;
      description?: string | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type LabelCreateOrConnectWithoutIssuesInput = {
      where: LabelWhereUniqueInput;
      create: XOR<LabelCreateWithoutIssuesInput, LabelUncheckedCreateWithoutIssuesInput>;
   };

   export type IssueUpsertWithoutLabelsInput = {
      update: XOR<IssueUpdateWithoutLabelsInput, IssueUncheckedUpdateWithoutLabelsInput>;
      create: XOR<IssueCreateWithoutLabelsInput, IssueUncheckedCreateWithoutLabelsInput>;
      where?: IssueWhereInput;
   };

   export type IssueUpdateToOneWithWhereWithoutLabelsInput = {
      where?: IssueWhereInput;
      data: XOR<IssueUpdateWithoutLabelsInput, IssueUncheckedUpdateWithoutLabelsInput>;
   };

   export type IssueUpdateWithoutLabelsInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      assignee?: UserUpdateOneWithoutAssignedIssuesNestedInput;
      project?: ProjectUpdateOneWithoutIssuesNestedInput;
      cycle?: CycleUpdateOneWithoutIssuesNestedInput;
      task?: TaskUpdateOneWithoutIssuesNestedInput;
      issueStatus?: IssueStatusUpdateOneWithoutIssuesNestedInput;
      issuePriority?: IssuePriorityUpdateOneWithoutIssuesNestedInput;
   };

   export type IssueUncheckedUpdateWithoutLabelsInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      statusId?: NullableStringFieldUpdateOperationsInput | string | null;
      priorityId?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      cycleId?: NullableStringFieldUpdateOperationsInput | string | null;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      taskId?: NullableIntFieldUpdateOperationsInput | number | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      assigneeId?: NullableStringFieldUpdateOperationsInput | string | null;
      projectId?: NullableStringFieldUpdateOperationsInput | string | null;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type LabelUpsertWithoutIssuesInput = {
      update: XOR<LabelUpdateWithoutIssuesInput, LabelUncheckedUpdateWithoutIssuesInput>;
      create: XOR<LabelCreateWithoutIssuesInput, LabelUncheckedCreateWithoutIssuesInput>;
      where?: LabelWhereInput;
   };

   export type LabelUpdateToOneWithWhereWithoutIssuesInput = {
      where?: LabelWhereInput;
      data: XOR<LabelUpdateWithoutIssuesInput, LabelUncheckedUpdateWithoutIssuesInput>;
   };

   export type LabelUpdateWithoutIssuesInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      color?: StringFieldUpdateOperationsInput | string;
      description?: NullableStringFieldUpdateOperationsInput | string | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type LabelUncheckedUpdateWithoutIssuesInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      color?: StringFieldUpdateOperationsInput | string;
      description?: NullableStringFieldUpdateOperationsInput | string | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type TeamCreateWithoutCyclesInput = {
      id?: string;
      name: string;
      icon: string;
      joined?: boolean;
      color: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      members?: TeamMemberCreateNestedManyWithoutTeamInput;
      projects?: TeamProjectCreateNestedManyWithoutTeamInput;
   };

   export type TeamUncheckedCreateWithoutCyclesInput = {
      id?: string;
      name: string;
      icon: string;
      joined?: boolean;
      color: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput;
      projects?: TeamProjectUncheckedCreateNestedManyWithoutTeamInput;
   };

   export type TeamCreateOrConnectWithoutCyclesInput = {
      where: TeamWhereUniqueInput;
      create: XOR<TeamCreateWithoutCyclesInput, TeamUncheckedCreateWithoutCyclesInput>;
   };

   export type IssueCreateWithoutCycleInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      status?: string | null;
      priority?: string | null;
      rank: string;
      dueDate?: Date | string | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      assignee?: UserCreateNestedOneWithoutAssignedIssuesInput;
      project?: ProjectCreateNestedOneWithoutIssuesInput;
      task?: TaskCreateNestedOneWithoutIssuesInput;
      issueStatus?: IssueStatusCreateNestedOneWithoutIssuesInput;
      issuePriority?: IssuePriorityCreateNestedOneWithoutIssuesInput;
      labels?: IssueLabelCreateNestedManyWithoutIssueInput;
   };

   export type IssueUncheckedCreateWithoutCycleInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      statusId?: string | null;
      priorityId?: string | null;
      status?: string | null;
      priority?: string | null;
      rank: string;
      dueDate?: Date | string | null;
      taskId?: number | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      assigneeId?: string | null;
      projectId?: string | null;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      labels?: IssueLabelUncheckedCreateNestedManyWithoutIssueInput;
   };

   export type IssueCreateOrConnectWithoutCycleInput = {
      where: IssueWhereUniqueInput;
      create: XOR<IssueCreateWithoutCycleInput, IssueUncheckedCreateWithoutCycleInput>;
   };

   export type IssueCreateManyCycleInputEnvelope = {
      data: IssueCreateManyCycleInput | IssueCreateManyCycleInput[];
   };

   export type TeamUpsertWithoutCyclesInput = {
      update: XOR<TeamUpdateWithoutCyclesInput, TeamUncheckedUpdateWithoutCyclesInput>;
      create: XOR<TeamCreateWithoutCyclesInput, TeamUncheckedCreateWithoutCyclesInput>;
      where?: TeamWhereInput;
   };

   export type TeamUpdateToOneWithWhereWithoutCyclesInput = {
      where?: TeamWhereInput;
      data: XOR<TeamUpdateWithoutCyclesInput, TeamUncheckedUpdateWithoutCyclesInput>;
   };

   export type TeamUpdateWithoutCyclesInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      icon?: StringFieldUpdateOperationsInput | string;
      joined?: BoolFieldUpdateOperationsInput | boolean;
      color?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      members?: TeamMemberUpdateManyWithoutTeamNestedInput;
      projects?: TeamProjectUpdateManyWithoutTeamNestedInput;
   };

   export type TeamUncheckedUpdateWithoutCyclesInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      icon?: StringFieldUpdateOperationsInput | string;
      joined?: BoolFieldUpdateOperationsInput | boolean;
      color?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput;
      projects?: TeamProjectUncheckedUpdateManyWithoutTeamNestedInput;
   };

   export type IssueUpsertWithWhereUniqueWithoutCycleInput = {
      where: IssueWhereUniqueInput;
      update: XOR<IssueUpdateWithoutCycleInput, IssueUncheckedUpdateWithoutCycleInput>;
      create: XOR<IssueCreateWithoutCycleInput, IssueUncheckedCreateWithoutCycleInput>;
   };

   export type IssueUpdateWithWhereUniqueWithoutCycleInput = {
      where: IssueWhereUniqueInput;
      data: XOR<IssueUpdateWithoutCycleInput, IssueUncheckedUpdateWithoutCycleInput>;
   };

   export type IssueUpdateManyWithWhereWithoutCycleInput = {
      where: IssueScalarWhereInput;
      data: XOR<IssueUpdateManyMutationInput, IssueUncheckedUpdateManyWithoutCycleInput>;
   };

   export type TeamMemberCreateWithoutTeamInput = {
      id?: string;
      user: UserCreateNestedOneWithoutTeamsInput;
   };

   export type TeamMemberUncheckedCreateWithoutTeamInput = {
      id?: string;
      userId: string;
   };

   export type TeamMemberCreateOrConnectWithoutTeamInput = {
      where: TeamMemberWhereUniqueInput;
      create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>;
   };

   export type TeamMemberCreateManyTeamInputEnvelope = {
      data: TeamMemberCreateManyTeamInput | TeamMemberCreateManyTeamInput[];
   };

   export type TeamProjectCreateWithoutTeamInput = {
      id?: string;
      project: ProjectCreateNestedOneWithoutTeamsInput;
   };

   export type TeamProjectUncheckedCreateWithoutTeamInput = {
      id?: string;
      projectId: string;
   };

   export type TeamProjectCreateOrConnectWithoutTeamInput = {
      where: TeamProjectWhereUniqueInput;
      create: XOR<TeamProjectCreateWithoutTeamInput, TeamProjectUncheckedCreateWithoutTeamInput>;
   };

   export type TeamProjectCreateManyTeamInputEnvelope = {
      data: TeamProjectCreateManyTeamInput | TeamProjectCreateManyTeamInput[];
   };

   export type CycleCreateWithoutTeamInput = {
      id?: string;
      number: number;
      name: string;
      startDate: Date | string;
      endDate: Date | string;
      progress?: number;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      issues?: IssueCreateNestedManyWithoutCycleInput;
   };

   export type CycleUncheckedCreateWithoutTeamInput = {
      id?: string;
      number: number;
      name: string;
      startDate: Date | string;
      endDate: Date | string;
      progress?: number;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      issues?: IssueUncheckedCreateNestedManyWithoutCycleInput;
   };

   export type CycleCreateOrConnectWithoutTeamInput = {
      where: CycleWhereUniqueInput;
      create: XOR<CycleCreateWithoutTeamInput, CycleUncheckedCreateWithoutTeamInput>;
   };

   export type CycleCreateManyTeamInputEnvelope = {
      data: CycleCreateManyTeamInput | CycleCreateManyTeamInput[];
   };

   export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
      where: TeamMemberWhereUniqueInput;
      update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>;
      create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>;
   };

   export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
      where: TeamMemberWhereUniqueInput;
      data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>;
   };

   export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
      where: TeamMemberScalarWhereInput;
      data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamInput>;
   };

   export type TeamProjectUpsertWithWhereUniqueWithoutTeamInput = {
      where: TeamProjectWhereUniqueInput;
      update: XOR<TeamProjectUpdateWithoutTeamInput, TeamProjectUncheckedUpdateWithoutTeamInput>;
      create: XOR<TeamProjectCreateWithoutTeamInput, TeamProjectUncheckedCreateWithoutTeamInput>;
   };

   export type TeamProjectUpdateWithWhereUniqueWithoutTeamInput = {
      where: TeamProjectWhereUniqueInput;
      data: XOR<TeamProjectUpdateWithoutTeamInput, TeamProjectUncheckedUpdateWithoutTeamInput>;
   };

   export type TeamProjectUpdateManyWithWhereWithoutTeamInput = {
      where: TeamProjectScalarWhereInput;
      data: XOR<TeamProjectUpdateManyMutationInput, TeamProjectUncheckedUpdateManyWithoutTeamInput>;
   };

   export type CycleUpsertWithWhereUniqueWithoutTeamInput = {
      where: CycleWhereUniqueInput;
      update: XOR<CycleUpdateWithoutTeamInput, CycleUncheckedUpdateWithoutTeamInput>;
      create: XOR<CycleCreateWithoutTeamInput, CycleUncheckedCreateWithoutTeamInput>;
   };

   export type CycleUpdateWithWhereUniqueWithoutTeamInput = {
      where: CycleWhereUniqueInput;
      data: XOR<CycleUpdateWithoutTeamInput, CycleUncheckedUpdateWithoutTeamInput>;
   };

   export type CycleUpdateManyWithWhereWithoutTeamInput = {
      where: CycleScalarWhereInput;
      data: XOR<CycleUpdateManyMutationInput, CycleUncheckedUpdateManyWithoutTeamInput>;
   };

   export type CycleScalarWhereInput = {
      AND?: CycleScalarWhereInput | CycleScalarWhereInput[];
      OR?: CycleScalarWhereInput[];
      NOT?: CycleScalarWhereInput | CycleScalarWhereInput[];
      id?: StringFilter<'Cycle'> | string;
      number?: IntFilter<'Cycle'> | number;
      name?: StringFilter<'Cycle'> | string;
      teamId?: StringFilter<'Cycle'> | string;
      startDate?: DateTimeFilter<'Cycle'> | Date | string;
      endDate?: DateTimeFilter<'Cycle'> | Date | string;
      progress?: IntFilter<'Cycle'> | number;
      createdAt?: DateTimeFilter<'Cycle'> | Date | string;
      updatedAt?: DateTimeFilter<'Cycle'> | Date | string;
   };

   export type TeamCreateWithoutMembersInput = {
      id?: string;
      name: string;
      icon: string;
      joined?: boolean;
      color: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      projects?: TeamProjectCreateNestedManyWithoutTeamInput;
      cycles?: CycleCreateNestedManyWithoutTeamInput;
   };

   export type TeamUncheckedCreateWithoutMembersInput = {
      id?: string;
      name: string;
      icon: string;
      joined?: boolean;
      color: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      projects?: TeamProjectUncheckedCreateNestedManyWithoutTeamInput;
      cycles?: CycleUncheckedCreateNestedManyWithoutTeamInput;
   };

   export type TeamCreateOrConnectWithoutMembersInput = {
      where: TeamWhereUniqueInput;
      create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>;
   };

   export type UserCreateWithoutTeamsInput = {
      id?: string;
      name: string;
      email: string;
      avatarUrl?: string | null;
      status?: $Enums.UserStatus;
      role?: $Enums.UserRole;
      joinedDate: Date | string;
      teamIds?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      assignedIssues?: IssueCreateNestedManyWithoutAssigneeInput;
      ledProjects?: ProjectCreateNestedManyWithoutLeadInput;
   };

   export type UserUncheckedCreateWithoutTeamsInput = {
      id?: string;
      name: string;
      email: string;
      avatarUrl?: string | null;
      status?: $Enums.UserStatus;
      role?: $Enums.UserRole;
      joinedDate: Date | string;
      teamIds?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      assignedIssues?: IssueUncheckedCreateNestedManyWithoutAssigneeInput;
      ledProjects?: ProjectUncheckedCreateNestedManyWithoutLeadInput;
   };

   export type UserCreateOrConnectWithoutTeamsInput = {
      where: UserWhereUniqueInput;
      create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>;
   };

   export type TeamUpsertWithoutMembersInput = {
      update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>;
      create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>;
      where?: TeamWhereInput;
   };

   export type TeamUpdateToOneWithWhereWithoutMembersInput = {
      where?: TeamWhereInput;
      data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>;
   };

   export type TeamUpdateWithoutMembersInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      icon?: StringFieldUpdateOperationsInput | string;
      joined?: BoolFieldUpdateOperationsInput | boolean;
      color?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      projects?: TeamProjectUpdateManyWithoutTeamNestedInput;
      cycles?: CycleUpdateManyWithoutTeamNestedInput;
   };

   export type TeamUncheckedUpdateWithoutMembersInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      icon?: StringFieldUpdateOperationsInput | string;
      joined?: BoolFieldUpdateOperationsInput | boolean;
      color?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      projects?: TeamProjectUncheckedUpdateManyWithoutTeamNestedInput;
      cycles?: CycleUncheckedUpdateManyWithoutTeamNestedInput;
   };

   export type UserUpsertWithoutTeamsInput = {
      update: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>;
      create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>;
      where?: UserWhereInput;
   };

   export type UserUpdateToOneWithWhereWithoutTeamsInput = {
      where?: UserWhereInput;
      data: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>;
   };

   export type UserUpdateWithoutTeamsInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      email?: StringFieldUpdateOperationsInput | string;
      avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
      role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
      joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      teamIds?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      assignedIssues?: IssueUpdateManyWithoutAssigneeNestedInput;
      ledProjects?: ProjectUpdateManyWithoutLeadNestedInput;
   };

   export type UserUncheckedUpdateWithoutTeamsInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      email?: StringFieldUpdateOperationsInput | string;
      avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: EnumUserStatusFieldUpdateOperationsInput | $Enums.UserStatus;
      role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole;
      joinedDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      teamIds?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      assignedIssues?: IssueUncheckedUpdateManyWithoutAssigneeNestedInput;
      ledProjects?: ProjectUncheckedUpdateManyWithoutLeadNestedInput;
   };

   export type TeamCreateWithoutProjectsInput = {
      id?: string;
      name: string;
      icon: string;
      joined?: boolean;
      color: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      members?: TeamMemberCreateNestedManyWithoutTeamInput;
      cycles?: CycleCreateNestedManyWithoutTeamInput;
   };

   export type TeamUncheckedCreateWithoutProjectsInput = {
      id?: string;
      name: string;
      icon: string;
      joined?: boolean;
      color: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput;
      cycles?: CycleUncheckedCreateNestedManyWithoutTeamInput;
   };

   export type TeamCreateOrConnectWithoutProjectsInput = {
      where: TeamWhereUniqueInput;
      create: XOR<TeamCreateWithoutProjectsInput, TeamUncheckedCreateWithoutProjectsInput>;
   };

   export type ProjectCreateWithoutTeamsInput = {
      id?: string;
      name: string;
      description?: string | null;
      color?: string | null;
      identifier?: string | null;
      icon?: string | null;
      percentComplete?: number;
      startDate?: Date | string | null;
      health?: $Enums.ProjectHealth;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      issues?: IssueCreateNestedManyWithoutProjectInput;
      lead?: UserCreateNestedOneWithoutLedProjectsInput;
   };

   export type ProjectUncheckedCreateWithoutTeamsInput = {
      id?: string;
      name: string;
      description?: string | null;
      color?: string | null;
      identifier?: string | null;
      icon?: string | null;
      percentComplete?: number;
      startDate?: Date | string | null;
      health?: $Enums.ProjectHealth;
      leadId?: string | null;
      createdAt?: Date | string;
      updatedAt?: Date | string;
      issues?: IssueUncheckedCreateNestedManyWithoutProjectInput;
   };

   export type ProjectCreateOrConnectWithoutTeamsInput = {
      where: ProjectWhereUniqueInput;
      create: XOR<ProjectCreateWithoutTeamsInput, ProjectUncheckedCreateWithoutTeamsInput>;
   };

   export type TeamUpsertWithoutProjectsInput = {
      update: XOR<TeamUpdateWithoutProjectsInput, TeamUncheckedUpdateWithoutProjectsInput>;
      create: XOR<TeamCreateWithoutProjectsInput, TeamUncheckedCreateWithoutProjectsInput>;
      where?: TeamWhereInput;
   };

   export type TeamUpdateToOneWithWhereWithoutProjectsInput = {
      where?: TeamWhereInput;
      data: XOR<TeamUpdateWithoutProjectsInput, TeamUncheckedUpdateWithoutProjectsInput>;
   };

   export type TeamUpdateWithoutProjectsInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      icon?: StringFieldUpdateOperationsInput | string;
      joined?: BoolFieldUpdateOperationsInput | boolean;
      color?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      members?: TeamMemberUpdateManyWithoutTeamNestedInput;
      cycles?: CycleUpdateManyWithoutTeamNestedInput;
   };

   export type TeamUncheckedUpdateWithoutProjectsInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      icon?: StringFieldUpdateOperationsInput | string;
      joined?: BoolFieldUpdateOperationsInput | boolean;
      color?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput;
      cycles?: CycleUncheckedUpdateManyWithoutTeamNestedInput;
   };

   export type ProjectUpsertWithoutTeamsInput = {
      update: XOR<ProjectUpdateWithoutTeamsInput, ProjectUncheckedUpdateWithoutTeamsInput>;
      create: XOR<ProjectCreateWithoutTeamsInput, ProjectUncheckedCreateWithoutTeamsInput>;
      where?: ProjectWhereInput;
   };

   export type ProjectUpdateToOneWithWhereWithoutTeamsInput = {
      where?: ProjectWhereInput;
      data: XOR<ProjectUpdateWithoutTeamsInput, ProjectUncheckedUpdateWithoutTeamsInput>;
   };

   export type ProjectUpdateWithoutTeamsInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      description?: NullableStringFieldUpdateOperationsInput | string | null;
      color?: NullableStringFieldUpdateOperationsInput | string | null;
      identifier?: NullableStringFieldUpdateOperationsInput | string | null;
      icon?: NullableStringFieldUpdateOperationsInput | string | null;
      percentComplete?: IntFieldUpdateOperationsInput | number;
      startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      health?: EnumProjectHealthFieldUpdateOperationsInput | $Enums.ProjectHealth;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      issues?: IssueUpdateManyWithoutProjectNestedInput;
      lead?: UserUpdateOneWithoutLedProjectsNestedInput;
   };

   export type ProjectUncheckedUpdateWithoutTeamsInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      description?: NullableStringFieldUpdateOperationsInput | string | null;
      color?: NullableStringFieldUpdateOperationsInput | string | null;
      identifier?: NullableStringFieldUpdateOperationsInput | string | null;
      icon?: NullableStringFieldUpdateOperationsInput | string | null;
      percentComplete?: IntFieldUpdateOperationsInput | number;
      startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      health?: EnumProjectHealthFieldUpdateOperationsInput | $Enums.ProjectHealth;
      leadId?: NullableStringFieldUpdateOperationsInput | string | null;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      issues?: IssueUncheckedUpdateManyWithoutProjectNestedInput;
   };

   export type SubtaskCreateManyParentTaskInput = {
      id: string;
      title: string;
      description: string;
      details?: string | null;
      testStrategy?: string | null;
      status: string;
      dependencies?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type TaskDependencyCreateManyTaskInput = {
      id?: number;
      dependsOnId: number;
      createdAt?: Date | string;
   };

   export type TaskDependencyCreateManyDependsOnInput = {
      id?: number;
      taskId: number;
      createdAt?: Date | string;
   };

   export type IssueCreateManyTaskInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      statusId?: string | null;
      priorityId?: string | null;
      status?: string | null;
      priority?: string | null;
      rank: string;
      cycleId?: string | null;
      dueDate?: Date | string | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      assigneeId?: string | null;
      projectId?: string | null;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type SubtaskUpdateWithoutParentTaskInput = {
      id?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: StringFieldUpdateOperationsInput | string;
      dependencies?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type SubtaskUncheckedUpdateWithoutParentTaskInput = {
      id?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: StringFieldUpdateOperationsInput | string;
      dependencies?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type SubtaskUncheckedUpdateManyWithoutParentTaskInput = {
      id?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      details?: NullableStringFieldUpdateOperationsInput | string | null;
      testStrategy?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: StringFieldUpdateOperationsInput | string;
      dependencies?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type TaskDependencyUpdateWithoutTaskInput = {
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      dependsOn?: TaskUpdateOneRequiredWithoutDependentsNestedInput;
   };

   export type TaskDependencyUncheckedUpdateWithoutTaskInput = {
      id?: IntFieldUpdateOperationsInput | number;
      dependsOnId?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type TaskDependencyUncheckedUpdateManyWithoutTaskInput = {
      id?: IntFieldUpdateOperationsInput | number;
      dependsOnId?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type TaskDependencyUpdateWithoutDependsOnInput = {
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      task?: TaskUpdateOneRequiredWithoutDependenciesNestedInput;
   };

   export type TaskDependencyUncheckedUpdateWithoutDependsOnInput = {
      id?: IntFieldUpdateOperationsInput | number;
      taskId?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type TaskDependencyUncheckedUpdateManyWithoutDependsOnInput = {
      id?: IntFieldUpdateOperationsInput | number;
      taskId?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type IssueUpdateWithoutTaskInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      assignee?: UserUpdateOneWithoutAssignedIssuesNestedInput;
      project?: ProjectUpdateOneWithoutIssuesNestedInput;
      cycle?: CycleUpdateOneWithoutIssuesNestedInput;
      issueStatus?: IssueStatusUpdateOneWithoutIssuesNestedInput;
      issuePriority?: IssuePriorityUpdateOneWithoutIssuesNestedInput;
      labels?: IssueLabelUpdateManyWithoutIssueNestedInput;
   };

   export type IssueUncheckedUpdateWithoutTaskInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      statusId?: NullableStringFieldUpdateOperationsInput | string | null;
      priorityId?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      cycleId?: NullableStringFieldUpdateOperationsInput | string | null;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      assigneeId?: NullableStringFieldUpdateOperationsInput | string | null;
      projectId?: NullableStringFieldUpdateOperationsInput | string | null;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      labels?: IssueLabelUncheckedUpdateManyWithoutIssueNestedInput;
   };

   export type IssueUncheckedUpdateManyWithoutTaskInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      statusId?: NullableStringFieldUpdateOperationsInput | string | null;
      priorityId?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      cycleId?: NullableStringFieldUpdateOperationsInput | string | null;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      assigneeId?: NullableStringFieldUpdateOperationsInput | string | null;
      projectId?: NullableStringFieldUpdateOperationsInput | string | null;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type IssueCreateManyAssigneeInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      statusId?: string | null;
      priorityId?: string | null;
      status?: string | null;
      priority?: string | null;
      rank: string;
      cycleId?: string | null;
      dueDate?: Date | string | null;
      taskId?: number | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      projectId?: string | null;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type TeamMemberCreateManyUserInput = {
      id?: string;
      teamId: string;
   };

   export type ProjectCreateManyLeadInput = {
      id?: string;
      name: string;
      description?: string | null;
      color?: string | null;
      identifier?: string | null;
      icon?: string | null;
      percentComplete?: number;
      startDate?: Date | string | null;
      health?: $Enums.ProjectHealth;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type IssueUpdateWithoutAssigneeInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      project?: ProjectUpdateOneWithoutIssuesNestedInput;
      cycle?: CycleUpdateOneWithoutIssuesNestedInput;
      task?: TaskUpdateOneWithoutIssuesNestedInput;
      issueStatus?: IssueStatusUpdateOneWithoutIssuesNestedInput;
      issuePriority?: IssuePriorityUpdateOneWithoutIssuesNestedInput;
      labels?: IssueLabelUpdateManyWithoutIssueNestedInput;
   };

   export type IssueUncheckedUpdateWithoutAssigneeInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      statusId?: NullableStringFieldUpdateOperationsInput | string | null;
      priorityId?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      cycleId?: NullableStringFieldUpdateOperationsInput | string | null;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      taskId?: NullableIntFieldUpdateOperationsInput | number | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      projectId?: NullableStringFieldUpdateOperationsInput | string | null;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      labels?: IssueLabelUncheckedUpdateManyWithoutIssueNestedInput;
   };

   export type IssueUncheckedUpdateManyWithoutAssigneeInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      statusId?: NullableStringFieldUpdateOperationsInput | string | null;
      priorityId?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      cycleId?: NullableStringFieldUpdateOperationsInput | string | null;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      taskId?: NullableIntFieldUpdateOperationsInput | number | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      projectId?: NullableStringFieldUpdateOperationsInput | string | null;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type TeamMemberUpdateWithoutUserInput = {
      id?: StringFieldUpdateOperationsInput | string;
      team?: TeamUpdateOneRequiredWithoutMembersNestedInput;
   };

   export type TeamMemberUncheckedUpdateWithoutUserInput = {
      id?: StringFieldUpdateOperationsInput | string;
      teamId?: StringFieldUpdateOperationsInput | string;
   };

   export type TeamMemberUncheckedUpdateManyWithoutUserInput = {
      id?: StringFieldUpdateOperationsInput | string;
      teamId?: StringFieldUpdateOperationsInput | string;
   };

   export type ProjectUpdateWithoutLeadInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      description?: NullableStringFieldUpdateOperationsInput | string | null;
      color?: NullableStringFieldUpdateOperationsInput | string | null;
      identifier?: NullableStringFieldUpdateOperationsInput | string | null;
      icon?: NullableStringFieldUpdateOperationsInput | string | null;
      percentComplete?: IntFieldUpdateOperationsInput | number;
      startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      health?: EnumProjectHealthFieldUpdateOperationsInput | $Enums.ProjectHealth;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      issues?: IssueUpdateManyWithoutProjectNestedInput;
      teams?: TeamProjectUpdateManyWithoutProjectNestedInput;
   };

   export type ProjectUncheckedUpdateWithoutLeadInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      description?: NullableStringFieldUpdateOperationsInput | string | null;
      color?: NullableStringFieldUpdateOperationsInput | string | null;
      identifier?: NullableStringFieldUpdateOperationsInput | string | null;
      icon?: NullableStringFieldUpdateOperationsInput | string | null;
      percentComplete?: IntFieldUpdateOperationsInput | number;
      startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      health?: EnumProjectHealthFieldUpdateOperationsInput | $Enums.ProjectHealth;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      issues?: IssueUncheckedUpdateManyWithoutProjectNestedInput;
      teams?: TeamProjectUncheckedUpdateManyWithoutProjectNestedInput;
   };

   export type ProjectUncheckedUpdateManyWithoutLeadInput = {
      id?: StringFieldUpdateOperationsInput | string;
      name?: StringFieldUpdateOperationsInput | string;
      description?: NullableStringFieldUpdateOperationsInput | string | null;
      color?: NullableStringFieldUpdateOperationsInput | string | null;
      identifier?: NullableStringFieldUpdateOperationsInput | string | null;
      icon?: NullableStringFieldUpdateOperationsInput | string | null;
      percentComplete?: IntFieldUpdateOperationsInput | number;
      startDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      health?: EnumProjectHealthFieldUpdateOperationsInput | $Enums.ProjectHealth;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type IssueCreateManyProjectInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      statusId?: string | null;
      priorityId?: string | null;
      status?: string | null;
      priority?: string | null;
      rank: string;
      cycleId?: string | null;
      dueDate?: Date | string | null;
      taskId?: number | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      assigneeId?: string | null;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type TeamProjectCreateManyProjectInput = {
      id?: string;
      teamId: string;
   };

   export type IssueUpdateWithoutProjectInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      assignee?: UserUpdateOneWithoutAssignedIssuesNestedInput;
      cycle?: CycleUpdateOneWithoutIssuesNestedInput;
      task?: TaskUpdateOneWithoutIssuesNestedInput;
      issueStatus?: IssueStatusUpdateOneWithoutIssuesNestedInput;
      issuePriority?: IssuePriorityUpdateOneWithoutIssuesNestedInput;
      labels?: IssueLabelUpdateManyWithoutIssueNestedInput;
   };

   export type IssueUncheckedUpdateWithoutProjectInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      statusId?: NullableStringFieldUpdateOperationsInput | string | null;
      priorityId?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      cycleId?: NullableStringFieldUpdateOperationsInput | string | null;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      taskId?: NullableIntFieldUpdateOperationsInput | number | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      assigneeId?: NullableStringFieldUpdateOperationsInput | string | null;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      labels?: IssueLabelUncheckedUpdateManyWithoutIssueNestedInput;
   };

   export type IssueUncheckedUpdateManyWithoutProjectInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      statusId?: NullableStringFieldUpdateOperationsInput | string | null;
      priorityId?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      cycleId?: NullableStringFieldUpdateOperationsInput | string | null;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      taskId?: NullableIntFieldUpdateOperationsInput | number | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      assigneeId?: NullableStringFieldUpdateOperationsInput | string | null;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type TeamProjectUpdateWithoutProjectInput = {
      id?: StringFieldUpdateOperationsInput | string;
      team?: TeamUpdateOneRequiredWithoutProjectsNestedInput;
   };

   export type TeamProjectUncheckedUpdateWithoutProjectInput = {
      id?: StringFieldUpdateOperationsInput | string;
      teamId?: StringFieldUpdateOperationsInput | string;
   };

   export type TeamProjectUncheckedUpdateManyWithoutProjectInput = {
      id?: StringFieldUpdateOperationsInput | string;
      teamId?: StringFieldUpdateOperationsInput | string;
   };

   export type IssueLabelCreateManyLabelInput = {
      id?: string;
      issueId: string;
   };

   export type IssueLabelUpdateWithoutLabelInput = {
      id?: StringFieldUpdateOperationsInput | string;
      issue?: IssueUpdateOneRequiredWithoutLabelsNestedInput;
   };

   export type IssueLabelUncheckedUpdateWithoutLabelInput = {
      id?: StringFieldUpdateOperationsInput | string;
      issueId?: StringFieldUpdateOperationsInput | string;
   };

   export type IssueLabelUncheckedUpdateManyWithoutLabelInput = {
      id?: StringFieldUpdateOperationsInput | string;
      issueId?: StringFieldUpdateOperationsInput | string;
   };

   export type IssueCreateManyIssueStatusInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      priorityId?: string | null;
      status?: string | null;
      priority?: string | null;
      rank: string;
      cycleId?: string | null;
      dueDate?: Date | string | null;
      taskId?: number | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      assigneeId?: string | null;
      projectId?: string | null;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type IssueUpdateWithoutIssueStatusInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      assignee?: UserUpdateOneWithoutAssignedIssuesNestedInput;
      project?: ProjectUpdateOneWithoutIssuesNestedInput;
      cycle?: CycleUpdateOneWithoutIssuesNestedInput;
      task?: TaskUpdateOneWithoutIssuesNestedInput;
      issuePriority?: IssuePriorityUpdateOneWithoutIssuesNestedInput;
      labels?: IssueLabelUpdateManyWithoutIssueNestedInput;
   };

   export type IssueUncheckedUpdateWithoutIssueStatusInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      priorityId?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      cycleId?: NullableStringFieldUpdateOperationsInput | string | null;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      taskId?: NullableIntFieldUpdateOperationsInput | number | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      assigneeId?: NullableStringFieldUpdateOperationsInput | string | null;
      projectId?: NullableStringFieldUpdateOperationsInput | string | null;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      labels?: IssueLabelUncheckedUpdateManyWithoutIssueNestedInput;
   };

   export type IssueUncheckedUpdateManyWithoutIssueStatusInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      priorityId?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      cycleId?: NullableStringFieldUpdateOperationsInput | string | null;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      taskId?: NullableIntFieldUpdateOperationsInput | number | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      assigneeId?: NullableStringFieldUpdateOperationsInput | string | null;
      projectId?: NullableStringFieldUpdateOperationsInput | string | null;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type IssueCreateManyIssuePriorityInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      statusId?: string | null;
      status?: string | null;
      priority?: string | null;
      rank: string;
      cycleId?: string | null;
      dueDate?: Date | string | null;
      taskId?: number | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      assigneeId?: string | null;
      projectId?: string | null;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type IssueUpdateWithoutIssuePriorityInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      assignee?: UserUpdateOneWithoutAssignedIssuesNestedInput;
      project?: ProjectUpdateOneWithoutIssuesNestedInput;
      cycle?: CycleUpdateOneWithoutIssuesNestedInput;
      task?: TaskUpdateOneWithoutIssuesNestedInput;
      issueStatus?: IssueStatusUpdateOneWithoutIssuesNestedInput;
      labels?: IssueLabelUpdateManyWithoutIssueNestedInput;
   };

   export type IssueUncheckedUpdateWithoutIssuePriorityInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      statusId?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      cycleId?: NullableStringFieldUpdateOperationsInput | string | null;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      taskId?: NullableIntFieldUpdateOperationsInput | number | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      assigneeId?: NullableStringFieldUpdateOperationsInput | string | null;
      projectId?: NullableStringFieldUpdateOperationsInput | string | null;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      labels?: IssueLabelUncheckedUpdateManyWithoutIssueNestedInput;
   };

   export type IssueUncheckedUpdateManyWithoutIssuePriorityInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      statusId?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      cycleId?: NullableStringFieldUpdateOperationsInput | string | null;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      taskId?: NullableIntFieldUpdateOperationsInput | number | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      assigneeId?: NullableStringFieldUpdateOperationsInput | string | null;
      projectId?: NullableStringFieldUpdateOperationsInput | string | null;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type IssueLabelCreateManyIssueInput = {
      id?: string;
      labelId: string;
   };

   export type IssueLabelUpdateWithoutIssueInput = {
      id?: StringFieldUpdateOperationsInput | string;
      label?: LabelUpdateOneRequiredWithoutIssuesNestedInput;
   };

   export type IssueLabelUncheckedUpdateWithoutIssueInput = {
      id?: StringFieldUpdateOperationsInput | string;
      labelId?: StringFieldUpdateOperationsInput | string;
   };

   export type IssueLabelUncheckedUpdateManyWithoutIssueInput = {
      id?: StringFieldUpdateOperationsInput | string;
      labelId?: StringFieldUpdateOperationsInput | string;
   };

   export type IssueCreateManyCycleInput = {
      id?: string;
      identifier: string;
      title: string;
      description: string;
      statusId?: string | null;
      priorityId?: string | null;
      status?: string | null;
      priority?: string | null;
      rank: string;
      dueDate?: Date | string | null;
      taskId?: number | null;
      subtaskId?: string | null;
      issueType: $Enums.IssueType;
      assigneeId?: string | null;
      projectId?: string | null;
      subissues?: string;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type IssueUpdateWithoutCycleInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      assignee?: UserUpdateOneWithoutAssignedIssuesNestedInput;
      project?: ProjectUpdateOneWithoutIssuesNestedInput;
      task?: TaskUpdateOneWithoutIssuesNestedInput;
      issueStatus?: IssueStatusUpdateOneWithoutIssuesNestedInput;
      issuePriority?: IssuePriorityUpdateOneWithoutIssuesNestedInput;
      labels?: IssueLabelUpdateManyWithoutIssueNestedInput;
   };

   export type IssueUncheckedUpdateWithoutCycleInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      statusId?: NullableStringFieldUpdateOperationsInput | string | null;
      priorityId?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      taskId?: NullableIntFieldUpdateOperationsInput | number | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      assigneeId?: NullableStringFieldUpdateOperationsInput | string | null;
      projectId?: NullableStringFieldUpdateOperationsInput | string | null;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      labels?: IssueLabelUncheckedUpdateManyWithoutIssueNestedInput;
   };

   export type IssueUncheckedUpdateManyWithoutCycleInput = {
      id?: StringFieldUpdateOperationsInput | string;
      identifier?: StringFieldUpdateOperationsInput | string;
      title?: StringFieldUpdateOperationsInput | string;
      description?: StringFieldUpdateOperationsInput | string;
      statusId?: NullableStringFieldUpdateOperationsInput | string | null;
      priorityId?: NullableStringFieldUpdateOperationsInput | string | null;
      status?: NullableStringFieldUpdateOperationsInput | string | null;
      priority?: NullableStringFieldUpdateOperationsInput | string | null;
      rank?: StringFieldUpdateOperationsInput | string;
      dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null;
      taskId?: NullableIntFieldUpdateOperationsInput | number | null;
      subtaskId?: NullableStringFieldUpdateOperationsInput | string | null;
      issueType?: EnumIssueTypeFieldUpdateOperationsInput | $Enums.IssueType;
      assigneeId?: NullableStringFieldUpdateOperationsInput | string | null;
      projectId?: NullableStringFieldUpdateOperationsInput | string | null;
      subissues?: StringFieldUpdateOperationsInput | string;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   export type TeamMemberCreateManyTeamInput = {
      id?: string;
      userId: string;
   };

   export type TeamProjectCreateManyTeamInput = {
      id?: string;
      projectId: string;
   };

   export type CycleCreateManyTeamInput = {
      id?: string;
      number: number;
      name: string;
      startDate: Date | string;
      endDate: Date | string;
      progress?: number;
      createdAt?: Date | string;
      updatedAt?: Date | string;
   };

   export type TeamMemberUpdateWithoutTeamInput = {
      id?: StringFieldUpdateOperationsInput | string;
      user?: UserUpdateOneRequiredWithoutTeamsNestedInput;
   };

   export type TeamMemberUncheckedUpdateWithoutTeamInput = {
      id?: StringFieldUpdateOperationsInput | string;
      userId?: StringFieldUpdateOperationsInput | string;
   };

   export type TeamMemberUncheckedUpdateManyWithoutTeamInput = {
      id?: StringFieldUpdateOperationsInput | string;
      userId?: StringFieldUpdateOperationsInput | string;
   };

   export type TeamProjectUpdateWithoutTeamInput = {
      id?: StringFieldUpdateOperationsInput | string;
      project?: ProjectUpdateOneRequiredWithoutTeamsNestedInput;
   };

   export type TeamProjectUncheckedUpdateWithoutTeamInput = {
      id?: StringFieldUpdateOperationsInput | string;
      projectId?: StringFieldUpdateOperationsInput | string;
   };

   export type TeamProjectUncheckedUpdateManyWithoutTeamInput = {
      id?: StringFieldUpdateOperationsInput | string;
      projectId?: StringFieldUpdateOperationsInput | string;
   };

   export type CycleUpdateWithoutTeamInput = {
      id?: StringFieldUpdateOperationsInput | string;
      number?: IntFieldUpdateOperationsInput | number;
      name?: StringFieldUpdateOperationsInput | string;
      startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      progress?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      issues?: IssueUpdateManyWithoutCycleNestedInput;
   };

   export type CycleUncheckedUpdateWithoutTeamInput = {
      id?: StringFieldUpdateOperationsInput | string;
      number?: IntFieldUpdateOperationsInput | number;
      name?: StringFieldUpdateOperationsInput | string;
      startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      progress?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      issues?: IssueUncheckedUpdateManyWithoutCycleNestedInput;
   };

   export type CycleUncheckedUpdateManyWithoutTeamInput = {
      id?: StringFieldUpdateOperationsInput | string;
      number?: IntFieldUpdateOperationsInput | number;
      name?: StringFieldUpdateOperationsInput | string;
      startDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      endDate?: DateTimeFieldUpdateOperationsInput | Date | string;
      progress?: IntFieldUpdateOperationsInput | number;
      createdAt?: DateTimeFieldUpdateOperationsInput | Date | string;
      updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string;
   };

   /**
    * Batch Payload for updateMany & deleteMany & createMany
    */

   export type BatchPayload = {
      count: number;
   };

   /**
    * DMMF
    */
   export const dmmf: runtime.BaseDMMF;
}
